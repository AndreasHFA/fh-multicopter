
STM32F3_Multicopter.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000aba0  08000188  08000188  00008188  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000140  20000000  0800ad28  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00002cc4  20000140  20000140  00018140  2**2
                  ALLOC
  4 ._user_heap_stack 00000200  20002e04  20002e04  00018140  2**0
                  ALLOC
  5 .ARM.attributes 00000031  00000000  00000000  00018140  2**0
                  CONTENTS, READONLY
  6 .debug_info   00016a4d  00000000  00000000  00018171  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004139  00000000  00000000  0002ebbe  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000004a8  00000000  00000000  00032cf8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macro  00012f52  00000000  00000000  000331a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000cbd8  00000000  00000000  000460f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0005cfb3  00000000  00000000  00052cca  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000030  00000000  00000000  000afc7d  2**0
                  CONTENTS, READONLY
 13 .debug_loc    0000b1c9  00000000  00000000  000afcad  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003404  00000000  00000000  000bae78  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000248  00000000  00000000  000be280  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <IMU_init>:
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	

	IMU->dcm_xe_line[0] = 1;
	IMU->dcm_xe_line[1] = 0;
 8000188:	2300      	movs	r3, #0
/*Initialization of the main dcm-variables used for the Gyro input*/
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	

	IMU->dcm_xe_line[0] = 1;
 800018a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000


/*Initialization of the main dcm-variables used for the Gyro input*/
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	
 800018e:	6001      	str	r1, [r0, #0]

	IMU->dcm_xe_line[0] = 1;
 8000190:	6042      	str	r2, [r0, #4]
	IMU->dcm_xe_line[1] = 0;
 8000192:	6083      	str	r3, [r0, #8]
	IMU->dcm_xe_line[2] = 0;
 8000194:	60c3      	str	r3, [r0, #12]

	IMU->dcm_ye_line[0] = 0;
 8000196:	6103      	str	r3, [r0, #16]
	IMU->dcm_ye_line[1] = 1;
 8000198:	6142      	str	r2, [r0, #20]
	IMU->dcm_ye_line[2] = 0;
 800019a:	6183      	str	r3, [r0, #24]

	IMU->dcm_ze_line[0] = 0;
 800019c:	61c3      	str	r3, [r0, #28]
	IMU->dcm_ze_line[1] = 0;
 800019e:	6203      	str	r3, [r0, #32]
	IMU->dcm_ze_line[2] = 1;			
 80001a0:	6242      	str	r2, [r0, #36]	; 0x24

	IMU->velocity_vector[0] = 0;
 80001a2:	6283      	str	r3, [r0, #40]	; 0x28
	IMU->velocity_vector[1] = 0;
 80001a4:	62c3      	str	r3, [r0, #44]	; 0x2c
	IMU->velocity_vector[2] = 0;
 80001a6:	6303      	str	r3, [r0, #48]	; 0x30
 80001a8:	4770      	bx	lr

080001aa <IMU_init_drift_correction>:
/*Initialization of the drift-correction variables - this is mainly solved with a PI-Controller*/
void IMU_init_drift_correction(struct IMU_values *IMU, float kp)
{
	IMU->kp = kp;

	IMU->accel_vector[0] = 0;
 80001aa:	2300      	movs	r3, #0


/*Initialization of the drift-correction variables - this is mainly solved with a PI-Controller*/
void IMU_init_drift_correction(struct IMU_values *IMU, float kp)
{
	IMU->kp = kp;
 80001ac:	64c1      	str	r1, [r0, #76]	; 0x4c

	IMU->accel_vector[0] = 0;
 80001ae:	6343      	str	r3, [r0, #52]	; 0x34
	IMU->accel_vector[1] = 0;
 80001b0:	6383      	str	r3, [r0, #56]	; 0x38
	IMU->accel_vector[2] = 0;
 80001b2:	63c3      	str	r3, [r0, #60]	; 0x3c

	IMU->mag_vector[0] = 0;
 80001b4:	6403      	str	r3, [r0, #64]	; 0x40
	IMU->mag_vector[1] = 0;
 80001b6:	6443      	str	r3, [r0, #68]	; 0x44
	IMU->mag_vector[2] = 0;
 80001b8:	6483      	str	r3, [r0, #72]	; 0x48

	IMU->kp_vector_ACC[0] = 0;
 80001ba:	6603      	str	r3, [r0, #96]	; 0x60
	IMU->kp_vector_ACC[1] = 0;
 80001bc:	6643      	str	r3, [r0, #100]	; 0x64
	IMU->kp_vector_ACC[2] = 0;
 80001be:	6683      	str	r3, [r0, #104]	; 0x68

	IMU->kp_vector_MAG[0] = 0;
 80001c0:	66c3      	str	r3, [r0, #108]	; 0x6c
	IMU->kp_vector_MAG[1] = 0;
 80001c2:	6703      	str	r3, [r0, #112]	; 0x70
	IMU->kp_vector_MAG[2] = 0;
 80001c4:	6743      	str	r3, [r0, #116]	; 0x74

	IMU->error_rollpitch[0] = 0;
 80001c6:	6503      	str	r3, [r0, #80]	; 0x50
	IMU->error_rollpitch[1] = 0;
 80001c8:	6543      	str	r3, [r0, #84]	; 0x54
	IMU->error_rollpitch[2] = 0;
 80001ca:	6583      	str	r3, [r0, #88]	; 0x58

	IMU->error_yaw = 0;
 80001cc:	65c3      	str	r3, [r0, #92]	; 0x5c
 80001ce:	4770      	bx	lr

080001d0 <IMU_update>:
}


/*Update of the dcm-matrix*/
void IMU_update(struct IMU_values *IMU)
{
 80001d0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001d2:	6805      	ldr	r5, [r0, #0]
}


/*Update of the dcm-matrix*/
void IMU_update(struct IMU_values *IMU)
{
 80001d4:	4604      	mov	r4, r0
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001d6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80001d8:	4628      	mov	r0, r5
 80001da:	f007 fcbd 	bl	8007b58 <__aeabi_fmul>
 80001de:	6e21      	ldr	r1, [r4, #96]	; 0x60
 80001e0:	f007 fbb0 	bl	8007944 <__aeabi_fsub>
 80001e4:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 80001e6:	f007 fbad 	bl	8007944 <__aeabi_fsub>
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 80001ea:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
void IMU_update(struct IMU_values *IMU)
{
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001ec:	62a0      	str	r0, [r4, #40]	; 0x28
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 80001ee:	4628      	mov	r0, r5
 80001f0:	f007 fcb2 	bl	8007b58 <__aeabi_fmul>
 80001f4:	6e61      	ldr	r1, [r4, #100]	; 0x64
 80001f6:	f007 fba5 	bl	8007944 <__aeabi_fsub>
 80001fa:	6f21      	ldr	r1, [r4, #112]	; 0x70
 80001fc:	f007 fba2 	bl	8007944 <__aeabi_fsub>
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 8000200:	6b21      	ldr	r1, [r4, #48]	; 0x30
{
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 8000202:	62e0      	str	r0, [r4, #44]	; 0x2c
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 8000204:	4628      	mov	r0, r5
 8000206:	f007 fca7 	bl	8007b58 <__aeabi_fmul>
 800020a:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 800020c:	f007 fb9a 	bl	8007944 <__aeabi_fsub>
 8000210:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8000212:	f007 fb97 	bl	8007944 <__aeabi_fsub>

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
 8000216:	1d26      	adds	r6, r4, #4
 8000218:	f104 0528 	add.w	r5, r4, #40	; 0x28
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 800021c:	6320      	str	r0, [r4, #48]	; 0x30

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
 800021e:	4631      	mov	r1, r6
 8000220:	a801      	add	r0, sp, #4
 8000222:	462a      	mov	r2, r5
 8000224:	f000 fe3c 	bl	8000ea0 <VectorCrossProduct>
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);
 8000228:	4630      	mov	r0, r6
 800022a:	4631      	mov	r1, r6
 800022c:	aa01      	add	r2, sp, #4

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
 800022e:	f104 0610 	add.w	r6, r4, #16
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);
 8000232:	f000 fe78 	bl	8000f26 <VectorAdd>

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
 8000236:	a801      	add	r0, sp, #4
 8000238:	4631      	mov	r1, r6
 800023a:	462a      	mov	r2, r5
 800023c:	f000 fe30 	bl	8000ea0 <VectorCrossProduct>
	VectorAdd(IMU->dcm_ye_line, IMU->dcm_ye_line, result);

	/*Update of the second dcm-line(ze)*/
	VectorCrossProduct(result, IMU->dcm_ze_line, IMU->velocity_vector);
 8000240:	341c      	adds	r4, #28
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_ye_line, IMU->dcm_ye_line, result);
 8000242:	4630      	mov	r0, r6
 8000244:	4631      	mov	r1, r6
 8000246:	aa01      	add	r2, sp, #4
 8000248:	f000 fe6d 	bl	8000f26 <VectorAdd>

	/*Update of the second dcm-line(ze)*/
	VectorCrossProduct(result, IMU->dcm_ze_line, IMU->velocity_vector);
 800024c:	a801      	add	r0, sp, #4
 800024e:	4621      	mov	r1, r4
 8000250:	462a      	mov	r2, r5
 8000252:	f000 fe25 	bl	8000ea0 <VectorCrossProduct>
	VectorAdd(IMU->dcm_ze_line, IMU->dcm_ze_line, result);
 8000256:	4620      	mov	r0, r4
 8000258:	4621      	mov	r1, r4
 800025a:	aa01      	add	r2, sp, #4
 800025c:	f000 fe63 	bl	8000f26 <VectorAdd>
}
 8000260:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

08000262 <IMU_normalize>:


/*Normalization of the vectors*/
void IMU_normalize(struct IMU_values *IMU)
{
 8000262:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000264:	4604      	mov	r4, r0
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
 8000266:	6840      	ldr	r0, [r0, #4]
 8000268:	68a7      	ldr	r7, [r4, #8]
 800026a:	4601      	mov	r1, r0
 800026c:	f007 fc74 	bl	8007b58 <__aeabi_fmul>
 8000270:	4639      	mov	r1, r7
 8000272:	4605      	mov	r5, r0
 8000274:	4638      	mov	r0, r7
 8000276:	f007 fc6f 	bl	8007b58 <__aeabi_fmul>
 800027a:	4601      	mov	r1, r0
 800027c:	4628      	mov	r0, r5
 800027e:	f007 fb63 	bl	8007948 <__addsf3>
 8000282:	68e6      	ldr	r6, [r4, #12]
 8000284:	4605      	mov	r5, r0
 8000286:	4631      	mov	r1, r6
 8000288:	4630      	mov	r0, r6
 800028a:	f007 fc65 	bl	8007b58 <__aeabi_fmul>
 800028e:	4601      	mov	r1, r0
 8000290:	4628      	mov	r0, r5
 8000292:	f007 fb59 	bl	8007948 <__addsf3>
 8000296:	f008 f90d 	bl	80084b4 <sqrtf>
 800029a:	4605      	mov	r5, r0
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
 800029c:	4629      	mov	r1, r5
 800029e:	6860      	ldr	r0, [r4, #4]
 80002a0:	f007 fd0e 	bl	8007cc0 <__aeabi_fdiv>
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
 80002a4:	4629      	mov	r1, r5
/*Normalization of the vectors*/
void IMU_normalize(struct IMU_values *IMU)
{
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
 80002a6:	6060      	str	r0, [r4, #4]
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
 80002a8:	68a0      	ldr	r0, [r4, #8]
 80002aa:	f007 fd09 	bl	8007cc0 <__aeabi_fdiv>
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	
 80002ae:	4629      	mov	r1, r5
void IMU_normalize(struct IMU_values *IMU)
{
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
 80002b0:	60a0      	str	r0, [r4, #8]
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	
 80002b2:	68e0      	ldr	r0, [r4, #12]
 80002b4:	f007 fd04 	bl	8007cc0 <__aeabi_fdiv>
 80002b8:	60e0      	str	r0, [r4, #12]

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
 80002ba:	6920      	ldr	r0, [r4, #16]
 80002bc:	6967      	ldr	r7, [r4, #20]
 80002be:	4601      	mov	r1, r0
 80002c0:	f007 fc4a 	bl	8007b58 <__aeabi_fmul>
 80002c4:	4639      	mov	r1, r7
 80002c6:	4605      	mov	r5, r0
 80002c8:	4638      	mov	r0, r7
 80002ca:	f007 fc45 	bl	8007b58 <__aeabi_fmul>
 80002ce:	4601      	mov	r1, r0
 80002d0:	4628      	mov	r0, r5
 80002d2:	f007 fb39 	bl	8007948 <__addsf3>
 80002d6:	69a6      	ldr	r6, [r4, #24]
 80002d8:	4605      	mov	r5, r0
 80002da:	4631      	mov	r1, r6
 80002dc:	4630      	mov	r0, r6
 80002de:	f007 fc3b 	bl	8007b58 <__aeabi_fmul>
 80002e2:	4601      	mov	r1, r0
 80002e4:	4628      	mov	r0, r5
 80002e6:	f007 fb2f 	bl	8007948 <__addsf3>
 80002ea:	f008 f8e3 	bl	80084b4 <sqrtf>
 80002ee:	4605      	mov	r5, r0
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
 80002f0:	4629      	mov	r1, r5
 80002f2:	6920      	ldr	r0, [r4, #16]
 80002f4:	f007 fce4 	bl	8007cc0 <__aeabi_fdiv>
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
 80002f8:	4629      	mov	r1, r5
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
 80002fa:	6120      	str	r0, [r4, #16]
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
 80002fc:	6960      	ldr	r0, [r4, #20]
 80002fe:	f007 fcdf 	bl	8007cc0 <__aeabi_fdiv>
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	
 8000302:	4629      	mov	r1, r5
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
 8000304:	6160      	str	r0, [r4, #20]
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	
 8000306:	69a0      	ldr	r0, [r4, #24]
 8000308:	f007 fcda 	bl	8007cc0 <__aeabi_fdiv>
 800030c:	61a0      	str	r0, [r4, #24]

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
 800030e:	69e0      	ldr	r0, [r4, #28]
 8000310:	6a27      	ldr	r7, [r4, #32]
 8000312:	4601      	mov	r1, r0
 8000314:	f007 fc20 	bl	8007b58 <__aeabi_fmul>
 8000318:	4639      	mov	r1, r7
 800031a:	4605      	mov	r5, r0
 800031c:	4638      	mov	r0, r7
 800031e:	f007 fc1b 	bl	8007b58 <__aeabi_fmul>
 8000322:	4601      	mov	r1, r0
 8000324:	4628      	mov	r0, r5
 8000326:	f007 fb0f 	bl	8007948 <__addsf3>
 800032a:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800032c:	4605      	mov	r5, r0
 800032e:	4631      	mov	r1, r6
 8000330:	4630      	mov	r0, r6
 8000332:	f007 fc11 	bl	8007b58 <__aeabi_fmul>
 8000336:	4601      	mov	r1, r0
 8000338:	4628      	mov	r0, r5
 800033a:	f007 fb05 	bl	8007948 <__addsf3>
 800033e:	f008 f8b9 	bl	80084b4 <sqrtf>
 8000342:	4605      	mov	r5, r0
	IMU->dcm_ze_line[0] = IMU->dcm_ze_line[0]/normfactor;	
 8000344:	4629      	mov	r1, r5
 8000346:	69e0      	ldr	r0, [r4, #28]
 8000348:	f007 fcba 	bl	8007cc0 <__aeabi_fdiv>
	IMU->dcm_ze_line[1] = IMU->dcm_ze_line[1]/normfactor;	
 800034c:	4629      	mov	r1, r5
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
	IMU->dcm_ze_line[0] = IMU->dcm_ze_line[0]/normfactor;	
 800034e:	61e0      	str	r0, [r4, #28]
	IMU->dcm_ze_line[1] = IMU->dcm_ze_line[1]/normfactor;	
 8000350:	6a20      	ldr	r0, [r4, #32]
 8000352:	f007 fcb5 	bl	8007cc0 <__aeabi_fdiv>
	IMU->dcm_ze_line[2] = IMU->dcm_ze_line[2]/normfactor;		
 8000356:	4629      	mov	r1, r5
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
	IMU->dcm_ze_line[0] = IMU->dcm_ze_line[0]/normfactor;	
	IMU->dcm_ze_line[1] = IMU->dcm_ze_line[1]/normfactor;	
 8000358:	6220      	str	r0, [r4, #32]
	IMU->dcm_ze_line[2] = IMU->dcm_ze_line[2]/normfactor;		
 800035a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800035c:	f007 fcb0 	bl	8007cc0 <__aeabi_fdiv>
 8000360:	6260      	str	r0, [r4, #36]	; 0x24
 8000362:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000364 <IMU_ortho_adjust>:
}

/*Keep the orthogonality*/
void IMU_ortho_adjust(struct IMU_values *IMU)
{
 8000364:	b5f0      	push	{r4, r5, r6, r7, lr}

	float result_x[3];
	float result_y[3];

	/*calc the orthogonality error*/	
	ortho_error = -VectorDotProduct(&IMU->dcm_xe_line[0], &IMU->dcm_ye_line[0])*0.5f;
 8000366:	f100 0410 	add.w	r4, r0, #16
 800036a:	1d05      	adds	r5, r0, #4
	IMU->dcm_ze_line[2] = IMU->dcm_ze_line[2]/normfactor;		
}

/*Keep the orthogonality*/
void IMU_ortho_adjust(struct IMU_values *IMU)
{
 800036c:	b087      	sub	sp, #28
 800036e:	4606      	mov	r6, r0

	float result_x[3];
	float result_y[3];

	/*calc the orthogonality error*/	
	ortho_error = -VectorDotProduct(&IMU->dcm_xe_line[0], &IMU->dcm_ye_line[0])*0.5f;
 8000370:	4621      	mov	r1, r4
 8000372:	4628      	mov	r0, r5
 8000374:	f000 fd82 	bl	8000e7c <VectorDotProduct>
 8000378:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800037c:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8000380:	f007 fbea 	bl	8007b58 <__aeabi_fmul>
 8000384:	4607      	mov	r7, r0
	
	/*add the half of the error to xe and ye*/
	VectorScale(&result_y[0],&IMU->dcm_ye_line[0],ortho_error);
 8000386:	4621      	mov	r1, r4
 8000388:	a803      	add	r0, sp, #12
 800038a:	463a      	mov	r2, r7
 800038c:	f000 fdb7 	bl	8000efe <VectorScale>
	VectorScale(&result_x[0],&IMU->dcm_xe_line[0],ortho_error);
 8000390:	4668      	mov	r0, sp
 8000392:	4629      	mov	r1, r5
 8000394:	463a      	mov	r2, r7
 8000396:	f000 fdb2 	bl	8000efe <VectorScale>

	VectorAdd(&IMU->dcm_xe_line[0], &IMU->dcm_xe_line[0], &result_y[0]);
 800039a:	4628      	mov	r0, r5
 800039c:	4629      	mov	r1, r5
 800039e:	aa03      	add	r2, sp, #12
 80003a0:	f000 fdc1 	bl	8000f26 <VectorAdd>
	VectorAdd(&IMU->dcm_ye_line[0], &IMU->dcm_ye_line[0], &result_x[0]);
 80003a4:	4620      	mov	r0, r4
 80003a6:	4621      	mov	r1, r4
 80003a8:	466a      	mov	r2, sp
 80003aa:	f000 fdbc 	bl	8000f26 <VectorAdd>
	
	/*the ze-line will be recalculated with the crossproduct*/	
	VectorCrossProduct(&IMU->dcm_ze_line[0],&IMU->dcm_xe_line[0],&IMU->dcm_ye_line[0]);   
 80003ae:	f106 001c 	add.w	r0, r6, #28
 80003b2:	4629      	mov	r1, r5
 80003b4:	4622      	mov	r2, r4
 80003b6:	f000 fd73 	bl	8000ea0 <VectorCrossProduct>
}
 80003ba:	b007      	add	sp, #28
 80003bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080003be <IMU_drift_correction_ACC>:


/*Roll-pitch Drift-Correction with Accelerometer*/
void IMU_drift_correction_ACC(struct IMU_values *IMU)
{
 80003be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80003c2:	4604      	mov	r4, r0
	float normfactor;
	float error_absolute;

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));
 80003c4:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80003c6:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 80003c8:	4601      	mov	r1, r0
 80003ca:	f007 fbc5 	bl	8007b58 <__aeabi_fmul>
 80003ce:	4639      	mov	r1, r7
 80003d0:	4605      	mov	r5, r0
 80003d2:	4638      	mov	r0, r7
 80003d4:	f007 fbc0 	bl	8007b58 <__aeabi_fmul>
 80003d8:	4601      	mov	r1, r0
 80003da:	4628      	mov	r0, r5
 80003dc:	f007 fab4 	bl	8007948 <__addsf3>
 80003e0:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 80003e2:	4605      	mov	r5, r0
 80003e4:	4631      	mov	r1, r6
 80003e6:	4630      	mov	r0, r6
 80003e8:	f007 fbb6 	bl	8007b58 <__aeabi_fmul>
 80003ec:	4601      	mov	r1, r0
 80003ee:	4628      	mov	r0, r5
 80003f0:	f007 faaa 	bl	8007948 <__addsf3>
 80003f4:	f008 f85e 	bl	80084b4 <sqrtf>

	if(normfactor != 0)
 80003f8:	2100      	movs	r1, #0
void IMU_drift_correction_ACC(struct IMU_values *IMU)
{
	float normfactor;
	float error_absolute;

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));
 80003fa:	4605      	mov	r5, r0

	if(normfactor != 0)
 80003fc:	f007 fd40 	bl	8007e80 <__aeabi_fcmpeq>
 8000400:	b970      	cbnz	r0, 8000420 <IMU_drift_correction_ACC+0x62>
	{
		IMU->accel_vector[0] = IMU->accel_vector[0]/normfactor;
 8000402:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8000404:	4629      	mov	r1, r5
 8000406:	f007 fc5b 	bl	8007cc0 <__aeabi_fdiv>
		IMU->accel_vector[1] = IMU->accel_vector[1]/normfactor;
 800040a:	4629      	mov	r1, r5

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));

	if(normfactor != 0)
	{
		IMU->accel_vector[0] = IMU->accel_vector[0]/normfactor;
 800040c:	6360      	str	r0, [r4, #52]	; 0x34
		IMU->accel_vector[1] = IMU->accel_vector[1]/normfactor;
 800040e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8000410:	f007 fc56 	bl	8007cc0 <__aeabi_fdiv>
		IMU->accel_vector[2] = IMU->accel_vector[2]/normfactor;
 8000414:	4629      	mov	r1, r5
	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));

	if(normfactor != 0)
	{
		IMU->accel_vector[0] = IMU->accel_vector[0]/normfactor;
		IMU->accel_vector[1] = IMU->accel_vector[1]/normfactor;
 8000416:	63a0      	str	r0, [r4, #56]	; 0x38
		IMU->accel_vector[2] = IMU->accel_vector[2]/normfactor;
 8000418:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800041a:	f007 fc51 	bl	8007cc0 <__aeabi_fdiv>
 800041e:	63e0      	str	r0, [r4, #60]	; 0x3c
	}
	
	/*Calc the error between the gyrobased calculations and the vector of the accelerometer, 
	this will be done with the crossproduct of the two vectors*/
	VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &IMU->accel_vector[0]);
 8000420:	f104 0550 	add.w	r5, r4, #80	; 0x50
 8000424:	f104 0234 	add.w	r2, r4, #52	; 0x34
 8000428:	4628      	mov	r0, r5
 800042a:	f104 011c 	add.w	r1, r4, #28
 800042e:	f000 fd37 	bl	8000ea0 <VectorCrossProduct>
	//VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &test[0]);
	
	error_absolute = sqrtf((IMU->error_rollpitch[0]*IMU->error_rollpitch[0]) + (IMU->error_rollpitch[1]*IMU->error_rollpitch[1]) + (IMU->error_rollpitch[2]*IMU->error_rollpitch[2]));
 8000432:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8000434:	f8d4 8054 	ldr.w	r8, [r4, #84]	; 0x54
 8000438:	4601      	mov	r1, r0
 800043a:	f007 fb8d 	bl	8007b58 <__aeabi_fmul>
 800043e:	4641      	mov	r1, r8
 8000440:	4606      	mov	r6, r0
 8000442:	4640      	mov	r0, r8
 8000444:	f007 fb88 	bl	8007b58 <__aeabi_fmul>
 8000448:	4601      	mov	r1, r0
 800044a:	4630      	mov	r0, r6
 800044c:	f007 fa7c 	bl	8007948 <__addsf3>
 8000450:	6da7      	ldr	r7, [r4, #88]	; 0x58
 8000452:	4606      	mov	r6, r0
 8000454:	4639      	mov	r1, r7
 8000456:	4638      	mov	r0, r7
 8000458:	f007 fb7e 	bl	8007b58 <__aeabi_fmul>
 800045c:	4601      	mov	r1, r0
 800045e:	4630      	mov	r0, r6
 8000460:	f007 fa72 	bl	8007948 <__addsf3>
 8000464:	f008 f826 	bl	80084b4 <sqrtf>
	else
	{
		VectorScale(&IMU->kp_vector[0], &IMU->error_rollpitch[0], IMU->kp);
	}
	*/
	VectorScale(&IMU->kp_vector_ACC[0], &IMU->error_rollpitch[0], (IMU->kp+(IMU->kp*error_absolute)));
 8000468:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
	/*Calc the error between the gyrobased calculations and the vector of the accelerometer, 
	this will be done with the crossproduct of the two vectors*/
	VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &IMU->accel_vector[0]);
	//VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &test[0]);
	
	error_absolute = sqrtf((IMU->error_rollpitch[0]*IMU->error_rollpitch[0]) + (IMU->error_rollpitch[1]*IMU->error_rollpitch[1]) + (IMU->error_rollpitch[2]*IMU->error_rollpitch[2]));
 800046a:	4601      	mov	r1, r0
	else
	{
		VectorScale(&IMU->kp_vector[0], &IMU->error_rollpitch[0], IMU->kp);
	}
	*/
	VectorScale(&IMU->kp_vector_ACC[0], &IMU->error_rollpitch[0], (IMU->kp+(IMU->kp*error_absolute)));
 800046c:	4630      	mov	r0, r6
 800046e:	f007 fb73 	bl	8007b58 <__aeabi_fmul>
 8000472:	4601      	mov	r1, r0
 8000474:	4630      	mov	r0, r6
 8000476:	f007 fa67 	bl	8007948 <__addsf3>
 800047a:	3460      	adds	r4, #96	; 0x60
 800047c:	4602      	mov	r2, r0
 800047e:	4629      	mov	r1, r5
 8000480:	4620      	mov	r0, r4
	//printf("%f\n", (IMU->kp+(IMU->kp*error_absolute)));
}
 8000482:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	else
	{
		VectorScale(&IMU->kp_vector[0], &IMU->error_rollpitch[0], IMU->kp);
	}
	*/
	VectorScale(&IMU->kp_vector_ACC[0], &IMU->error_rollpitch[0], (IMU->kp+(IMU->kp*error_absolute)));
 8000486:	f000 bd3a 	b.w	8000efe <VectorScale>

0800048a <IMU_drift_correction_MAG>:
}


/*yaw Drift-Correction with Magnetometer*/
void IMU_drift_correction_MAG(struct IMU_values *IMU)
{
 800048a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800048c:	4604      	mov	r4, r0
	float normfactor;
	//float error_absolute;

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));
 800048e:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8000490:	6c67      	ldr	r7, [r4, #68]	; 0x44
 8000492:	4601      	mov	r1, r0
 8000494:	f007 fb60 	bl	8007b58 <__aeabi_fmul>
 8000498:	4639      	mov	r1, r7
 800049a:	4605      	mov	r5, r0
 800049c:	4638      	mov	r0, r7
 800049e:	f007 fb5b 	bl	8007b58 <__aeabi_fmul>
 80004a2:	4601      	mov	r1, r0
 80004a4:	4628      	mov	r0, r5
 80004a6:	f007 fa4f 	bl	8007948 <__addsf3>
 80004aa:	6ca6      	ldr	r6, [r4, #72]	; 0x48
 80004ac:	4605      	mov	r5, r0
 80004ae:	4631      	mov	r1, r6
 80004b0:	4630      	mov	r0, r6
 80004b2:	f007 fb51 	bl	8007b58 <__aeabi_fmul>
 80004b6:	4601      	mov	r1, r0
 80004b8:	4628      	mov	r0, r5
 80004ba:	f007 fa45 	bl	8007948 <__addsf3>
 80004be:	f007 fff9 	bl	80084b4 <sqrtf>

	if(normfactor != 0)
 80004c2:	2100      	movs	r1, #0
void IMU_drift_correction_MAG(struct IMU_values *IMU)
{
	float normfactor;
	//float error_absolute;

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));
 80004c4:	4605      	mov	r5, r0

	if(normfactor != 0)
 80004c6:	f007 fcdb 	bl	8007e80 <__aeabi_fcmpeq>
 80004ca:	b970      	cbnz	r0, 80004ea <IMU_drift_correction_MAG+0x60>
	{
		IMU->mag_vector[0] = IMU->mag_vector[0]/normfactor;
 80004cc:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80004ce:	4629      	mov	r1, r5
 80004d0:	f007 fbf6 	bl	8007cc0 <__aeabi_fdiv>
		IMU->mag_vector[1] = IMU->mag_vector[1]/normfactor;
 80004d4:	4629      	mov	r1, r5

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));

	if(normfactor != 0)
	{
		IMU->mag_vector[0] = IMU->mag_vector[0]/normfactor;
 80004d6:	6420      	str	r0, [r4, #64]	; 0x40
		IMU->mag_vector[1] = IMU->mag_vector[1]/normfactor;
 80004d8:	6c60      	ldr	r0, [r4, #68]	; 0x44
 80004da:	f007 fbf1 	bl	8007cc0 <__aeabi_fdiv>
		IMU->mag_vector[2] = IMU->mag_vector[2]/normfactor;
 80004de:	4629      	mov	r1, r5
	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));

	if(normfactor != 0)
	{
		IMU->mag_vector[0] = IMU->mag_vector[0]/normfactor;
		IMU->mag_vector[1] = IMU->mag_vector[1]/normfactor;
 80004e0:	6460      	str	r0, [r4, #68]	; 0x44
		IMU->mag_vector[2] = IMU->mag_vector[2]/normfactor;
 80004e2:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80004e4:	f007 fbec 	bl	8007cc0 <__aeabi_fdiv>
 80004e8:	64a0      	str	r0, [r4, #72]	; 0x48

	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
 80004ea:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80004ec:	6860      	ldr	r0, [r4, #4]
 80004ee:	f007 fb33 	bl	8007b58 <__aeabi_fmul>
 80004f2:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80004f4:	4605      	mov	r5, r0
 80004f6:	6920      	ldr	r0, [r4, #16]
 80004f8:	f007 fb2e 	bl	8007b58 <__aeabi_fmul>
 80004fc:	4601      	mov	r1, r0
 80004fe:	4628      	mov	r0, r5
 8000500:	f007 fa20 	bl	8007944 <__aeabi_fsub>
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 8000504:	6ce1      	ldr	r1, [r4, #76]	; 0x4c

	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
 8000506:	65e0      	str	r0, [r4, #92]	; 0x5c
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 8000508:	f007 fb26 	bl	8007b58 <__aeabi_fmul>
 800050c:	f104 066c 	add.w	r6, r4, #108	; 0x6c
 8000510:	f104 051c 	add.w	r5, r4, #28
 8000514:	4602      	mov	r2, r0
 8000516:	4629      	mov	r1, r5
 8000518:	4630      	mov	r0, r6
	//VectorScale(&IMU->kp_vector_MAG[0], &IMU->error_yaw[0], IMU->kp);
	//printf("%f\n", (IMU->kp+(IMU->kp*error_absolute)));
}
 800051a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 800051e:	f000 bcee 	b.w	8000efe <VectorScale>

08000522 <IMU_DCM_to_Euler_deg>:
}


/*DCM to EULER Angles*/
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000522:	b538      	push	{r3, r4, r5, lr}
 8000524:	4604      	mov	r4, r0
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 8000526:	69c0      	ldr	r0, [r0, #28]
}


/*DCM to EULER Angles*/
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000528:	460d      	mov	r5, r1
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 800052a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800052e:	f007 ff6d 	bl	800840c <asinf>
 8000532:	490a      	ldr	r1, [pc, #40]	; (800055c <IMU_DCM_to_Euler_deg+0x3a>)
 8000534:	f007 fb10 	bl	8007b58 <__aeabi_fmul>
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 8000538:	6a61      	ldr	r1, [r4, #36]	; 0x24


/*DCM to EULER Angles*/
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 800053a:	6068      	str	r0, [r5, #4]
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 800053c:	6a20      	ldr	r0, [r4, #32]
 800053e:	f007 ffb7 	bl	80084b0 <atan2f>
 8000542:	4906      	ldr	r1, [pc, #24]	; (800055c <IMU_DCM_to_Euler_deg+0x3a>)
 8000544:	f007 fb08 	bl	8007b58 <__aeabi_fmul>
	euler->yaw = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 8000548:	6861      	ldr	r1, [r4, #4]

/*DCM to EULER Angles*/
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 800054a:	6028      	str	r0, [r5, #0]
	euler->yaw = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 800054c:	6920      	ldr	r0, [r4, #16]
 800054e:	f007 ffaf 	bl	80084b0 <atan2f>
 8000552:	4902      	ldr	r1, [pc, #8]	; (800055c <IMU_DCM_to_Euler_deg+0x3a>)
 8000554:	f007 fb00 	bl	8007b58 <__aeabi_fmul>
 8000558:	60a8      	str	r0, [r5, #8]
 800055a:	bd38      	pop	{r3, r4, r5, pc}
 800055c:	42652ee0 	.word	0x42652ee0

08000560 <IMU_Euler_to_DCM>:
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}

/*EULER Angles to DCM*/
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000560:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
 8000564:	f8d1 b004 	ldr.w	fp, [r1, #4]
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}

/*EULER Angles to DCM*/
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000568:	b085      	sub	sp, #20
 800056a:	4604      	mov	r4, r0
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
 800056c:	4658      	mov	r0, fp
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}

/*EULER Angles to DCM*/
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
 800056e:	460f      	mov	r7, r1
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
 8000570:	f007 fe82 	bl	8008278 <cosf>
 8000574:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8000578:	4606      	mov	r6, r0
 800057a:	4640      	mov	r0, r8
 800057c:	f007 fe7c 	bl	8008278 <cosf>
 8000580:	4605      	mov	r5, r0
 8000582:	4629      	mov	r1, r5
 8000584:	4630      	mov	r0, r6
 8000586:	f007 fae7 	bl	8007b58 <__aeabi_fmul>
 800058a:	6060      	str	r0, [r4, #4]
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 800058c:	4640      	mov	r0, r8
 800058e:	f007 fea9 	bl	80082e4 <sinf>
 8000592:	4680      	mov	r8, r0
 8000594:	4641      	mov	r1, r8
 8000596:	4630      	mov	r0, r6
 8000598:	f007 fade 	bl	8007b58 <__aeabi_fmul>
 800059c:	f8d7 9000 	ldr.w	r9, [r7]
 80005a0:	4682      	mov	sl, r0
 80005a2:	4648      	mov	r0, r9
 80005a4:	f007 fe9e 	bl	80082e4 <sinf>
 80005a8:	4607      	mov	r7, r0
 80005aa:	4658      	mov	r0, fp
 80005ac:	f007 fe9a 	bl	80082e4 <sinf>
 80005b0:	4683      	mov	fp, r0
 80005b2:	4659      	mov	r1, fp
 80005b4:	4638      	mov	r0, r7
 80005b6:	f007 facf 	bl	8007b58 <__aeabi_fmul>
 80005ba:	4629      	mov	r1, r5
 80005bc:	9001      	str	r0, [sp, #4]
 80005be:	f007 facb 	bl	8007b58 <__aeabi_fmul>
 80005c2:	4601      	mov	r1, r0
 80005c4:	4650      	mov	r0, sl
 80005c6:	f007 f9bf 	bl	8007948 <__addsf3>
 80005ca:	60a0      	str	r0, [r4, #8]
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 80005cc:	4648      	mov	r0, r9
 80005ce:	f007 fe53 	bl	8008278 <cosf>
 80005d2:	4659      	mov	r1, fp
 80005d4:	4681      	mov	r9, r0
 80005d6:	f007 fabf 	bl	8007b58 <__aeabi_fmul>
 80005da:	4641      	mov	r1, r8
 80005dc:	9003      	str	r0, [sp, #12]
 80005de:	4638      	mov	r0, r7
 80005e0:	f007 faba 	bl	8007b58 <__aeabi_fmul>
 80005e4:	4629      	mov	r1, r5
 80005e6:	4684      	mov	ip, r0
 80005e8:	9803      	ldr	r0, [sp, #12]
 80005ea:	f8cd c008 	str.w	ip, [sp, #8]
 80005ee:	f007 fab3 	bl	8007b58 <__aeabi_fmul>
 80005f2:	f8dd c008 	ldr.w	ip, [sp, #8]
 80005f6:	4601      	mov	r1, r0
 80005f8:	4660      	mov	r0, ip
 80005fa:	f007 f9a3 	bl	8007944 <__aeabi_fsub>

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
 80005fe:	f10a 4a00 	add.w	sl, sl, #2147483648	; 0x80000000
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000602:	4629      	mov	r1, r5
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 8000604:	60e0      	str	r0, [r4, #12]

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
 8000606:	f8c4 a010 	str.w	sl, [r4, #16]
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 800060a:	4648      	mov	r0, r9
 800060c:	f007 faa4 	bl	8007b58 <__aeabi_fmul>
 8000610:	9a01      	ldr	r2, [sp, #4]
 8000612:	4682      	mov	sl, r0
 8000614:	4641      	mov	r1, r8
 8000616:	4610      	mov	r0, r2
 8000618:	f007 fa9e 	bl	8007b58 <__aeabi_fmul>
 800061c:	4601      	mov	r1, r0
 800061e:	4650      	mov	r0, sl
 8000620:	f007 f990 	bl	8007944 <__aeabi_fsub>
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000624:	4629      	mov	r1, r5
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000626:	6160      	str	r0, [r4, #20]
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000628:	4638      	mov	r0, r7
 800062a:	f007 fa95 	bl	8007b58 <__aeabi_fmul>
 800062e:	4641      	mov	r1, r8
 8000630:	4605      	mov	r5, r0
 8000632:	9803      	ldr	r0, [sp, #12]
 8000634:	f007 fa90 	bl	8007b58 <__aeabi_fmul>
 8000638:	4601      	mov	r1, r0
 800063a:	4628      	mov	r0, r5
 800063c:	f007 f984 	bl	8007948 <__addsf3>

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
 8000640:	4631      	mov	r1, r6
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000642:	61a0      	str	r0, [r4, #24]

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
 8000644:	f8c4 b01c 	str.w	fp, [r4, #28]
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
 8000648:	f107 4000 	add.w	r0, r7, #2147483648	; 0x80000000
 800064c:	f007 fa84 	bl	8007b58 <__aeabi_fmul>
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
 8000650:	4631      	mov	r1, r6
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
 8000652:	6220      	str	r0, [r4, #32]
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
 8000654:	4648      	mov	r0, r9
 8000656:	f007 fa7f 	bl	8007b58 <__aeabi_fmul>
 800065a:	6260      	str	r0, [r4, #36]	; 0x24
}
 800065c:	b005      	add	sp, #20
 800065e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000662 <IMU_DCM_to_XYZ>:

void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
 8000662:	b538      	push	{r3, r4, r5, lr}
 8000664:	4604      	mov	r4, r0
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
 8000666:	69c0      	ldr	r0, [r0, #28]
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
}

void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
 8000668:	460d      	mov	r5, r1
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
 800066a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800066e:	f007 fecd 	bl	800840c <asinf>
 8000672:	490a      	ldr	r1, [pc, #40]	; (800069c <IMU_DCM_to_XYZ+0x3a>)
 8000674:	f007 fa70 	bl	8007b58 <__aeabi_fmul>
 8000678:	6028      	str	r0, [r5, #0]
	XYZ->y = asinf(IMU->dcm_ze_line[1])*(180/M_PI);
 800067a:	6a20      	ldr	r0, [r4, #32]
 800067c:	f007 fec6 	bl	800840c <asinf>
 8000680:	4906      	ldr	r1, [pc, #24]	; (800069c <IMU_DCM_to_XYZ+0x3a>)
 8000682:	f007 fa69 	bl	8007b58 <__aeabi_fmul>
	XYZ->z = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 8000686:	6861      	ldr	r1, [r4, #4]
}

void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
	XYZ->y = asinf(IMU->dcm_ze_line[1])*(180/M_PI);
 8000688:	6068      	str	r0, [r5, #4]
	XYZ->z = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 800068a:	6920      	ldr	r0, [r4, #16]
 800068c:	f007 ff10 	bl	80084b0 <atan2f>
 8000690:	4902      	ldr	r1, [pc, #8]	; (800069c <IMU_DCM_to_XYZ+0x3a>)
 8000692:	f007 fa61 	bl	8007b58 <__aeabi_fmul>
 8000696:	60a8      	str	r0, [r5, #8]
 8000698:	bd38      	pop	{r3, r4, r5, pc}
 800069a:	bf00      	nop
 800069c:	42652ee0 	.word	0x42652ee0

080006a0 <L3GD20_SendByte>:
 */

#include <L3GD20_Lib_SPI.h>

static uint8_t L3GD20_SendByte(uint8_t byte)
{
 80006a0:	b510      	push	{r4, lr}
 80006a2:	4604      	mov	r4, r0
  /* Loop while DR register in not empty */
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_TXE) == RESET)
 80006a4:	480a      	ldr	r0, [pc, #40]	; (80006d0 <L3GD20_SendByte+0x30>)
 80006a6:	2102      	movs	r1, #2
 80006a8:	f004 f8e9 	bl	800487e <SPI_I2S_GetFlagStatus>
 80006ac:	2800      	cmp	r0, #0
 80006ae:	d0f9      	beq.n	80006a4 <L3GD20_SendByte+0x4>
  {
  }

  /* Send a Byte through the SPI peripheral */
  SPI_SendData8(L3GD20_SPI, byte);
 80006b0:	4807      	ldr	r0, [pc, #28]	; (80006d0 <L3GD20_SendByte+0x30>)
 80006b2:	4621      	mov	r1, r4
 80006b4:	f004 f888 	bl	80047c8 <SPI_SendData8>

  /* Wait to receive a Byte */
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_RXNE) == RESET)
 80006b8:	4805      	ldr	r0, [pc, #20]	; (80006d0 <L3GD20_SendByte+0x30>)
 80006ba:	2101      	movs	r1, #1
 80006bc:	f004 f8df 	bl	800487e <SPI_I2S_GetFlagStatus>
 80006c0:	2800      	cmp	r0, #0
 80006c2:	d0f9      	beq.n	80006b8 <L3GD20_SendByte+0x18>
  {
  }

  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_ReceiveData8(L3GD20_SPI);
 80006c4:	4802      	ldr	r0, [pc, #8]	; (80006d0 <L3GD20_SendByte+0x30>)
}
 80006c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_RXNE) == RESET)
  {
  }

  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_ReceiveData8(L3GD20_SPI);
 80006ca:	f004 b881 	b.w	80047d0 <SPI_ReceiveData8>
 80006ce:	bf00      	nop
 80006d0:	40013000 	.word	0x40013000

080006d4 <L3GD20_Init>:
}



void L3GD20_Init(void)
{
 80006d4:	b510      	push	{r4, lr}

  ctrl5 = (uint8_t) (0x13); /* CTRL_REG5   low pass filter enable, high pass filter enabled */


  /* Write value to MEMS CTRL_REG1 regsister */
  L3GD20_CS_LOW();
 80006d6:	4c1d      	ldr	r4, [pc, #116]	; (800074c <L3GD20_Init+0x78>)
 80006d8:	2108      	movs	r1, #8
 80006da:	4620      	mov	r0, r4
 80006dc:	f003 f9e8 	bl	8003ab0 <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG1_ADDR);
 80006e0:	2020      	movs	r0, #32
 80006e2:	f7ff ffdd 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl1);
 80006e6:	20ff      	movs	r0, #255	; 0xff
 80006e8:	f7ff ffda 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 80006ec:	4620      	mov	r0, r4
 80006ee:	2108      	movs	r1, #8
 80006f0:	f003 f9dc 	bl	8003aac <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
 80006f4:	2108      	movs	r1, #8
 80006f6:	4620      	mov	r0, r4
 80006f8:	f003 f9da 	bl	8003ab0 <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG2_ADDR);
 80006fc:	2021      	movs	r0, #33	; 0x21
 80006fe:	f7ff ffcf 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl2);
 8000702:	2034      	movs	r0, #52	; 0x34
 8000704:	f7ff ffcc 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 8000708:	4620      	mov	r0, r4
 800070a:	2108      	movs	r1, #8
 800070c:	f003 f9ce 	bl	8003aac <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG4 regsister */
  L3GD20_CS_LOW();
 8000710:	2108      	movs	r1, #8
 8000712:	4620      	mov	r0, r4
 8000714:	f003 f9cc 	bl	8003ab0 <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG4_ADDR);
 8000718:	2023      	movs	r0, #35	; 0x23
 800071a:	f7ff ffc1 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl4);
 800071e:	20a0      	movs	r0, #160	; 0xa0
 8000720:	f7ff ffbe 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 8000724:	4620      	mov	r0, r4
 8000726:	2108      	movs	r1, #8
 8000728:	f003 f9c0 	bl	8003aac <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
 800072c:	2108      	movs	r1, #8
 800072e:	4620      	mov	r0, r4
 8000730:	f003 f9be 	bl	8003ab0 <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG5_ADDR);
 8000734:	2024      	movs	r0, #36	; 0x24
 8000736:	f7ff ffb3 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl5);
 800073a:	2013      	movs	r0, #19
 800073c:	f7ff ffb0 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 8000740:	4620      	mov	r0, r4
 8000742:	2108      	movs	r1, #8
}
 8000744:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
  L3GD20_SendByte(L3GD20_CTRL_REG5_ADDR);
  L3GD20_SendByte(ctrl5);
  L3GD20_CS_HIGH();
 8000748:	f003 b9b0 	b.w	8003aac <GPIO_SetBits>
 800074c:	48001000 	.word	0x48001000

08000750 <L3GD20_Read>:
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
  if(NumByteToRead > 0x01)
 8000750:	2a01      	cmp	r2, #1
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 8000752:	b570      	push	{r4, r5, r6, lr}
  if(NumByteToRead > 0x01)
  {
    ReadAddr |= (uint8_t)(READWRITE_CMD | MULTIPLEBYTE_CMD);
 8000754:	bf8c      	ite	hi
 8000756:	f041 06c0 	orrhi.w	r6, r1, #192	; 0xc0
  }
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
 800075a:	f041 0680 	orrls.w	r6, r1, #128	; 0x80
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 800075e:	4605      	mov	r5, r0
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 8000760:	2108      	movs	r1, #8
 8000762:	480b      	ldr	r0, [pc, #44]	; (8000790 <L3GD20_Read+0x40>)
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 8000764:	4614      	mov	r4, r2
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 8000766:	f003 f9a3 	bl	8003ab0 <GPIO_ResetBits>

  /* Send the Address of the indexed register */
  L3GD20_SendByte(ReadAddr);
 800076a:	4630      	mov	r0, r6
 800076c:	f7ff ff98 	bl	80006a0 <L3GD20_SendByte>

  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 8000770:	e006      	b.n	8000780 <L3GD20_Read+0x30>
  {
    /* Send dummy byte (0x00) to generate the SPI clock to L3GD20 (Slave device) */
    *pBuffer = L3GD20_SendByte(DUMMY_BYTE);
 8000772:	2000      	movs	r0, #0
 8000774:	f7ff ff94 	bl	80006a0 <L3GD20_SendByte>
    NumByteToRead--;
 8000778:	3c01      	subs	r4, #1

  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
  {
    /* Send dummy byte (0x00) to generate the SPI clock to L3GD20 (Slave device) */
    *pBuffer = L3GD20_SendByte(DUMMY_BYTE);
 800077a:	f805 0b01 	strb.w	r0, [r5], #1
    NumByteToRead--;
 800077e:	b2a4      	uxth	r4, r4

  /* Send the Address of the indexed register */
  L3GD20_SendByte(ReadAddr);

  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 8000780:	2c00      	cmp	r4, #0
 8000782:	d1f6      	bne.n	8000772 <L3GD20_Read+0x22>
    NumByteToRead--;
    pBuffer++;
  }

  /* Set chip select High at the end of the transmission */
  L3GD20_CS_HIGH();
 8000784:	4802      	ldr	r0, [pc, #8]	; (8000790 <L3GD20_Read+0x40>)
 8000786:	2108      	movs	r1, #8
}
 8000788:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    NumByteToRead--;
    pBuffer++;
  }

  /* Set chip select High at the end of the transmission */
  L3GD20_CS_HIGH();
 800078c:	f003 b98e 	b.w	8003aac <GPIO_SetBits>
 8000790:	48001000 	.word	0x48001000

08000794 <Gyro_convert>:
}


void Gyro_convert(uint8_t Buffer[6], struct gyroValues *gyro, uint8_t bigEndian)
{
 8000794:	b510      	push	{r4, lr}
 8000796:	7843      	ldrb	r3, [r0, #1]
 8000798:	7804      	ldrb	r4, [r0, #0]
	if(bigEndian)
 800079a:	b152      	cbz	r2, 80007b2 <Gyro_convert+0x1e>
	{
		gyro->gyroValueX = (Buffer[1] << 8) | (Buffer[0]);
 800079c:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80007a0:	800b      	strh	r3, [r1, #0]
		gyro->gyroValueY = (Buffer[3] << 8) | (Buffer[2]);
 80007a2:	78c2      	ldrb	r2, [r0, #3]
 80007a4:	7883      	ldrb	r3, [r0, #2]
 80007a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80007aa:	804b      	strh	r3, [r1, #2]
		gyro->gyroValueZ = (Buffer[5] << 8) | (Buffer[4]);
 80007ac:	7942      	ldrb	r2, [r0, #5]
 80007ae:	7903      	ldrb	r3, [r0, #4]
 80007b0:	e009      	b.n	80007c6 <Gyro_convert+0x32>
	}
	else
	{
		gyro->gyroValueX = (Buffer[0] << 8) | (Buffer[1]);
 80007b2:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 80007b6:	800b      	strh	r3, [r1, #0]
		gyro->gyroValueY = (Buffer[2] << 8) | (Buffer[3]);
 80007b8:	7882      	ldrb	r2, [r0, #2]
 80007ba:	78c3      	ldrb	r3, [r0, #3]
 80007bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80007c0:	804b      	strh	r3, [r1, #2]
		gyro->gyroValueZ = (Buffer[4] << 8) | (Buffer[5]);
 80007c2:	7902      	ldrb	r2, [r0, #4]
 80007c4:	7943      	ldrb	r3, [r0, #5]
 80007c6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80007ca:	808b      	strh	r3, [r1, #4]
 80007cc:	bd10      	pop	{r4, pc}

080007ce <Gyro_readValues>:
	}
}


void Gyro_readValues (struct gyroValues *gyro)
{
 80007ce:	b530      	push	{r4, r5, lr}
 80007d0:	b085      	sub	sp, #20
  uint8_t tmpbuffer[6] ={0};
 80007d2:	2400      	movs	r4, #0
	}
}


void Gyro_readValues (struct gyroValues *gyro)
{
 80007d4:	4605      	mov	r5, r0
  uint8_t tmpbuffer[6] ={0};
  uint8_t tmpreg = 0;
 80007d6:	a804      	add	r0, sp, #16
 80007d8:	f800 4d09 	strb.w	r4, [r0, #-9]!

  L3GD20_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
 80007dc:	2123      	movs	r1, #35	; 0x23
 80007de:	2201      	movs	r2, #1
}


void Gyro_readValues (struct gyroValues *gyro)
{
  uint8_t tmpbuffer[6] ={0};
 80007e0:	9402      	str	r4, [sp, #8]
 80007e2:	f8ad 400c 	strh.w	r4, [sp, #12]
  uint8_t tmpreg = 0;

  L3GD20_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
 80007e6:	f7ff ffb3 	bl	8000750 <L3GD20_Read>
  L3GD20_Read(tmpbuffer,L3GD20_OUT_X_L_ADDR,6);
 80007ea:	a802      	add	r0, sp, #8
 80007ec:	2128      	movs	r1, #40	; 0x28
 80007ee:	2206      	movs	r2, #6
 80007f0:	f7ff ffae 	bl	8000750 <L3GD20_Read>

  /* check in the control register 4 the data alignment (Big Endian or Little Endian)*/
  if(!(tmpreg & 0x40))
 80007f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80007f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80007fc:	b2db      	uxtb	r3, r3
 80007fe:	b9ab      	cbnz	r3, 800082c <Gyro_readValues+0x5e>

void Gyro_convert(uint8_t Buffer[6], struct gyroValues *gyro, uint8_t bigEndian)
{
	if(bigEndian)
	{
		gyro->gyroValueX = (Buffer[1] << 8) | (Buffer[0]);
 8000800:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8000804:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8000808:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800080c:	802b      	strh	r3, [r5, #0]
		gyro->gyroValueY = (Buffer[3] << 8) | (Buffer[2]);
 800080e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8000812:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8000816:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800081a:	806b      	strh	r3, [r5, #2]
		gyro->gyroValueZ = (Buffer[5] << 8) | (Buffer[4]);
 800081c:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8000820:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8000824:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000828:	80ab      	strh	r3, [r5, #4]
 800082a:	e004      	b.n	8000836 <Gyro_readValues+0x68>
  {
	Gyro_convert(&tmpbuffer[0], gyro, 1);
  }
  else
  {
   	Gyro_convert(&tmpbuffer[0], gyro, 0);
 800082c:	a802      	add	r0, sp, #8
 800082e:	4629      	mov	r1, r5
 8000830:	4622      	mov	r2, r4
 8000832:	f7ff ffaf 	bl	8000794 <Gyro_convert>
  }
}
 8000836:	b005      	add	sp, #20
 8000838:	bd30      	pop	{r4, r5, pc}

0800083a <Gyro_calibrate>:



//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
 800083a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800083e:	4604      	mov	r4, r0
int i = 0;
int32_t tmpX = 0;
int32_t tmpY = 0;
int32_t tmpZ = 0;

L3GD20_Init();
 8000840:	f7ff ff48 	bl	80006d4 <L3GD20_Init>
 8000844:	2564      	movs	r5, #100	; 0x64

//discard the first 100 values
for(i=0;i<100;i++)
{
	Gyro_readValues(gyroOffset);
 8000846:	4620      	mov	r0, r4
 8000848:	f7ff ffc1 	bl	80007ce <Gyro_readValues>
int32_t tmpZ = 0;

L3GD20_Init();

//discard the first 100 values
for(i=0;i<100;i++)
 800084c:	3d01      	subs	r5, #1
 800084e:	d1fa      	bne.n	8000846 <Gyro_calibrate+0xc>
{
	Gyro_readValues(gyroOffset);
}

gyroOffset->gyroValueX = 0;
 8000850:	8025      	strh	r5, [r4, #0]
gyroOffset->gyroValueY = 0;
 8000852:	8065      	strh	r5, [r4, #2]
gyroOffset->gyroValueZ = 0;
 8000854:	80a5      	strh	r5, [r4, #4]
 8000856:	f44f 7896 	mov.w	r8, #300	; 0x12c
//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
int i = 0;
int32_t tmpX = 0;
int32_t tmpY = 0;
 800085a:	462e      	mov	r6, r5

//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
int i = 0;
int32_t tmpX = 0;
 800085c:	462f      	mov	r7, r5

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
{

	Gyro_readValues(gyroOffset);
 800085e:	4620      	mov	r0, r4
 8000860:	f7ff ffb5 	bl	80007ce <Gyro_readValues>
	tmpX += gyroOffset->gyroValueX;
 8000864:	f9b4 3000 	ldrsh.w	r3, [r4]
gyroOffset->gyroValueX = 0;
gyroOffset->gyroValueY = 0;
gyroOffset->gyroValueZ = 0;

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
 8000868:	f1b8 0801 	subs.w	r8, r8, #1
{

	Gyro_readValues(gyroOffset);
	tmpX += gyroOffset->gyroValueX;
 800086c:	441f      	add	r7, r3
	tmpY += gyroOffset->gyroValueY;
 800086e:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 8000872:	441e      	add	r6, r3
	tmpZ += gyroOffset->gyroValueZ;
 8000874:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
 8000878:	441d      	add	r5, r3
gyroOffset->gyroValueX = 0;
gyroOffset->gyroValueY = 0;
gyroOffset->gyroValueZ = 0;

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
 800087a:	d1f0      	bne.n	800085e <Gyro_calibrate+0x24>
	tmpX += gyroOffset->gyroValueX;
	tmpY += gyroOffset->gyroValueY;
	tmpZ += gyroOffset->gyroValueZ;
}

gyroOffset->gyroValueX = tmpX/average_loop_value;
 800087c:	f44f 7396 	mov.w	r3, #300	; 0x12c
 8000880:	fb97 f7f3 	sdiv	r7, r7, r3
gyroOffset->gyroValueY = tmpY/average_loop_value;
 8000884:	fb96 f6f3 	sdiv	r6, r6, r3
gyroOffset->gyroValueZ = tmpZ/average_loop_value;
 8000888:	fb95 f5f3 	sdiv	r5, r5, r3
	tmpX += gyroOffset->gyroValueX;
	tmpY += gyroOffset->gyroValueY;
	tmpZ += gyroOffset->gyroValueZ;
}

gyroOffset->gyroValueX = tmpX/average_loop_value;
 800088c:	8027      	strh	r7, [r4, #0]
gyroOffset->gyroValueY = tmpY/average_loop_value;
 800088e:	8066      	strh	r6, [r4, #2]
gyroOffset->gyroValueZ = tmpZ/average_loop_value;
 8000890:	80a5      	strh	r5, [r4, #4]
 8000892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000896:	bf00      	nop

08000898 <LSM303DLHC_Write>:
#include <LSM303DLHC_Lib_I2C.h>


void LSM303DLHC_Write(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer)
{
 8000898:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800089a:	4604      	mov	r4, r0
 800089c:	460e      	mov	r6, r1
 800089e:	4615      	mov	r5, r2
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 80008a0:	4820      	ldr	r0, [pc, #128]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008a2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80008a6:	f003 faae 	bl	8003e06 <I2C_GetFlagStatus>
 80008aa:	2800      	cmp	r0, #0
 80008ac:	d1f8      	bne.n	80008a0 <LSM303DLHC_Write+0x8>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_Reload_Mode, I2C_Generate_Start_Write);
 80008ae:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80008b2:	9300      	str	r3, [sp, #0]
 80008b4:	481b      	ldr	r0, [pc, #108]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008b6:	4621      	mov	r1, r4
 80008b8:	2201      	movs	r2, #1
 80008ba:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80008be:	f003 fa28 	bl	8003d12 <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 80008c2:	4818      	ldr	r0, [pc, #96]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008c4:	2102      	movs	r1, #2
 80008c6:	f003 fa9e 	bl	8003e06 <I2C_GetFlagStatus>
 80008ca:	2800      	cmp	r0, #0
 80008cc:	d0f9      	beq.n	80008c2 <LSM303DLHC_Write+0x2a>
  {
  }

  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t) RegAddr);
 80008ce:	4815      	ldr	r0, [pc, #84]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008d0:	4631      	mov	r1, r6
 80008d2:	f003 fa8b 	bl	8003dec <I2C_SendData>

  /* Wait until TCR flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TCR) == RESET)
 80008d6:	4813      	ldr	r0, [pc, #76]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008d8:	2180      	movs	r1, #128	; 0x80
 80008da:	f003 fa94 	bl	8003e06 <I2C_GetFlagStatus>
 80008de:	2800      	cmp	r0, #0
 80008e0:	d0f9      	beq.n	80008d6 <LSM303DLHC_Write+0x3e>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_AutoEnd_Mode, I2C_No_StartStop);
 80008e2:	2300      	movs	r3, #0
 80008e4:	9300      	str	r3, [sp, #0]
 80008e6:	480f      	ldr	r0, [pc, #60]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008e8:	4621      	mov	r1, r4
 80008ea:	2201      	movs	r2, #1
 80008ec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80008f0:	f003 fa0f 	bl	8003d12 <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 80008f4:	480b      	ldr	r0, [pc, #44]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008f6:	2102      	movs	r1, #2
 80008f8:	f003 fa85 	bl	8003e06 <I2C_GetFlagStatus>
 80008fc:	2800      	cmp	r0, #0
 80008fe:	d0f9      	beq.n	80008f4 <LSM303DLHC_Write+0x5c>
  {
  }

  /* Write data to TXDR */
  I2C_SendData(LSM303DLHC_I2C, *pBuffer);
 8000900:	4808      	ldr	r0, [pc, #32]	; (8000924 <LSM303DLHC_Write+0x8c>)
 8000902:	7829      	ldrb	r1, [r5, #0]
 8000904:	f003 fa72 	bl	8003dec <I2C_SendData>

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 8000908:	4806      	ldr	r0, [pc, #24]	; (8000924 <LSM303DLHC_Write+0x8c>)
 800090a:	2120      	movs	r1, #32
 800090c:	f003 fa7b 	bl	8003e06 <I2C_GetFlagStatus>
 8000910:	2800      	cmp	r0, #0
 8000912:	d0f9      	beq.n	8000908 <LSM303DLHC_Write+0x70>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 8000914:	4803      	ldr	r0, [pc, #12]	; (8000924 <LSM303DLHC_Write+0x8c>)
 8000916:	2120      	movs	r1, #32
}
 8000918:	b002      	add	sp, #8
 800091a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 800091e:	f003 ba78 	b.w	8003e12 <I2C_ClearFlag>
 8000922:	bf00      	nop
 8000924:	40005400 	.word	0x40005400

08000928 <LSM303DLHC_Read>:
}


void LSM303DLHC_Read(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer, uint16_t NumByteToRead)
{
 8000928:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800092a:	4607      	mov	r7, r0
 800092c:	460d      	mov	r5, r1
 800092e:	4616      	mov	r6, r2
 8000930:	461c      	mov	r4, r3
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 8000932:	4825      	ldr	r0, [pc, #148]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000934:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000938:	f003 fa65 	bl	8003e06 <I2C_GetFlagStatus>
 800093c:	4603      	mov	r3, r0
 800093e:	2800      	cmp	r0, #0
 8000940:	d1f7      	bne.n	8000932 <LSM303DLHC_Read+0xa>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_SoftEnd_Mode, I2C_Generate_Start_Write);
 8000942:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000946:	9200      	str	r2, [sp, #0]
 8000948:	481f      	ldr	r0, [pc, #124]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 800094a:	4639      	mov	r1, r7
 800094c:	2201      	movs	r2, #1
 800094e:	f003 f9e0 	bl	8003d12 <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 8000952:	481d      	ldr	r0, [pc, #116]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000954:	2102      	movs	r1, #2
 8000956:	f003 fa56 	bl	8003e06 <I2C_GetFlagStatus>
 800095a:	2800      	cmp	r0, #0
 800095c:	d0f9      	beq.n	8000952 <LSM303DLHC_Read+0x2a>
  {
  }

  if(NumByteToRead>1)
 800095e:	2c01      	cmp	r4, #1
      RegAddr |= 0x80;
 8000960:	bf88      	it	hi
 8000962:	f045 0580 	orrhi.w	r5, r5, #128	; 0x80


  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t)RegAddr);
 8000966:	4818      	ldr	r0, [pc, #96]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000968:	4629      	mov	r1, r5
 800096a:	f003 fa3f 	bl	8003dec <I2C_SendData>

  /* Wait until TC flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TC) == RESET)
 800096e:	4816      	ldr	r0, [pc, #88]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000970:	2140      	movs	r1, #64	; 0x40
 8000972:	f003 fa48 	bl	8003e06 <I2C_GetFlagStatus>
 8000976:	2800      	cmp	r0, #0
 8000978:	d0f9      	beq.n	800096e <LSM303DLHC_Read+0x46>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, NumByteToRead, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);
 800097a:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 800097e:	9300      	str	r3, [sp, #0]
 8000980:	4811      	ldr	r0, [pc, #68]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000982:	4639      	mov	r1, r7
 8000984:	b2e2      	uxtb	r2, r4
 8000986:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800098a:	f003 f9c2 	bl	8003d12 <I2C_TransferHandling>

  /* Wait until all data are received */
  while (NumByteToRead)
 800098e:	e00c      	b.n	80009aa <LSM303DLHC_Read+0x82>
  {
    /* Wait until RXNE flag is set */
    while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_RXNE) == RESET)
 8000990:	480d      	ldr	r0, [pc, #52]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000992:	2104      	movs	r1, #4
 8000994:	f003 fa37 	bl	8003e06 <I2C_GetFlagStatus>
 8000998:	2800      	cmp	r0, #0
 800099a:	d0f9      	beq.n	8000990 <LSM303DLHC_Read+0x68>
    {
    }

    /* Read data from RXDR */
    *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 800099c:	480a      	ldr	r0, [pc, #40]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 800099e:	f003 fa27 	bl	8003df0 <I2C_ReceiveData>
    /* Point to the next location where the byte read will be saved */
    pBuffer++;

    /* Decrement the read bytes counter */
    NumByteToRead--;
 80009a2:	3c01      	subs	r4, #1
    while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_RXNE) == RESET)
    {
    }

    /* Read data from RXDR */
    *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 80009a4:	f806 0b01 	strb.w	r0, [r6], #1
    /* Point to the next location where the byte read will be saved */
    pBuffer++;

    /* Decrement the read bytes counter */
    NumByteToRead--;
 80009a8:	b2a4      	uxth	r4, r4

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, NumByteToRead, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);

  /* Wait until all data are received */
  while (NumByteToRead)
 80009aa:	2c00      	cmp	r4, #0
 80009ac:	d1f0      	bne.n	8000990 <LSM303DLHC_Read+0x68>
    /* Decrement the read bytes counter */
    NumByteToRead--;
  }

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 80009ae:	4806      	ldr	r0, [pc, #24]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 80009b0:	2120      	movs	r1, #32
 80009b2:	f003 fa28 	bl	8003e06 <I2C_GetFlagStatus>
 80009b6:	2800      	cmp	r0, #0
 80009b8:	d0f9      	beq.n	80009ae <LSM303DLHC_Read+0x86>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 80009ba:	4803      	ldr	r0, [pc, #12]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 80009bc:	2120      	movs	r1, #32
}
 80009be:	b003      	add	sp, #12
 80009c0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 80009c4:	f003 ba25 	b.w	8003e12 <I2C_ClearFlag>
 80009c8:	40005400 	.word	0x40005400

080009cc <LSM303DLHC_ReadDMA>:
}

void LSM303DLHC_ReadDMA(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer, uint16_t NumByteToRead)
{
 80009cc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80009ce:	4606      	mov	r6, r0
 80009d0:	460c      	mov	r4, r1
 80009d2:	461d      	mov	r5, r3
//	  return;
//  }

  //DMA_Configuration(pBuffer);
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 80009d4:	482c      	ldr	r0, [pc, #176]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 80009d6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80009da:	f003 fa14 	bl	8003e06 <I2C_GetFlagStatus>
 80009de:	4603      	mov	r3, r0
 80009e0:	2800      	cmp	r0, #0
 80009e2:	d1f7      	bne.n	80009d4 <LSM303DLHC_ReadDMA+0x8>
  {
  }


  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_SoftEnd_Mode, I2C_Generate_Start_Write);
 80009e4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80009e8:	9200      	str	r2, [sp, #0]
 80009ea:	4827      	ldr	r0, [pc, #156]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 80009ec:	4631      	mov	r1, r6
 80009ee:	2201      	movs	r2, #1
 80009f0:	f003 f98f 	bl	8003d12 <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 80009f4:	4824      	ldr	r0, [pc, #144]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 80009f6:	2102      	movs	r1, #2
 80009f8:	f003 fa05 	bl	8003e06 <I2C_GetFlagStatus>
 80009fc:	2800      	cmp	r0, #0
 80009fe:	d0f9      	beq.n	80009f4 <LSM303DLHC_ReadDMA+0x28>
  {
  }

  if(NumByteToRead>1)
 8000a00:	2d01      	cmp	r5, #1
      RegAddr |= 0x80;
 8000a02:	bf88      	it	hi
 8000a04:	f044 0480 	orrhi.w	r4, r4, #128	; 0x80

  //printf("M2%d ", 0);

  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t)RegAddr);
 8000a08:	481f      	ldr	r0, [pc, #124]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a0a:	4621      	mov	r1, r4
 8000a0c:	f003 f9ee 	bl	8003dec <I2C_SendData>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TC) == RESET)
 8000a10:	481d      	ldr	r0, [pc, #116]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a12:	2140      	movs	r1, #64	; 0x40
 8000a14:	f003 f9f7 	bl	8003e06 <I2C_GetFlagStatus>
 8000a18:	2800      	cmp	r0, #0
 8000a1a:	d0f9      	beq.n	8000a10 <LSM303DLHC_ReadDMA+0x44>
//  I2C_MasterRequestConfig(LSM303DLHC_I2C, I2C_Direction_Receiver);
//  I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
//  I2C_SlaveAddressConfig(LSM303DLHC_I2C, DeviceAddr);
  //I2C_MasterRequestConfig(LSM303DLHC_I2C, I2C_Direction_Receiver);
  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, NumByteToRead, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);
 8000a1c:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8000a20:	9300      	str	r3, [sp, #0]
 8000a22:	4819      	ldr	r0, [pc, #100]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a24:	4631      	mov	r1, r6
 8000a26:	b2ea      	uxtb	r2, r5
 8000a28:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8000a2c:	f003 f971 	bl	8003d12 <I2C_TransferHandling>

  /* Enable DMA1 Channel5 */
  I2C_DMACmd(LSM303DLHC_I2C, I2C_DMAReq_Rx, ENABLE);
 8000a30:	4815      	ldr	r0, [pc, #84]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a32:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000a36:	2201      	movs	r2, #1
 8000a38:	f003 f9dd 	bl	8003df6 <I2C_DMACmd>
DMA_Cmd(DMA1_Channel7, ENABLE);
 8000a3c:	4813      	ldr	r0, [pc, #76]	; (8000a8c <LSM303DLHC_ReadDMA+0xc0>)
 8000a3e:	2101      	movs	r1, #1
 8000a40:	f002 fe30 	bl	80036a4 <DMA_Cmd>
//  }

//printf("M4%d ", 0);

  /* DMA1 Channel1 transfer complete test */
  while(!DMA_GetFlagStatus(DMA1_FLAG_TC7));
 8000a44:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8000a48:	f002 fe44 	bl	80036d4 <DMA_GetFlagStatus>
 8000a4c:	2800      	cmp	r0, #0
 8000a4e:	d0f9      	beq.n	8000a44 <LSM303DLHC_ReadDMA+0x78>

  //printf("M5%d ", 0);

  DMA_ClearFlag(DMA1_FLAG_GL7);
 8000a50:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 8000a54:	f002 fe4c 	bl	80036f0 <DMA_ClearFlag>

  I2C_DMACmd(LSM303DLHC_I2C, I2C_DMAReq_Rx, DISABLE);
 8000a58:	480b      	ldr	r0, [pc, #44]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a5a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000a5e:	2200      	movs	r2, #0
 8000a60:	f003 f9c9 	bl	8003df6 <I2C_DMACmd>
  DMA_Cmd(DMA1_Channel7, DISABLE);
 8000a64:	4809      	ldr	r0, [pc, #36]	; (8000a8c <LSM303DLHC_ReadDMA+0xc0>)
 8000a66:	2100      	movs	r1, #0
 8000a68:	f002 fe1c 	bl	80036a4 <DMA_Cmd>
  //GPIO_SetBits(GPIOE,GPIO_Pin_9);

  //I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 8000a6c:	4806      	ldr	r0, [pc, #24]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a6e:	2120      	movs	r1, #32
 8000a70:	f003 f9c9 	bl	8003e06 <I2C_GetFlagStatus>
 8000a74:	2800      	cmp	r0, #0
 8000a76:	d0f9      	beq.n	8000a6c <LSM303DLHC_ReadDMA+0xa0>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 8000a78:	4803      	ldr	r0, [pc, #12]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a7a:	2120      	movs	r1, #32
}
 8000a7c:	b002      	add	sp, #8
 8000a7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 8000a82:	f003 b9c6 	b.w	8003e12 <I2C_ClearFlag>
 8000a86:	bf00      	nop
 8000a88:	40005400 	.word	0x40005400
 8000a8c:	40020080 	.word	0x40020080

08000a90 <LSM303DLHC_AccInit>:
}


#ifdef LSM303_ACC
void LSM303DLHC_AccInit(void)
{
 8000a90:	b507      	push	{r0, r1, r2, lr}
  uint8_t ctrl1 = 0x00, ctrl2 = 0x00, ctrl4 = 0x00;
 8000a92:	2300      	movs	r3, #0
 8000a94:	f88d 3006 	strb.w	r3, [sp, #6]

  /* Configure MEMS: data rate, power mode, full scale and axes */
//  ctrl1 |= (uint8_t) (LSM303DLHC_NORMAL_MODE | LSM303DLHC_ODR_200_HZ |
//		  	  	  	  LSM303DLHC_AXES_ENABLE);

    ctrl1 |= (uint8_t) (LSM303DLHC_NORMAL_MODE | LSM303DLHC_ODR_1344_HZ |
 8000a98:	2397      	movs	r3, #151	; 0x97
 8000a9a:	f88d 3005 	strb.w	r3, [sp, #5]
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000a9e:	2032      	movs	r0, #50	; 0x32


//  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
//		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
 8000aa0:	2338      	movs	r3, #56	; 0x38
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000aa2:	2120      	movs	r1, #32
 8000aa4:	f10d 0205 	add.w	r2, sp, #5


//  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
//		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
 8000aa8:	f88d 3007 	strb.w	r3, [sp, #7]
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000aac:	f7ff fef4 	bl	8000898 <LSM303DLHC_Write>

  /* Write value to ACC MEMS CTRL_REG2 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG2_A, &ctrl2);
 8000ab0:	2032      	movs	r0, #50	; 0x32
 8000ab2:	2121      	movs	r1, #33	; 0x21
 8000ab4:	f10d 0206 	add.w	r2, sp, #6
 8000ab8:	f7ff feee 	bl	8000898 <LSM303DLHC_Write>

  /* Write value to ACC MEMS CTRL_REG4 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, &ctrl4);
 8000abc:	2032      	movs	r0, #50	; 0x32
 8000abe:	2123      	movs	r1, #35	; 0x23
 8000ac0:	f10d 0207 	add.w	r2, sp, #7
 8000ac4:	f7ff fee8 	bl	8000898 <LSM303DLHC_Write>
}
 8000ac8:	bd0e      	pop	{r1, r2, r3, pc}

08000aca <LSM303DLHC_ACC_readValues>:
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
}


void LSM303DLHC_ACC_readValues(struct accValues *accXYZ)
{
 8000aca:	b513      	push	{r0, r1, r4, lr}
	uint8_t buffer[6], cDivider;

	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000acc:	2306      	movs	r3, #6
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
}


void LSM303DLHC_ACC_readValues(struct accValues *accXYZ)
{
 8000ace:	4604      	mov	r4, r0
	uint8_t buffer[6], cDivider;

	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000ad0:	2128      	movs	r1, #40	; 0x28
 8000ad2:	466a      	mov	r2, sp
 8000ad4:	2032      	movs	r0, #50	; 0x32
 8000ad6:	f7ff ff27 	bl	8000928 <LSM303DLHC_Read>

	cDivider=16;

	/* check in the control register4 the data alignment*/
	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000ada:	f89d 3000 	ldrb.w	r3, [sp]
 8000ade:	f99d 2001 	ldrsb.w	r2, [sp, #1]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000ae2:	f99d 1003 	ldrsb.w	r1, [sp, #3]
	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);

	cDivider=16;

	/* check in the control register4 the data alignment*/
	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000ae6:	eb03 2202 	add.w	r2, r3, r2, lsl #8
 8000aea:	2310      	movs	r3, #16
 8000aec:	fb92 f2f3 	sdiv	r2, r2, r3
 8000af0:	8022      	strh	r2, [r4, #0]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000af2:	f89d 2002 	ldrb.w	r2, [sp, #2]
 8000af6:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000afa:	fb92 f2f3 	sdiv	r2, r2, r3
 8000afe:	8062      	strh	r2, [r4, #2]
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
 8000b00:	f99d 1005 	ldrsb.w	r1, [sp, #5]
 8000b04:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8000b08:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000b0c:	fb92 f3f3 	sdiv	r3, r2, r3
 8000b10:	80a3      	strh	r3, [r4, #4]
}
 8000b12:	bd1c      	pop	{r2, r3, r4, pc}

08000b14 <LSM303DLHC_ACC_calibrate>:
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, &ctrl4);
}


void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
 8000b14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000b18:	4681      	mov	r9, r0
 8000b1a:	460c      	mov	r4, r1
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;

	LSM303DLHC_AccInit();
 8000b1c:	f7ff ffb8 	bl	8000a90 <LSM303DLHC_AccInit>
void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;
 8000b20:	2500      	movs	r5, #0

	LSM303DLHC_AccInit();
 8000b22:	f04f 080a 	mov.w	r8, #10

void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
 8000b26:	462e      	mov	r6, r5


void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
 8000b28:	462f      	mov	r7, r5

	LSM303DLHC_AccInit();

	for(i=0;i<AVG_ROUNDS;i++)
	{
		LSM303DLHC_ACC_readValues(Acc_values);
 8000b2a:	4620      	mov	r0, r4
 8000b2c:	f7ff ffcd 	bl	8000aca <LSM303DLHC_ACC_readValues>

		tmpX += (Acc_values->accValueX);
 8000b30:	f9b4 3000 	ldrsh.w	r3, [r4]
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
 8000b34:	f643 2098 	movw	r0, #15000	; 0x3a98

	for(i=0;i<AVG_ROUNDS;i++)
	{
		LSM303DLHC_ACC_readValues(Acc_values);

		tmpX += (Acc_values->accValueX);
 8000b38:	18ff      	adds	r7, r7, r3
		tmpY += (Acc_values->accValueY);
 8000b3a:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 8000b3e:	f108 38ff 	add.w	r8, r8, #4294967295
 8000b42:	18f6      	adds	r6, r6, r3
		tmpZ += (Acc_values->accValueZ);
 8000b44:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
 8000b48:	18ed      	adds	r5, r5, r3

		Delay(INIT_DELAY_TIME/10);
 8000b4a:	f000 fc05 	bl	8001358 <Delay>
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;

	LSM303DLHC_AccInit();

	for(i=0;i<AVG_ROUNDS;i++)
 8000b4e:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 8000b52:	d1ea      	bne.n	8000b2a <LSM303DLHC_ACC_calibrate+0x16>
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
 8000b54:	230a      	movs	r3, #10
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
 8000b56:	fbb6 f6f3 	udiv	r6, r6, r3
 8000b5a:	8066      	strh	r6, [r4, #2]
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
									(Acc_values->accValueY*Acc_values->accValueY) +
 8000b5c:	b236      	sxth	r6, r6
 8000b5e:	4376      	muls	r6, r6
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
 8000b60:	fbb7 f7f3 	udiv	r7, r7, r3
 8000b64:	8027      	strh	r7, [r4, #0]
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
 8000b66:	b23f      	sxth	r7, r7
 8000b68:	fb07 6007 	mla	r0, r7, r7, r6

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);
 8000b6c:	fbb5 f5f3 	udiv	r5, r5, r3
 8000b70:	80a5      	strh	r5, [r4, #4]

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
									(Acc_values->accValueY*Acc_values->accValueY) +
									(Acc_values->accValueZ*Acc_values->accValueZ));
 8000b72:	b22d      	sxth	r5, r5
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
 8000b74:	fb05 0005 	mla	r0, r5, r5, r0
 8000b78:	f006 ff9a 	bl	8007ab0 <__aeabi_i2f>
 8000b7c:	f007 fc9a 	bl	80084b4 <sqrtf>
									(Acc_values->accValueY*Acc_values->accValueY) +
									(Acc_values->accValueZ*Acc_values->accValueZ));

	/* Allow some kind of overflow */
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
 8000b80:	4649      	mov	r1, r9
 8000b82:	f006 ffe9 	bl	8007b58 <__aeabi_fmul>
 8000b86:	60a0      	str	r0, [r4, #8]
 8000b88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08000b8c <LSM303DLHC_ACC_readValuesDMA>:
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
}

void LSM303DLHC_ACC_readValuesDMA(struct accValues *accXYZ, uint8_t *buffer)
{
 8000b8c:	b538      	push	{r3, r4, r5, lr}
 8000b8e:	460c      	mov	r4, r1
 8000b90:	4605      	mov	r5, r0
	uint8_t cDivider;

	/* Read the register content */
	LSM303DLHC_ReadDMA(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000b92:	2128      	movs	r1, #40	; 0x28
 8000b94:	4622      	mov	r2, r4
 8000b96:	2306      	movs	r3, #6
 8000b98:	2032      	movs	r0, #50	; 0x32
 8000b9a:	f7ff ff17 	bl	80009cc <LSM303DLHC_ReadDMA>

	cDivider=16;

	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000b9e:	7823      	ldrb	r3, [r4, #0]
 8000ba0:	f994 2001 	ldrsb.w	r2, [r4, #1]
 8000ba4:	eb03 2202 	add.w	r2, r3, r2, lsl #8
 8000ba8:	2310      	movs	r3, #16
 8000baa:	fb92 f2f3 	sdiv	r2, r2, r3
 8000bae:	802a      	strh	r2, [r5, #0]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000bb0:	f994 1003 	ldrsb.w	r1, [r4, #3]
 8000bb4:	78a2      	ldrb	r2, [r4, #2]
 8000bb6:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000bba:	fb92 f2f3 	sdiv	r2, r2, r3
 8000bbe:	806a      	strh	r2, [r5, #2]
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
 8000bc0:	f994 1005 	ldrsb.w	r1, [r4, #5]
 8000bc4:	7922      	ldrb	r2, [r4, #4]
 8000bc6:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000bca:	fb92 f3f3 	sdiv	r3, r2, r3
 8000bce:	80ab      	strh	r3, [r5, #4]
 8000bd0:	bd38      	pop	{r3, r4, r5, pc}

08000bd2 <Mag_calibrate>:
//}

#endif

void Mag_calibrate(void)
{
 8000bd2:	b507      	push	{r0, r1, r2, lr}
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);
 8000bd4:	2314      	movs	r3, #20

#endif

void Mag_calibrate(void)
{
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;
 8000bd6:	2100      	movs	r1, #0

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);
 8000bd8:	f88d 3005 	strb.w	r3, [sp, #5]

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000bdc:	203c      	movs	r0, #60	; 0x3c

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);

	/* Configure MEMS: full Scale */
	crb_regm |= (uint8_t) (LSM303DLHC_FS_8_1_GA);
 8000bde:	23e0      	movs	r3, #224	; 0xe0

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000be0:	f10d 0205 	add.w	r2, sp, #5

#endif

void Mag_calibrate(void)
{
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;
 8000be4:	f88d 1007 	strb.w	r1, [sp, #7]

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);

	/* Configure MEMS: full Scale */
	crb_regm |= (uint8_t) (LSM303DLHC_FS_8_1_GA);
 8000be8:	f88d 3006 	strb.w	r3, [sp, #6]

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000bec:	f7ff fe54 	bl	8000898 <LSM303DLHC_Write>

	/* Write value to Mag MEMS CRB_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &crb_regm);
 8000bf0:	203c      	movs	r0, #60	; 0x3c
 8000bf2:	2101      	movs	r1, #1
 8000bf4:	f10d 0206 	add.w	r2, sp, #6
 8000bf8:	f7ff fe4e 	bl	8000898 <LSM303DLHC_Write>

	/* Write value to Mag MEMS MR_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_MR_REG_M, &mr_regm);
 8000bfc:	203c      	movs	r0, #60	; 0x3c
 8000bfe:	2102      	movs	r1, #2
 8000c00:	f10d 0207 	add.w	r2, sp, #7
 8000c04:	f7ff fe48 	bl	8000898 <LSM303DLHC_Write>
}
 8000c08:	bd0e      	pop	{r1, r2, r3, pc}

08000c0a <Mag_readValues>:


void Mag_readValues (struct magValues *magXYZ)
{
 8000c0a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
 8000c0e:	2300      	movs	r3, #0
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &CTRLB, 1);
 8000c10:	2101      	movs	r1, #1


void Mag_readValues (struct magValues *magXYZ)
{
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
 8000c12:	aa02      	add	r2, sp, #8
 8000c14:	f802 3d01 	strb.w	r3, [r2, #-1]!
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_MR_REG_M, &mr_regm);
}


void Mag_readValues (struct magValues *magXYZ)
{
 8000c18:	4606      	mov	r6, r0
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &CTRLB, 1);
 8000c1a:	460b      	mov	r3, r1
 8000c1c:	203c      	movs	r0, #60	; 0x3c
 8000c1e:	f7ff fe83 	bl	8000928 <LSM303DLHC_Read>

  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_X_H_M, buffer, 6);
 8000c22:	2306      	movs	r3, #6
 8000c24:	203c      	movs	r0, #60	; 0x3c
 8000c26:	2103      	movs	r1, #3
 8000c28:	4a38      	ldr	r2, [pc, #224]	; (8000d0c <Mag_readValues+0x102>)
 8000c2a:	f7ff fe7d 	bl	8000928 <LSM303DLHC_Read>
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Y_H_M, buffer+2, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Y_L_M, buffer+3, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_H_M, buffer+4, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_L_M, buffer+5, 1);
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
 8000c2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000c32:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8000c36:	2b80      	cmp	r3, #128	; 0x80
 8000c38:	d01a      	beq.n	8000c70 <Mag_readValues+0x66>
 8000c3a:	d806      	bhi.n	8000c4a <Mag_readValues+0x40>
 8000c3c:	2b40      	cmp	r3, #64	; 0x40
 8000c3e:	d00d      	beq.n	8000c5c <Mag_readValues+0x52>
 8000c40:	2b60      	cmp	r3, #96	; 0x60
 8000c42:	d010      	beq.n	8000c66 <Mag_readValues+0x5c>
 8000c44:	2b20      	cmp	r3, #32
 8000c46:	d106      	bne.n	8000c56 <Mag_readValues+0x4c>
 8000c48:	e024      	b.n	8000c94 <Mag_readValues+0x8a>
 8000c4a:	2bc0      	cmp	r3, #192	; 0xc0
 8000c4c:	d01a      	beq.n	8000c84 <Mag_readValues+0x7a>
 8000c4e:	2be0      	cmp	r3, #224	; 0xe0
 8000c50:	d01d      	beq.n	8000c8e <Mag_readValues+0x84>
 8000c52:	2ba0      	cmp	r3, #160	; 0xa0
 8000c54:	d011      	beq.n	8000c7a <Mag_readValues+0x70>

void Mag_readValues (struct magValues *magXYZ)
{
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
 8000c56:	2400      	movs	r4, #0
 8000c58:	4620      	mov	r0, r4
 8000c5a:	e01f      	b.n	8000c9c <Mag_readValues+0x92>
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
    break;
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
 8000c5c:	f44f 743e 	mov.w	r4, #760	; 0x2f8
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
    break;
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
 8000c60:	f240 3057 	movw	r0, #855	; 0x357
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
    break;
 8000c64:	e01a      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
 8000c66:	f44f 7416 	mov.w	r4, #600	; 0x258
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
    break;
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
 8000c6a:	f240 209e 	movw	r0, #670	; 0x29e
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
    break;
 8000c6e:	e015      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
 8000c70:	f44f 74c8 	mov.w	r4, #400	; 0x190
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
    break;
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
 8000c74:	f44f 70e1 	mov.w	r0, #450	; 0x1c2
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
    break;
 8000c78:	e010      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
 8000c7a:	f240 1463 	movw	r4, #355	; 0x163
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
    break;
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
 8000c7e:	f44f 70c8 	mov.w	r0, #400	; 0x190
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
    break;
 8000c82:	e00b      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
 8000c84:	f240 1427 	movw	r4, #295	; 0x127
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
    break;
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
 8000c88:	f44f 70a5 	mov.w	r0, #330	; 0x14a
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
    break;
 8000c8c:	e006      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_8_1_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
 8000c8e:	24cd      	movs	r4, #205	; 0xcd
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
    break;
  case LSM303DLHC_FS_8_1_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
 8000c90:	20e6      	movs	r0, #230	; 0xe6
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
    break;
 8000c92:	e003      	b.n	8000c9c <Mag_readValues+0x92>
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
  {
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
 8000c94:	f44f 7475 	mov.w	r4, #980	; 0x3d4
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_L_M, buffer+5, 1);
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
  {
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
 8000c98:	f240 404c 	movw	r0, #1100	; 0x44c
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
    break;
  }

  magXYZ->magValueX = (float)((int16_t)(((uint16_t)buffer[0] << 8) + buffer[1])*1000)/Magn_Sensitivity_XY;
 8000c9c:	f006 ff08 	bl	8007ab0 <__aeabi_i2f>
 8000ca0:	4d1a      	ldr	r5, [pc, #104]	; (8000d0c <Mag_readValues+0x102>)
 8000ca2:	4680      	mov	r8, r0
 8000ca4:	786b      	ldrb	r3, [r5, #1]
 8000ca6:	7828      	ldrb	r0, [r5, #0]
 8000ca8:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8000cac:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8000cb0:	b200      	sxth	r0, r0
 8000cb2:	4378      	muls	r0, r7
 8000cb4:	f006 fefc 	bl	8007ab0 <__aeabi_i2f>
 8000cb8:	4641      	mov	r1, r8
 8000cba:	f007 f801 	bl	8007cc0 <__aeabi_fdiv>
 8000cbe:	f007 f911 	bl	8007ee4 <__aeabi_f2iz>
 8000cc2:	8030      	strh	r0, [r6, #0]
  magXYZ->magValueZ = (float)((int16_t)(((uint16_t)buffer[2] << 8) + buffer[3])*1000)/Magn_Sensitivity_XY;
 8000cc4:	78eb      	ldrb	r3, [r5, #3]
 8000cc6:	78a8      	ldrb	r0, [r5, #2]
 8000cc8:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8000ccc:	b200      	sxth	r0, r0
 8000cce:	4378      	muls	r0, r7
 8000cd0:	f006 feee 	bl	8007ab0 <__aeabi_i2f>
 8000cd4:	4641      	mov	r1, r8
 8000cd6:	f006 fff3 	bl	8007cc0 <__aeabi_fdiv>
 8000cda:	f007 f903 	bl	8007ee4 <__aeabi_f2iz>
 8000cde:	80b0      	strh	r0, [r6, #4]
  magXYZ->magValueY = (float)((int16_t)(((uint16_t)buffer[4] << 8) + buffer[5])*1000)/Magn_Sensitivity_Z;
 8000ce0:	796b      	ldrb	r3, [r5, #5]
 8000ce2:	7928      	ldrb	r0, [r5, #4]
 8000ce4:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8000ce8:	b200      	sxth	r0, r0
 8000cea:	4378      	muls	r0, r7
 8000cec:	f006 fee0 	bl	8007ab0 <__aeabi_i2f>
 8000cf0:	4605      	mov	r5, r0
 8000cf2:	4620      	mov	r0, r4
 8000cf4:	f006 fedc 	bl	8007ab0 <__aeabi_i2f>
 8000cf8:	4601      	mov	r1, r0
 8000cfa:	4628      	mov	r0, r5
 8000cfc:	f006 ffe0 	bl	8007cc0 <__aeabi_fdiv>
 8000d00:	f007 f8f0 	bl	8007ee4 <__aeabi_f2iz>
 8000d04:	8070      	strh	r0, [r6, #2]
}
 8000d06:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
 8000d0a:	bf00      	nop
 8000d0c:	20000140 	.word	0x20000140

08000d10 <PWM_Motor>:



void PWM_Motor(uint8_t Motor, uint16_t value)
{
	switch (Motor)
 8000d10:	2805      	cmp	r0, #5
 8000d12:	d816      	bhi.n	8000d42 <PWM_Motor+0x32>
 8000d14:	e8df f000 	tbb	[pc, r0]
 8000d18:	0a070503 	.word	0x0a070503
 8000d1c:	110d      	.short	0x110d
	{
	case 0:
		TIM_SetCompare1(TIM3, value);
 8000d1e:	4809      	ldr	r0, [pc, #36]	; (8000d44 <PWM_Motor+0x34>)
 8000d20:	e009      	b.n	8000d36 <PWM_Motor+0x26>
		break;
	case 1:
		TIM_SetCompare2(TIM3, value);
 8000d22:	4808      	ldr	r0, [pc, #32]	; (8000d44 <PWM_Motor+0x34>)
 8000d24:	e00b      	b.n	8000d3e <PWM_Motor+0x2e>
		break;
	case 2:
		TIM_SetCompare3(TIM3, value);
 8000d26:	4807      	ldr	r0, [pc, #28]	; (8000d44 <PWM_Motor+0x34>)
 8000d28:	f004 b934 	b.w	8004f94 <TIM_SetCompare3>
		break;
	case 3:
		TIM_SetCompare4(TIM3, value);
 8000d2c:	4805      	ldr	r0, [pc, #20]	; (8000d44 <PWM_Motor+0x34>)
 8000d2e:	f004 b933 	b.w	8004f98 <TIM_SetCompare4>
		break;
	case 4:
		TIM_SetCompare1(TIM2, value);
 8000d32:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000d36:	f004 b929 	b.w	8004f8c <TIM_SetCompare1>
		break;
	case 5:
		TIM_SetCompare2(TIM2, value);
 8000d3a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000d3e:	f004 b927 	b.w	8004f90 <TIM_SetCompare2>
 8000d42:	4770      	bx	lr
 8000d44:	40000400 	.word	0x40000400

08000d48 <init_PID>:
#include <PID_control.h>


void init_PID(float sample_rate, float kp, float ki, float kd, PID_Control *values)
{
 8000d48:	b510      	push	{r4, lr}
 8000d4a:	9c02      	ldr	r4, [sp, #8]
	values->sampling_rate = sample_rate;
 8000d4c:	6020      	str	r0, [r4, #0]
	values->kp = kp;
 8000d4e:	60a1      	str	r1, [r4, #8]
	values->ki = ki;
 8000d50:	60e2      	str	r2, [r4, #12]
	values->kd = kd;
 8000d52:	6123      	str	r3, [r4, #16]
 8000d54:	bd10      	pop	{r4, pc}

08000d56 <resetIntegralValues_PID>:
}

void resetIntegralValues_PID(PID_Control *values)
{
	values->ealt = 0;
 8000d56:	2300      	movs	r3, #0
 8000d58:	61c3      	str	r3, [r0, #28]
	values->esum = 0;
 8000d5a:	6183      	str	r3, [r0, #24]
	values->y = 0;
 8000d5c:	6043      	str	r3, [r0, #4]
 8000d5e:	4770      	bx	lr

08000d60 <calc_PID>:
}


/*Simple PID-Calcultion from http://www.rn-wissen.de/index.php/Regelungstechnik*/
void calc_PID(float istwert, float sollwert, PID_Control *values)
{	
 8000d60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000d64:	4614      	mov	r4, r2
		values->e = istwert - sollwert;
 8000d66:	f006 fded 	bl	8007944 <__aeabi_fsub>

		//f�r I-Anteil aufsummieren:
		values->esum = values->esum + (values->e);
 8000d6a:	69a1      	ldr	r1, [r4, #24]


/*Simple PID-Calcultion from http://www.rn-wissen.de/index.php/Regelungstechnik*/
void calc_PID(float istwert, float sollwert, PID_Control *values)
{	
		values->e = istwert - sollwert;
 8000d6c:	6160      	str	r0, [r4, #20]
 8000d6e:	4605      	mov	r5, r0

		//f�r I-Anteil aufsummieren:
		values->esum = values->esum + (values->e);
 8000d70:	f006 fdea 	bl	8007948 <__addsf3>
	
		//PID-Regler	 	
		values->y = (values->kp*values->e) + (values->esum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8000d74:	68a1      	ldr	r1, [r4, #8]
void calc_PID(float istwert, float sollwert, PID_Control *values)
{	
		values->e = istwert - sollwert;

		//f�r I-Anteil aufsummieren:
		values->esum = values->esum + (values->e);
 8000d76:	4607      	mov	r7, r0
 8000d78:	61a0      	str	r0, [r4, #24]
	
		//PID-Regler	 	
		values->y = (values->kp*values->e) + (values->esum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8000d7a:	4628      	mov	r0, r5
 8000d7c:	f006 feec 	bl	8007b58 <__aeabi_fmul>
 8000d80:	6826      	ldr	r6, [r4, #0]
 8000d82:	4680      	mov	r8, r0
 8000d84:	68e1      	ldr	r1, [r4, #12]
 8000d86:	4638      	mov	r0, r7
 8000d88:	f006 fee6 	bl	8007b58 <__aeabi_fmul>
 8000d8c:	4631      	mov	r1, r6
 8000d8e:	f006 fee3 	bl	8007b58 <__aeabi_fmul>
 8000d92:	4601      	mov	r1, r0
 8000d94:	4640      	mov	r0, r8
 8000d96:	f006 fdd7 	bl	8007948 <__addsf3>
 8000d9a:	69e1      	ldr	r1, [r4, #28]
 8000d9c:	4607      	mov	r7, r0
 8000d9e:	4628      	mov	r0, r5
 8000da0:	f006 fdd0 	bl	8007944 <__aeabi_fsub>
 8000da4:	6921      	ldr	r1, [r4, #16]
 8000da6:	f006 fed7 	bl	8007b58 <__aeabi_fmul>
 8000daa:	4631      	mov	r1, r6
 8000dac:	f006 ff88 	bl	8007cc0 <__aeabi_fdiv>
 8000db0:	4601      	mov	r1, r0
 8000db2:	4638      	mov	r0, r7
 8000db4:	f006 fdc8 	bl	8007948 <__addsf3>
	
		//f�r D-Anteil:
		values->ealt = values->e;
 8000db8:	61e5      	str	r5, [r4, #28]

		//f�r I-Anteil aufsummieren:
		values->esum = values->esum + (values->e);
	
		//PID-Regler	 	
		values->y = (values->kp*values->e) + (values->esum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8000dba:	6060      	str	r0, [r4, #4]
	
		//f�r D-Anteil:
		values->ealt = values->e;
 8000dbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08000dc0 <calc_PID_YAW>:
/*
 * The yaw PID calculation needs a special handling as the input value has
 * an integrating character
 * */
void calc_PID_YAW(float istwert, float sollwert, PID_Control *values)
{
 8000dc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000dc4:	4614      	mov	r4, r2
	values->e = istwert - sollwert;
 8000dc6:	f006 fdbd 	bl	8007944 <__aeabi_fsub>

	if(values->e >= 180) values->e -= 360;
 8000dca:	4927      	ldr	r1, [pc, #156]	; (8000e68 <calc_PID_YAW+0xa8>)
 * The yaw PID calculation needs a special handling as the input value has
 * an integrating character
 * */
void calc_PID_YAW(float istwert, float sollwert, PID_Control *values)
{
	values->e = istwert - sollwert;
 8000dcc:	4605      	mov	r5, r0

	if(values->e >= 180) values->e -= 360;
 8000dce:	f007 f875 	bl	8007ebc <__aeabi_fcmpge>
 8000dd2:	b120      	cbz	r0, 8000dde <calc_PID_YAW+0x1e>
 8000dd4:	4628      	mov	r0, r5
 8000dd6:	4925      	ldr	r1, [pc, #148]	; (8000e6c <calc_PID_YAW+0xac>)
 8000dd8:	f006 fdb4 	bl	8007944 <__aeabi_fsub>
 8000ddc:	e00a      	b.n	8000df4 <calc_PID_YAW+0x34>
	else if (values->e <= -180) values->e += 360;
 8000dde:	4628      	mov	r0, r5
 8000de0:	4923      	ldr	r1, [pc, #140]	; (8000e70 <calc_PID_YAW+0xb0>)
 8000de2:	f007 f861 	bl	8007ea8 <__aeabi_fcmple>
 8000de6:	b908      	cbnz	r0, 8000dec <calc_PID_YAW+0x2c>
 * The yaw PID calculation needs a special handling as the input value has
 * an integrating character
 * */
void calc_PID_YAW(float istwert, float sollwert, PID_Control *values)
{
	values->e = istwert - sollwert;
 8000de8:	6165      	str	r5, [r4, #20]
 8000dea:	e004      	b.n	8000df6 <calc_PID_YAW+0x36>

	if(values->e >= 180) values->e -= 360;
	else if (values->e <= -180) values->e += 360;
 8000dec:	4628      	mov	r0, r5
 8000dee:	491f      	ldr	r1, [pc, #124]	; (8000e6c <calc_PID_YAW+0xac>)
 8000df0:	f006 fdaa 	bl	8007948 <__addsf3>
 8000df4:	6160      	str	r0, [r4, #20]

	/* Keep the e-value in a maintainable range */
	if(values->e > 50) values->e = 50;
 8000df6:	4d1f      	ldr	r5, [pc, #124]	; (8000e74 <calc_PID_YAW+0xb4>)
 8000df8:	6960      	ldr	r0, [r4, #20]
 8000dfa:	4629      	mov	r1, r5
 8000dfc:	f007 f868 	bl	8007ed0 <__aeabi_fcmpgt>
 8000e00:	b100      	cbz	r0, 8000e04 <calc_PID_YAW+0x44>
 8000e02:	6165      	str	r5, [r4, #20]
	if(values->e < -50) values->e = -50;
 8000e04:	4d1c      	ldr	r5, [pc, #112]	; (8000e78 <calc_PID_YAW+0xb8>)
 8000e06:	6960      	ldr	r0, [r4, #20]
 8000e08:	4629      	mov	r1, r5
 8000e0a:	f007 f843 	bl	8007e94 <__aeabi_fcmplt>
 8000e0e:	b100      	cbz	r0, 8000e12 <calc_PID_YAW+0x52>
 8000e10:	6165      	str	r5, [r4, #20]

	//f�r I-Anteil aufsummieren:
	values->esum = values->esum + (values->e);
 8000e12:	6965      	ldr	r5, [r4, #20]
 8000e14:	69a1      	ldr	r1, [r4, #24]
 8000e16:	4628      	mov	r0, r5
 8000e18:	f006 fd96 	bl	8007948 <__addsf3>

	//PID-Regler
	values->y = (values->kp*values->e) + (values->esum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8000e1c:	68a1      	ldr	r1, [r4, #8]
	/* Keep the e-value in a maintainable range */
	if(values->e > 50) values->e = 50;
	if(values->e < -50) values->e = -50;

	//f�r I-Anteil aufsummieren:
	values->esum = values->esum + (values->e);
 8000e1e:	4607      	mov	r7, r0
 8000e20:	61a0      	str	r0, [r4, #24]

	//PID-Regler
	values->y = (values->kp*values->e) + (values->esum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8000e22:	4628      	mov	r0, r5
 8000e24:	f006 fe98 	bl	8007b58 <__aeabi_fmul>
 8000e28:	6826      	ldr	r6, [r4, #0]
 8000e2a:	4680      	mov	r8, r0
 8000e2c:	68e1      	ldr	r1, [r4, #12]
 8000e2e:	4638      	mov	r0, r7
 8000e30:	f006 fe92 	bl	8007b58 <__aeabi_fmul>
 8000e34:	4631      	mov	r1, r6
 8000e36:	f006 fe8f 	bl	8007b58 <__aeabi_fmul>
 8000e3a:	4601      	mov	r1, r0
 8000e3c:	4640      	mov	r0, r8
 8000e3e:	f006 fd83 	bl	8007948 <__addsf3>
 8000e42:	69e1      	ldr	r1, [r4, #28]
 8000e44:	4607      	mov	r7, r0
 8000e46:	4628      	mov	r0, r5
 8000e48:	f006 fd7c 	bl	8007944 <__aeabi_fsub>
 8000e4c:	6921      	ldr	r1, [r4, #16]
 8000e4e:	f006 fe83 	bl	8007b58 <__aeabi_fmul>
 8000e52:	4631      	mov	r1, r6
 8000e54:	f006 ff34 	bl	8007cc0 <__aeabi_fdiv>
 8000e58:	4601      	mov	r1, r0
 8000e5a:	4638      	mov	r0, r7
 8000e5c:	f006 fd74 	bl	8007948 <__addsf3>

	//f�r D-Anteil:
	values->ealt = values->e;
 8000e60:	61e5      	str	r5, [r4, #28]

	//f�r I-Anteil aufsummieren:
	values->esum = values->esum + (values->e);

	//PID-Regler
	values->y = (values->kp*values->e) + (values->esum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8000e62:	6060      	str	r0, [r4, #4]

	//f�r D-Anteil:
	values->ealt = values->e;
 8000e64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000e68:	43340000 	.word	0x43340000
 8000e6c:	43b40000 	.word	0x43b40000
 8000e70:	c3340000 	.word	0xc3340000
 8000e74:	42480000 	.word	0x42480000
 8000e78:	c2480000 	.word	0xc2480000

08000e7c <VectorDotProduct>:
#include <Vector_math.h>


//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
 8000e7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e7e:	4607      	mov	r7, r0
 8000e80:	460e      	mov	r6, r1
 8000e82:	2400      	movs	r4, #0
	int c = 0;
	float op=0;      
 8000e84:	2500      	movs	r5, #0
	for( c = 0 ; c < 3 ; c++ )   
	{   
		op += vector1[c] * vector2[c];   
 8000e86:	5931      	ldr	r1, [r6, r4]
 8000e88:	5938      	ldr	r0, [r7, r4]
 8000e8a:	f006 fe65 	bl	8007b58 <__aeabi_fmul>
 8000e8e:	4601      	mov	r1, r0
 8000e90:	4628      	mov	r0, r5
 8000e92:	f006 fd59 	bl	8007948 <__addsf3>
 8000e96:	3404      	adds	r4, #4
//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
	int c = 0;
	float op=0;      
	for( c = 0 ; c < 3 ; c++ )   
 8000e98:	2c0c      	cmp	r4, #12
	{   
		op += vector1[c] * vector2[c];   
 8000e9a:	4605      	mov	r5, r0
//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
	int c = 0;
	float op=0;      
	for( c = 0 ; c < 3 ; c++ )   
 8000e9c:	d1f3      	bne.n	8000e86 <VectorDotProduct+0xa>
	{   
		op += vector1[c] * vector2[c];   
	}      
	return op;  
}  
 8000e9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000ea0 <VectorCrossProduct>:

//Computes the cross product of two vectors 
void VectorCrossProduct(float vectorOut[3], float v1[3],float v2[3]) 
{   
 8000ea0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ea2:	460d      	mov	r5, r1
 8000ea4:	4606      	mov	r6, r0
	vectorOut[0] = (v1[1]*v2[2]) - (v1[2]*v2[1]);   
 8000ea6:	6848      	ldr	r0, [r1, #4]
 8000ea8:	6891      	ldr	r1, [r2, #8]
	return op;  
}  

//Computes the cross product of two vectors 
void VectorCrossProduct(float vectorOut[3], float v1[3],float v2[3]) 
{   
 8000eaa:	4614      	mov	r4, r2
	vectorOut[0] = (v1[1]*v2[2]) - (v1[2]*v2[1]);   
 8000eac:	f006 fe54 	bl	8007b58 <__aeabi_fmul>
 8000eb0:	6861      	ldr	r1, [r4, #4]
 8000eb2:	4607      	mov	r7, r0
 8000eb4:	68a8      	ldr	r0, [r5, #8]
 8000eb6:	f006 fe4f 	bl	8007b58 <__aeabi_fmul>
 8000eba:	4601      	mov	r1, r0
 8000ebc:	4638      	mov	r0, r7
 8000ebe:	f006 fd41 	bl	8007944 <__aeabi_fsub>
 8000ec2:	6030      	str	r0, [r6, #0]
	vectorOut[1] = (v1[2]*v2[0]) - (v1[0]*v2[2]);   
 8000ec4:	6821      	ldr	r1, [r4, #0]
 8000ec6:	68a8      	ldr	r0, [r5, #8]
 8000ec8:	f006 fe46 	bl	8007b58 <__aeabi_fmul>
 8000ecc:	68a1      	ldr	r1, [r4, #8]
 8000ece:	4607      	mov	r7, r0
 8000ed0:	6828      	ldr	r0, [r5, #0]
 8000ed2:	f006 fe41 	bl	8007b58 <__aeabi_fmul>
 8000ed6:	4601      	mov	r1, r0
 8000ed8:	4638      	mov	r0, r7
 8000eda:	f006 fd33 	bl	8007944 <__aeabi_fsub>
 8000ede:	6070      	str	r0, [r6, #4]
	vectorOut[2] = (v1[0]*v2[1]) - (v1[1]*v2[0]); 
 8000ee0:	6861      	ldr	r1, [r4, #4]
 8000ee2:	6828      	ldr	r0, [r5, #0]
 8000ee4:	f006 fe38 	bl	8007b58 <__aeabi_fmul>
 8000ee8:	6821      	ldr	r1, [r4, #0]
 8000eea:	4607      	mov	r7, r0
 8000eec:	6868      	ldr	r0, [r5, #4]
 8000eee:	f006 fe33 	bl	8007b58 <__aeabi_fmul>
 8000ef2:	4601      	mov	r1, r0
 8000ef4:	4638      	mov	r0, r7
 8000ef6:	f006 fd25 	bl	8007944 <__aeabi_fsub>
 8000efa:	60b0      	str	r0, [r6, #8]
 8000efc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000efe <VectorScale>:
}  

//Multiply the vector by a scalar.  
void VectorScale(float vectorOut[3],float vectorIn[3], float scale2) 
{   
 8000efe:	b570      	push	{r4, r5, r6, lr}
 8000f00:	4604      	mov	r4, r0
 8000f02:	460d      	mov	r5, r1
	int c = 0;
	for( c = 0 ; c < 3 ; c++ )   
	{    
		vectorOut[c] = vectorIn[c] * scale2;    
 8000f04:	6808      	ldr	r0, [r1, #0]
 8000f06:	4611      	mov	r1, r2
	vectorOut[2] = (v1[0]*v2[1]) - (v1[1]*v2[0]); 
}  

//Multiply the vector by a scalar.  
void VectorScale(float vectorOut[3],float vectorIn[3], float scale2) 
{   
 8000f08:	4616      	mov	r6, r2
	int c = 0;
	for( c = 0 ; c < 3 ; c++ )   
	{    
		vectorOut[c] = vectorIn[c] * scale2;    
 8000f0a:	f006 fe25 	bl	8007b58 <__aeabi_fmul>
 8000f0e:	6020      	str	r0, [r4, #0]
 8000f10:	6868      	ldr	r0, [r5, #4]
 8000f12:	4631      	mov	r1, r6
 8000f14:	f006 fe20 	bl	8007b58 <__aeabi_fmul>
 8000f18:	6060      	str	r0, [r4, #4]
 8000f1a:	68a8      	ldr	r0, [r5, #8]
 8000f1c:	4631      	mov	r1, r6
 8000f1e:	f006 fe1b 	bl	8007b58 <__aeabi_fmul>
 8000f22:	60a0      	str	r0, [r4, #8]
 8000f24:	bd70      	pop	{r4, r5, r6, pc}

08000f26 <VectorAdd>:
	} 
}  

void VectorAdd(float vectorOut[3],float vectorIn1[3], float vectorIn2[3]) 
{
 8000f26:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000f28:	4605      	mov	r5, r0
 8000f2a:	460e      	mov	r6, r1
 8000f2c:	4617      	mov	r7, r2
 8000f2e:	2400      	movs	r4, #0
	int c = 0;
   
	for(c = 0 ; c < 3 ; c++ )   
	{      
		vectorOut[c] = vectorIn1[c] + vectorIn2[c];   
 8000f30:	5930      	ldr	r0, [r6, r4]
 8000f32:	5939      	ldr	r1, [r7, r4]
 8000f34:	f006 fd08 	bl	8007948 <__addsf3>
 8000f38:	5128      	str	r0, [r5, r4]
 8000f3a:	3404      	adds	r4, #4

void VectorAdd(float vectorOut[3],float vectorIn1[3], float vectorIn2[3]) 
{
	int c = 0;
   
	for(c = 0 ; c < 3 ; c++ )   
 8000f3c:	2c0c      	cmp	r4, #12
 8000f3e:	d1f7      	bne.n	8000f30 <VectorAdd+0xa>
	{      
		vectorOut[c] = vectorIn1[c] + vectorIn2[c];   
	} 
} 
 8000f40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000f42 <MatrixMultiply>:



//Multiply two 3x3 matrices. 
void MatrixMultiply(float a[3][3], float b[3][3],float mat[3][3]) 
{   
 8000f42:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000f46:	4681      	mov	r9, r0
 8000f48:	b087      	sub	sp, #28
 8000f4a:	4688      	mov	r8, r1
 8000f4c:	4607      	mov	r7, r0
} 



//Multiply two 3x3 matrices. 
void MatrixMultiply(float a[3][3], float b[3][3],float mat[3][3]) 
 8000f4e:	2500      	movs	r5, #0
 8000f50:	e025      	b.n	8000f9e <MatrixMultiply+0x5c>
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
			{        
				op[w] = a[x][w]*b[w][y];       
 8000f52:	f858 1004 	ldr.w	r1, [r8, r4]
 8000f56:	f859 0005 	ldr.w	r0, [r9, r5]
 8000f5a:	9201      	str	r2, [sp, #4]
 8000f5c:	f006 fdfc 	bl	8007b58 <__aeabi_fmul>
 8000f60:	68f1      	ldr	r1, [r6, #12]
 8000f62:	4682      	mov	sl, r0
 8000f64:	9003      	str	r0, [sp, #12]
 8000f66:	6878      	ldr	r0, [r7, #4]
 8000f68:	f006 fdf6 	bl	8007b58 <__aeabi_fmul>
 8000f6c:	4601      	mov	r1, r0
 8000f6e:	9004      	str	r0, [sp, #16]
			}        
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
 8000f70:	4650      	mov	r0, sl
 8000f72:	f006 fce9 	bl	8007948 <__addsf3>
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
			{        
				op[w] = a[x][w]*b[w][y];       
 8000f76:	69b1      	ldr	r1, [r6, #24]
			}        
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
 8000f78:	4682      	mov	sl, r0
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
			{        
				op[w] = a[x][w]*b[w][y];       
 8000f7a:	68b8      	ldr	r0, [r7, #8]
 8000f7c:	f006 fdec 	bl	8007b58 <__aeabi_fmul>
 8000f80:	4601      	mov	r1, r0
			}        
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
 8000f82:	4650      	mov	r0, sl
 8000f84:	f006 fce0 	bl	8007948 <__addsf3>
 8000f88:	f84b 0004 	str.w	r0, [fp, r4]
 8000f8c:	3404      	adds	r4, #4
 8000f8e:	3604      	adds	r6, #4
	int w = 0;
	//float test = 0;
	
	for(  x = 0 ; x < 3 ; x++ )   
	{     
		for(  y = 0 ; y < 3 ; y++ )     
 8000f90:	2c0c      	cmp	r4, #12
 8000f92:	9a01      	ldr	r2, [sp, #4]
 8000f94:	d1dd      	bne.n	8000f52 <MatrixMultiply+0x10>
 8000f96:	350c      	adds	r5, #12
 8000f98:	370c      	adds	r7, #12
	int x = 0;
	int y = 0;
	int w = 0;
	//float test = 0;
	
	for(  x = 0 ; x < 3 ; x++ )   
 8000f9a:	2d24      	cmp	r5, #36	; 0x24
 8000f9c:	d004      	beq.n	8000fa8 <MatrixMultiply+0x66>
} 



//Multiply two 3x3 matrices. 
void MatrixMultiply(float a[3][3], float b[3][3],float mat[3][3]) 
 8000f9e:	eb02 0b05 	add.w	fp, r2, r5
 8000fa2:	4646      	mov	r6, r8
 8000fa4:	2400      	movs	r4, #0
 8000fa6:	e7d4      	b.n	8000f52 <MatrixMultiply+0x10>
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
			//test=mat[x][y];     
		}   
	} 
} 
 8000fa8:	b007      	add	sp, #28
 8000faa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08000fb0 <update_intFilter>:
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
	filter->r = newMeasurement + filter->r - filter->filtered;
 8000fb0:	6803      	ldr	r3, [r0, #0]
#include <filter_Lib.h>
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
 8000fb2:	b510      	push	{r4, lr}
	filter->r = newMeasurement + filter->r - filter->filtered;
 8000fb4:	6844      	ldr	r4, [r0, #4]
 8000fb6:	18d2      	adds	r2, r2, r3
 8000fb8:	1b12      	subs	r2, r2, r4
	filter->filtered = filter->r>>lowpassValue;
 8000fba:	fa42 f101 	asr.w	r1, r2, r1
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
	filter->r = newMeasurement + filter->r - filter->filtered;
 8000fbe:	6002      	str	r2, [r0, #0]
	filter->filtered = filter->r>>lowpassValue;
 8000fc0:	6041      	str	r1, [r0, #4]
 8000fc2:	bd10      	pop	{r4, pc}

08000fc4 <initAvgValues>:
}

void initAvgValues(struct movingAverageValues *avg)
{
	int i = 0;
	avg->countValue = 0;
 8000fc4:	2300      	movs	r3, #0
 8000fc6:	6143      	str	r3, [r0, #20]
	for(i = 0;i<MA_VALUE;i++)
	{
		avg->avgArray[i] = 0;
 8000fc8:	6003      	str	r3, [r0, #0]
 8000fca:	6043      	str	r3, [r0, #4]
 8000fcc:	6083      	str	r3, [r0, #8]
 8000fce:	60c3      	str	r3, [r0, #12]
 8000fd0:	6103      	str	r3, [r0, #16]
 8000fd2:	4770      	bx	lr

08000fd4 <calcMovingAvg>:

int calcMovingAvg(struct movingAverageValues *avg, int newValue)
{
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
 8000fd4:	6943      	ldr	r3, [r0, #20]
 8000fd6:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 8000fda:	e890 0006 	ldmia.w	r0, {r1, r2}
 8000fde:	1889      	adds	r1, r1, r2
 8000fe0:	6882      	ldr	r2, [r0, #8]
	}
	avg->countValue++;
 8000fe2:	3301      	adds	r3, #1
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 8000fe4:	1889      	adds	r1, r1, r2
 8000fe6:	68c2      	ldr	r2, [r0, #12]
	}
	avg->countValue++;
	if (avg->countValue >= MA_VALUE)
 8000fe8:	2b04      	cmp	r3, #4
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 8000fea:	4411      	add	r1, r2
 8000fec:	6902      	ldr	r2, [r0, #16]
	}
	avg->countValue++;
	if (avg->countValue >= MA_VALUE)
	{
		avg->countValue = 0;
 8000fee:	bfc8      	it	gt
 8000ff0:	2300      	movgt	r3, #0
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 8000ff2:	188a      	adds	r2, r1, r2
	}
	avg->countValue++;
	if (avg->countValue >= MA_VALUE)
	{
		avg->countValue = 0;
 8000ff4:	6143      	str	r3, [r0, #20]
	}
	return result/MA_VALUE;
}
 8000ff6:	2005      	movs	r0, #5
 8000ff8:	fb92 f0f0 	sdiv	r0, r2, r0
 8000ffc:	4770      	bx	lr

08000ffe <quickSort>:


void quickSort (int a[], int lo, int hi)
{
 8000ffe:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001002:	4605      	mov	r5, r0
 8001004:	4616      	mov	r6, r2
//  lo is the lower index, hi is the upper index
//  of the region of array a that is to be sorted
    int i=lo, j=hi, h;
    int x=a[(lo+hi)/2];
 8001006:	f04f 0802 	mov.w	r8, #2
 800100a:	198b      	adds	r3, r1, r6
 800100c:	fb93 f3f8 	sdiv	r3, r3, r8
 8001010:	f855 a023 	ldr.w	sl, [r5, r3, lsl #2]
	}
	return result/MA_VALUE;
}


void quickSort (int a[], int lo, int hi)
 8001014:	eb05 0281 	add.w	r2, r5, r1, lsl #2
 8001018:	1c4c      	adds	r4, r1, #1
{
//  lo is the lower index, hi is the upper index
//  of the region of array a that is to be sorted
    int i=lo, j=hi, h;
 800101a:	4633      	mov	r3, r6
 800101c:	e000      	b.n	8001020 <quickSort+0x22>
 800101e:	3401      	adds	r4, #1
    int x=a[(lo+hi)/2];

    //  partition
    do
    {
        while (a[i]<x) i++;
 8001020:	f852 cb04 	ldr.w	ip, [r2], #4
	}
	return result/MA_VALUE;
}


void quickSort (int a[], int lo, int hi)
 8001024:	1e67      	subs	r7, r4, #1
    int x=a[(lo+hi)/2];

    //  partition
    do
    {
        while (a[i]<x) i++;
 8001026:	45d4      	cmp	ip, sl
 8001028:	dbf9      	blt.n	800101e <quickSort+0x20>
	}
	return result/MA_VALUE;
}


void quickSort (int a[], int lo, int hi)
 800102a:	eb05 0083 	add.w	r0, r5, r3, lsl #2
 800102e:	e000      	b.n	8001032 <quickSort+0x34>

    //  partition
    do
    {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
 8001030:	3b01      	subs	r3, #1
 8001032:	4683      	mov	fp, r0
 8001034:	f850 9904 	ldr.w	r9, [r0], #-4
 8001038:	45d1      	cmp	r9, sl
 800103a:	dcf9      	bgt.n	8001030 <quickSort+0x32>
        if (i<=j)
 800103c:	429f      	cmp	r7, r3
 800103e:	dc07      	bgt.n	8001050 <quickSort+0x52>
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
            i++; j--;
 8001040:	3b01      	subs	r3, #1
        }
    } while (i<=j);
 8001042:	429c      	cmp	r4, r3
    {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j)
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
 8001044:	f842 9c04 	str.w	r9, [r2, #-4]
            i++; j--;
 8001048:	4627      	mov	r7, r4
    {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j)
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
 800104a:	f8cb c000 	str.w	ip, [fp]
            i++; j--;
        }
    } while (i<=j);
 800104e:	dde6      	ble.n	800101e <quickSort+0x20>

    //  recursion
    if (lo<j) quickSort(a, lo, j);
 8001050:	4299      	cmp	r1, r3
 8001052:	da03      	bge.n	800105c <quickSort+0x5e>
 8001054:	4628      	mov	r0, r5
 8001056:	461a      	mov	r2, r3
 8001058:	f7ff ffd1 	bl	8000ffe <quickSort>
    if (i<hi) quickSort(a, i, hi);
 800105c:	42b7      	cmp	r7, r6
 800105e:	4639      	mov	r1, r7
 8001060:	dbd3      	blt.n	800100a <quickSort+0xc>
}
 8001062:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001066 <calcStdDev>:

int calcStdDev (int a[], int index, int avgVal)
{
	int sum = 0, i = 0;

	for(i = 0; i<index;i++)
 8001066:	2300      	movs	r3, #0
}



int calcStdDev (int a[], int index, int avgVal)
{
 8001068:	b510      	push	{r4, lr}
	int sum = 0, i = 0;
 800106a:	461c      	mov	r4, r3

	for(i = 0; i<index;i++)
 800106c:	e004      	b.n	8001078 <calcStdDev+0x12>
	{
		sum = (a[i]-avgVal)*(a[i]-avgVal);
 800106e:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]

int calcStdDev (int a[], int index, int avgVal)
{
	int sum = 0, i = 0;

	for(i = 0; i<index;i++)
 8001072:	3301      	adds	r3, #1
	{
		sum = (a[i]-avgVal)*(a[i]-avgVal);
 8001074:	1aa4      	subs	r4, r4, r2
 8001076:	4364      	muls	r4, r4

int calcStdDev (int a[], int index, int avgVal)
{
	int sum = 0, i = 0;

	for(i = 0; i<index;i++)
 8001078:	428b      	cmp	r3, r1
 800107a:	dbf8      	blt.n	800106e <calcStdDev+0x8>
	{
		sum = (a[i]-avgVal)*(a[i]-avgVal);
	}
	return (sqrt(sum/(index-1)));
 800107c:	1e48      	subs	r0, r1, #1
 800107e:	fb94 f0f0 	sdiv	r0, r4, r0
 8001082:	f006 fb7d 	bl	8007780 <__aeabi_i2d>
 8001086:	f007 f96b 	bl	8008360 <sqrt>
 800108a:	f006 fbdf 	bl	800784c <__aeabi_d2iz>
}
 800108e:	bd10      	pop	{r4, pc}

08001090 <floatFilterAcc1>:
/*
 * SampleRate 250Hz cutoff: 5Hz 4th order Butterworth
 * http://www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html
 */
void floatFilterAcc1(floatFilter *value, int newValue)
{
 8001090:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001094:	6843      	ldr	r3, [r0, #4]
 8001096:	f8d0 900c 	ldr.w	r9, [r0, #12]
 800109a:	f8d0 b008 	ldr.w	fp, [r0, #8]
 800109e:	f8d0 a010 	ldr.w	sl, [r0, #16]
/*
 * SampleRate 250Hz cutoff: 5Hz 4th order Butterworth
 * http://www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html
 */
void floatFilterAcc1(floatFilter *value, int newValue)
{
 80010a2:	4604      	mov	r4, r0
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 80010a4:	6003      	str	r3, [r0, #0]
 80010a6:	f8c0 9008 	str.w	r9, [r0, #8]
 80010aa:	f8c0 a00c 	str.w	sl, [r0, #12]
 80010ae:	f8c0 b004 	str.w	fp, [r0, #4]
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
 80010b2:	4608      	mov	r0, r1
 80010b4:	9301      	str	r3, [sp, #4]
 80010b6:	f006 fcfb 	bl	8007ab0 <__aeabi_i2f>
 80010ba:	4929      	ldr	r1, [pc, #164]	; (8001160 <floatFilterAcc1+0xd0>)
 80010bc:	f006 fe00 	bl	8007cc0 <__aeabi_fdiv>
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 80010c0:	f8d4 8018 	ldr.w	r8, [r4, #24]
 80010c4:	69e7      	ldr	r7, [r4, #28]
 80010c6:	6a26      	ldr	r6, [r4, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 80010c8:	9b01      	ldr	r3, [sp, #4]
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 80010ca:	6a65      	ldr	r5, [r4, #36]	; 0x24
void floatFilterAcc1(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
 80010cc:	4601      	mov	r1, r0
 80010ce:	6120      	str	r0, [r4, #16]
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 80010d0:	f8c4 8014 	str.w	r8, [r4, #20]
 80010d4:	61a7      	str	r7, [r4, #24]
 80010d6:	61e6      	str	r6, [r4, #28]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 80010d8:	4618      	mov	r0, r3
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 80010da:	6225      	str	r5, [r4, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 80010dc:	f006 fc34 	bl	8007948 <__addsf3>
 80010e0:	4651      	mov	r1, sl
 80010e2:	4603      	mov	r3, r0
 80010e4:	4658      	mov	r0, fp
 80010e6:	9301      	str	r3, [sp, #4]
 80010e8:	f006 fc2e 	bl	8007948 <__addsf3>
 80010ec:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 80010f0:	f006 fd32 	bl	8007b58 <__aeabi_fmul>
 80010f4:	9b01      	ldr	r3, [sp, #4]
 80010f6:	4601      	mov	r1, r0
 80010f8:	4618      	mov	r0, r3
 80010fa:	f006 fc25 	bl	8007948 <__addsf3>
 80010fe:	4919      	ldr	r1, [pc, #100]	; (8001164 <floatFilterAcc1+0xd4>)
 8001100:	4682      	mov	sl, r0
 8001102:	4648      	mov	r0, r9
 8001104:	f006 fd28 	bl	8007b58 <__aeabi_fmul>
 8001108:	4601      	mov	r1, r0
 800110a:	4650      	mov	r0, sl
 800110c:	f006 fc1c 	bl	8007948 <__addsf3>
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001110:	4915      	ldr	r1, [pc, #84]	; (8001168 <floatFilterAcc1+0xd8>)
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001112:	4681      	mov	r9, r0
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001114:	4640      	mov	r0, r8
 8001116:	f006 fd1f 	bl	8007b58 <__aeabi_fmul>
 800111a:	4601      	mov	r1, r0
 800111c:	4648      	mov	r0, r9
 800111e:	f006 fc13 	bl	8007948 <__addsf3>
 8001122:	4912      	ldr	r1, [pc, #72]	; (800116c <floatFilterAcc1+0xdc>)
 8001124:	4680      	mov	r8, r0
 8001126:	4638      	mov	r0, r7
 8001128:	f006 fd16 	bl	8007b58 <__aeabi_fmul>
 800112c:	4601      	mov	r1, r0
 800112e:	4640      	mov	r0, r8
 8001130:	f006 fc0a 	bl	8007948 <__addsf3>
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
 8001134:	490e      	ldr	r1, [pc, #56]	; (8001170 <floatFilterAcc1+0xe0>)
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001136:	4607      	mov	r7, r0
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
 8001138:	4630      	mov	r0, r6
 800113a:	f006 fd0d 	bl	8007b58 <__aeabi_fmul>
 800113e:	4601      	mov	r1, r0
 8001140:	4638      	mov	r0, r7
 8001142:	f006 fc01 	bl	8007948 <__addsf3>
 8001146:	490b      	ldr	r1, [pc, #44]	; (8001174 <floatFilterAcc1+0xe4>)
 8001148:	4606      	mov	r6, r0
 800114a:	4628      	mov	r0, r5
 800114c:	f006 fd04 	bl	8007b58 <__aeabi_fmul>
 8001150:	4601      	mov	r1, r0
 8001152:	4630      	mov	r0, r6
 8001154:	f006 fbf8 	bl	8007948 <__addsf3>
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001158:	6260      	str	r0, [r4, #36]	; 0x24
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
	value->currentValue = yv[4];
 800115a:	62a0      	str	r0, [r4, #40]	; 0x28
}
 800115c:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001160:	4a233904 	.word	0x4a233904
 8001164:	40c00000 	.word	0x40c00000
 8001168:	bf607c4b 	.word	0xbf607c4b
 800116c:	4067db50 	.word	0x4067db50
 8001170:	c0b3aa34 	.word	0xc0b3aa34
 8001174:	40779812 	.word	0x40779812

08001178 <floatFilterAcc2>:

void floatFilterAcc2(floatFilter *value, int newValue)
{
 8001178:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
 800117c:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8001180:	6887      	ldr	r7, [r0, #8]
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
	value->currentValue = yv[4];
}

void floatFilterAcc2(floatFilter *value, int newValue)
{
 8001182:	4604      	mov	r4, r0
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
 8001184:	f8c0 8000 	str.w	r8, [r0]
 8001188:	6047      	str	r7, [r0, #4]
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
 800118a:	4608      	mov	r0, r1
 800118c:	f006 fc90 	bl	8007ab0 <__aeabi_i2f>
 8001190:	4915      	ldr	r1, [pc, #84]	; (80011e8 <floatFilterAcc2+0x70>)
 8001192:	f006 fd95 	bl	8007cc0 <__aeabi_fdiv>
    yv[0] = yv[1]; yv[1] = yv[2];
 8001196:	69a6      	ldr	r6, [r4, #24]
 8001198:	69e5      	ldr	r5, [r4, #28]
void floatFilterAcc2(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
 800119a:	4601      	mov	r1, r0
 800119c:	60a0      	str	r0, [r4, #8]
    yv[0] = yv[1]; yv[1] = yv[2];
 800119e:	6166      	str	r6, [r4, #20]
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 80011a0:	4640      	mov	r0, r8
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
 80011a2:	61a5      	str	r5, [r4, #24]
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 80011a4:	f006 fbd0 	bl	8007948 <__addsf3>
 80011a8:	4639      	mov	r1, r7
 80011aa:	4680      	mov	r8, r0
 80011ac:	4638      	mov	r0, r7
 80011ae:	f006 fbcb 	bl	8007948 <__addsf3>
 80011b2:	4601      	mov	r1, r0
 80011b4:	4640      	mov	r0, r8
 80011b6:	f006 fbc7 	bl	8007948 <__addsf3>
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
 80011ba:	490c      	ldr	r1, [pc, #48]	; (80011ec <floatFilterAcc2+0x74>)
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 80011bc:	4607      	mov	r7, r0
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
 80011be:	4630      	mov	r0, r6
 80011c0:	f006 fcca 	bl	8007b58 <__aeabi_fmul>
 80011c4:	4601      	mov	r1, r0
 80011c6:	4638      	mov	r0, r7
 80011c8:	f006 fbbe 	bl	8007948 <__addsf3>
 80011cc:	4908      	ldr	r1, [pc, #32]	; (80011f0 <floatFilterAcc2+0x78>)
 80011ce:	4606      	mov	r6, r0
 80011d0:	4628      	mov	r0, r5
 80011d2:	f006 fcc1 	bl	8007b58 <__aeabi_fmul>
 80011d6:	4601      	mov	r1, r0
 80011d8:	4630      	mov	r0, r6
 80011da:	f006 fbb5 	bl	8007948 <__addsf3>
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 80011de:	61e0      	str	r0, [r4, #28]
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
    value->currentValue = yv[2];
 80011e0:	62a0      	str	r0, [r4, #40]	; 0x28
 80011e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80011e6:	bf00      	nop
 80011e8:	46c7a769 	.word	0x46c7a769
 80011ec:	bf7b7d9d 	.word	0xbf7b7d9d
 80011f0:	3ffdb9ad 	.word	0x3ffdb9ad

080011f4 <floatFilterAcc>:
}

void floatFilterAcc(floatFilter *value, int newValue)
{
 80011f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
 80011f8:	f8d0 8004 	ldr.w	r8, [r0, #4]
 80011fc:	6887      	ldr	r7, [r0, #8]
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
    value->currentValue = yv[2];
}

void floatFilterAcc(floatFilter *value, int newValue)
{
 80011fe:	4604      	mov	r4, r0
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
 8001200:	f8c0 8000 	str.w	r8, [r0]
 8001204:	6047      	str	r7, [r0, #4]
	xv[2] = (float)newValue / 1.017716736e+05 /*GAIN*/;
 8001206:	4608      	mov	r0, r1
 8001208:	f006 fc52 	bl	8007ab0 <__aeabi_i2f>
 800120c:	4915      	ldr	r1, [pc, #84]	; (8001264 <floatFilterAcc+0x70>)
 800120e:	f006 fd57 	bl	8007cc0 <__aeabi_fdiv>
    yv[0] = yv[1]; yv[1] = yv[2];
 8001212:	69a6      	ldr	r6, [r4, #24]
 8001214:	69e5      	ldr	r5, [r4, #28]
void floatFilterAcc(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 1.017716736e+05 /*GAIN*/;
 8001216:	4601      	mov	r1, r0
 8001218:	60a0      	str	r0, [r4, #8]
    yv[0] = yv[1]; yv[1] = yv[2];
 800121a:	6166      	str	r6, [r4, #20]
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 800121c:	4640      	mov	r0, r8
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 1.017716736e+05 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
 800121e:	61a5      	str	r5, [r4, #24]
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 8001220:	f006 fb92 	bl	8007948 <__addsf3>
 8001224:	4639      	mov	r1, r7
 8001226:	4680      	mov	r8, r0
 8001228:	4638      	mov	r0, r7
 800122a:	f006 fb8d 	bl	8007948 <__addsf3>
 800122e:	4601      	mov	r1, r0
 8001230:	4640      	mov	r0, r8
 8001232:	f006 fb89 	bl	8007948 <__addsf3>
                 + ( -0.9911535959 * yv[0]) + (  1.9911142922 * yv[1]);
 8001236:	490c      	ldr	r1, [pc, #48]	; (8001268 <floatFilterAcc+0x74>)
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 1.017716736e+05 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 8001238:	4607      	mov	r7, r0
                 + ( -0.9911535959 * yv[0]) + (  1.9911142922 * yv[1]);
 800123a:	4630      	mov	r0, r6
 800123c:	f006 fc8c 	bl	8007b58 <__aeabi_fmul>
 8001240:	4601      	mov	r1, r0
 8001242:	4638      	mov	r0, r7
 8001244:	f006 fb80 	bl	8007948 <__addsf3>
 8001248:	4908      	ldr	r1, [pc, #32]	; (800126c <floatFilterAcc+0x78>)
 800124a:	4606      	mov	r6, r0
 800124c:	4628      	mov	r0, r5
 800124e:	f006 fc83 	bl	8007b58 <__aeabi_fmul>
 8001252:	4601      	mov	r1, r0
 8001254:	4630      	mov	r0, r6
 8001256:	f006 fb77 	bl	8007948 <__addsf3>
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 1.017716736e+05 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 800125a:	61e0      	str	r0, [r4, #28]
                 + ( -0.9911535959 * yv[0]) + (  1.9911142922 * yv[1]);
    value->currentValue = yv[2];
 800125c:	62a0      	str	r0, [r4, #40]	; 0x28
 800125e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001262:	bf00      	nop
 8001264:	47c6c5d6 	.word	0x47c6c5d6
 8001268:	bf7dbc3e 	.word	0xbf7dbc3e
 800126c:	3ffedcd5 	.word	0x3ffedcd5

08001270 <floatFilterGyro>:
/*
 * SampleRate 500Hz, cutoff 200Hz, 4th order Butterworth
 * http://www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html
 */
void floatFilterGyro(floatFilter *value, int newValue)
{
 8001270:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001274:	6843      	ldr	r3, [r0, #4]
 8001276:	f8d0 900c 	ldr.w	r9, [r0, #12]
 800127a:	f8d0 b008 	ldr.w	fp, [r0, #8]
 800127e:	f8d0 a010 	ldr.w	sl, [r0, #16]
/*
 * SampleRate 500Hz, cutoff 200Hz, 4th order Butterworth
 * http://www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html
 */
void floatFilterGyro(floatFilter *value, int newValue)
{
 8001282:	4604      	mov	r4, r0
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001284:	6003      	str	r3, [r0, #0]
 8001286:	f8c0 9008 	str.w	r9, [r0, #8]
 800128a:	f8c0 a00c 	str.w	sl, [r0, #12]
 800128e:	f8c0 b004 	str.w	fp, [r0, #4]
	xv[4] = (float)newValue / 2.310287053e+00;
 8001292:	4608      	mov	r0, r1
 8001294:	9301      	str	r3, [sp, #4]
 8001296:	f006 fc0b 	bl	8007ab0 <__aeabi_i2f>
 800129a:	4929      	ldr	r1, [pc, #164]	; (8001340 <floatFilterGyro+0xd0>)
 800129c:	f006 fd10 	bl	8007cc0 <__aeabi_fdiv>
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 80012a0:	f8d4 8018 	ldr.w	r8, [r4, #24]
 80012a4:	69e7      	ldr	r7, [r4, #28]
 80012a6:	6a26      	ldr	r6, [r4, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 80012a8:	9b01      	ldr	r3, [sp, #4]
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 80012aa:	6a65      	ldr	r5, [r4, #36]	; 0x24
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
 80012ac:	4601      	mov	r1, r0
 80012ae:	6120      	str	r0, [r4, #16]
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 80012b0:	f8c4 8014 	str.w	r8, [r4, #20]
 80012b4:	61a7      	str	r7, [r4, #24]
 80012b6:	61e6      	str	r6, [r4, #28]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 80012b8:	4618      	mov	r0, r3
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 80012ba:	6225      	str	r5, [r4, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 80012bc:	f006 fb44 	bl	8007948 <__addsf3>
 80012c0:	4651      	mov	r1, sl
 80012c2:	4603      	mov	r3, r0
 80012c4:	4658      	mov	r0, fp
 80012c6:	9301      	str	r3, [sp, #4]
 80012c8:	f006 fb3e 	bl	8007948 <__addsf3>
 80012cc:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 80012d0:	f006 fc42 	bl	8007b58 <__aeabi_fmul>
 80012d4:	9b01      	ldr	r3, [sp, #4]
 80012d6:	4601      	mov	r1, r0
 80012d8:	4618      	mov	r0, r3
 80012da:	f006 fb35 	bl	8007948 <__addsf3>
 80012de:	4919      	ldr	r1, [pc, #100]	; (8001344 <floatFilterGyro+0xd4>)
 80012e0:	4682      	mov	sl, r0
 80012e2:	4648      	mov	r0, r9
 80012e4:	f006 fc38 	bl	8007b58 <__aeabi_fmul>
 80012e8:	4601      	mov	r1, r0
 80012ea:	4650      	mov	r0, sl
 80012ec:	f006 fb2c 	bl	8007948 <__addsf3>
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 80012f0:	4915      	ldr	r1, [pc, #84]	; (8001348 <floatFilterGyro+0xd8>)
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 80012f2:	4681      	mov	r9, r0
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 80012f4:	4640      	mov	r0, r8
 80012f6:	f006 fc2f 	bl	8007b58 <__aeabi_fmul>
 80012fa:	4601      	mov	r1, r0
 80012fc:	4648      	mov	r0, r9
 80012fe:	f006 fb23 	bl	8007948 <__addsf3>
 8001302:	4912      	ldr	r1, [pc, #72]	; (800134c <floatFilterGyro+0xdc>)
 8001304:	4680      	mov	r8, r0
 8001306:	4638      	mov	r0, r7
 8001308:	f006 fc26 	bl	8007b58 <__aeabi_fmul>
 800130c:	4601      	mov	r1, r0
 800130e:	4640      	mov	r0, r8
 8001310:	f006 fb1a 	bl	8007948 <__addsf3>
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
 8001314:	490e      	ldr	r1, [pc, #56]	; (8001350 <floatFilterGyro+0xe0>)

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 8001316:	4607      	mov	r7, r0
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
 8001318:	4630      	mov	r0, r6
 800131a:	f006 fc1d 	bl	8007b58 <__aeabi_fmul>
 800131e:	4601      	mov	r1, r0
 8001320:	4638      	mov	r0, r7
 8001322:	f006 fb11 	bl	8007948 <__addsf3>
 8001326:	490b      	ldr	r1, [pc, #44]	; (8001354 <floatFilterGyro+0xe4>)
 8001328:	4606      	mov	r6, r0
 800132a:	4628      	mov	r0, r5
 800132c:	f006 fc14 	bl	8007b58 <__aeabi_fmul>
 8001330:	4601      	mov	r1, r0
 8001332:	4630      	mov	r0, r6
 8001334:	f006 fb08 	bl	8007948 <__addsf3>
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001338:	6260      	str	r0, [r4, #36]	; 0x24
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
	value->currentValue = yv[4];
 800133a:	62a0      	str	r0, [r4, #40]	; 0x28
}
 800133c:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001340:	4013dbbe 	.word	0x4013dbbe
 8001344:	40c00000 	.word	0x40c00000
 8001348:	be3fe069 	.word	0xbe3fe069
 800134c:	bf86ff47 	.word	0xbf86ff47
 8001350:	c0141863 	.word	0xc0141863
 8001354:	c017a61a 	.word	0xc017a61a

08001358 <Delay>:
#include <helperFunctions.h>


void Delay(volatile uint32_t delayCount)
{
 8001358:	b082      	sub	sp, #8
 800135a:	9001      	str	r0, [sp, #4]
	while (delayCount > 0)
 800135c:	e002      	b.n	8001364 <Delay+0xc>
	{
		delayCount--;
 800135e:	9b01      	ldr	r3, [sp, #4]
 8001360:	3b01      	subs	r3, #1
 8001362:	9301      	str	r3, [sp, #4]
#include <helperFunctions.h>


void Delay(volatile uint32_t delayCount)
{
	while (delayCount > 0)
 8001364:	9b01      	ldr	r3, [sp, #4]
 8001366:	2b00      	cmp	r3, #0
 8001368:	d1f9      	bne.n	800135e <Delay+0x6>
	{
		delayCount--;
	}
}
 800136a:	b002      	add	sp, #8
 800136c:	4770      	bx	lr
	...

08001370 <IMU_Print_Values>:
}


/*For debug purposes - the print task*/
static void IMU_Print_Values( void *pvParameters )
{
 8001370:	b510      	push	{r4, lr}

	while(1)
	{
		//printf("%d,%d,%d,%d %d  ",CtrlStates.gas, CtrlStates.nick, CtrlStates.roll, CtrlStates.yaw, CtrlStates.copterStatus);
		//printf("%d,%d,%d\n",(int)XYZ.y, (int)XYZ.x, (int)XYZ.z);
		printf("test:%d,%d,%d\r\n", (int)(xTemp), (int)(yTemp), (int)(zTemp));
 8001372:	4c05      	ldr	r4, [pc, #20]	; (8001388 <IMU_Print_Values+0x18>)
 8001374:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
 8001378:	4804      	ldr	r0, [pc, #16]	; (800138c <IMU_Print_Values+0x1c>)
 800137a:	f000 ff59 	bl	8002230 <printf>
		vTaskDelay( xDelay );
 800137e:	2028      	movs	r0, #40	; 0x28
 8001380:	f005 fc78 	bl	8006c74 <vTaskDelay>
 8001384:	e7f6      	b.n	8001374 <IMU_Print_Values+0x4>
 8001386:	bf00      	nop
 8001388:	20000148 	.word	0x20000148
 800138c:	0800aca0 	.word	0x0800aca0

08001390 <PID_Calculation>:
/*
 *		PID Calculation - this is far from being finished
 * */

static void PID_Calculation( void *pvParameters )
{
 8001390:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001394:	b0b1      	sub	sp, #196	; 0xc4
	PID_Control PID_Y1;
	PID_Control PID_Y2;

	PID_Control PID_Z;

	init_PID(0.003f, GlobalSettings.PID_rollPitch.PID_kp, GlobalSettings.PID_rollPitch.PID_ki, GlobalSettings.PID_rollPitch.PID_kd, &PID_X1);
 8001396:	4d98      	ldr	r5, [pc, #608]	; (80015f8 <PID_Calculation+0x268>)
 8001398:	ab08      	add	r3, sp, #32
 800139a:	9300      	str	r3, [sp, #0]
 800139c:	4897      	ldr	r0, [pc, #604]	; (80015fc <PID_Calculation+0x26c>)
 800139e:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 80013a0:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80013a2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013a4:	f7ff fcd0 	bl	8000d48 <init_PID>
	init_PID(0.003f, GlobalSettings.PID_rollPitch.PID_kp, GlobalSettings.PID_rollPitch.PID_ki, GlobalSettings.PID_rollPitch.PID_kd, &PID_X2);
 80013a8:	ab10      	add	r3, sp, #64	; 0x40
 80013aa:	9300      	str	r3, [sp, #0]
 80013ac:	4893      	ldr	r0, [pc, #588]	; (80015fc <PID_Calculation+0x26c>)
 80013ae:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 80013b0:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80013b2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013b4:	f7ff fcc8 	bl	8000d48 <init_PID>
	init_PID(0.003f, GlobalSettings.PID_rollPitch.PID_kp, GlobalSettings.PID_rollPitch.PID_ki, GlobalSettings.PID_rollPitch.PID_kd, &PID_Y1);
 80013b8:	ab18      	add	r3, sp, #96	; 0x60
 80013ba:	9300      	str	r3, [sp, #0]
 80013bc:	488f      	ldr	r0, [pc, #572]	; (80015fc <PID_Calculation+0x26c>)
 80013be:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 80013c0:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80013c2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013c4:	f7ff fcc0 	bl	8000d48 <init_PID>
	init_PID(0.003f, GlobalSettings.PID_rollPitch.PID_kp, GlobalSettings.PID_rollPitch.PID_ki, GlobalSettings.PID_rollPitch.PID_kd, &PID_Y2);
 80013c8:	ab20      	add	r3, sp, #128	; 0x80
 80013ca:	9300      	str	r3, [sp, #0]
 80013cc:	488b      	ldr	r0, [pc, #556]	; (80015fc <PID_Calculation+0x26c>)
 80013ce:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 80013d0:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80013d2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013d4:	f7ff fcb8 	bl	8000d48 <init_PID>
	init_PID(0.003f, GlobalSettings.PID_yaw.PID_kp, GlobalSettings.PID_yaw.PID_ki, GlobalSettings.PID_yaw.PID_kd, &PID_Z);
 80013d8:	ab28      	add	r3, sp, #160	; 0xa0
 80013da:	9300      	str	r3, [sp, #0]
 80013dc:	4887      	ldr	r0, [pc, #540]	; (80015fc <PID_Calculation+0x26c>)
 80013de:	6b69      	ldr	r1, [r5, #52]	; 0x34
 80013e0:	6baa      	ldr	r2, [r5, #56]	; 0x38
 80013e2:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80013e4:	f7ff fcb0 	bl	8000d48 <init_PID>
	float MOT0 = 0;
	float MOT1 = 0;
	float MOT2 = 0;
	float MOT3 = 0;
	float MOT4 = 0;
	float MOT5 = 0;
 80013e8:	2400      	movs	r4, #0
	const portTickType xDelay = 3 / portTICK_RATE_MS;

	float MOT0 = 0;
	float MOT1 = 0;
	float MOT2 = 0;
	float MOT3 = 0;
 80013ea:	4627      	mov	r7, r4
static void PID_Calculation( void *pvParameters )
{
	const portTickType xDelay = 3 / portTICK_RATE_MS;

	float MOT0 = 0;
	float MOT1 = 0;
 80013ec:	4626      	mov	r6, r4
			resetIntegralValues_PID(&PID_X2);
			resetIntegralValues_PID(&PID_Y1);
			resetIntegralValues_PID(&PID_Y2);
			resetIntegralValues_PID(&PID_Z);

			PWM_Motor(1, (uint16_t)GlobalSettings.stopSpeed);
 80013ee:	46ab      	mov	fp, r5
	init_PID(0.003f, GlobalSettings.PID_rollPitch.PID_kp, GlobalSettings.PID_rollPitch.PID_ki, GlobalSettings.PID_rollPitch.PID_kd, &PID_Y2);
	init_PID(0.003f, GlobalSettings.PID_yaw.PID_kp, GlobalSettings.PID_yaw.PID_ki, GlobalSettings.PID_yaw.PID_kd, &PID_Z);

	while(1)
	{
		if(CtrlStates.copterStatus & ARMED_FLAG )
 80013f0:	f8df 8214 	ldr.w	r8, [pc, #532]	; 8001608 <PID_Calculation+0x278>
 80013f4:	f898 0008 	ldrb.w	r0, [r8, #8]
 80013f8:	f010 0501 	ands.w	r5, r0, #1
 80013fc:	f000 8135 	beq.w	800166a <PID_Calculation+0x2da>
			MOT2 = GlobalSettings.minSpeed + CtrlStates.gas - PID_X2.y + PID_X1.y - PID_Z.y;
			MOT1 = GlobalSettings.minSpeed + CtrlStates.gas + PID_Y1.y + PID_Y2.y + PID_Z.y;
			MOT3 = GlobalSettings.minSpeed + CtrlStates.gas - PID_Y1.y - PID_Y2.y + PID_Z.y;
			#endif
			#ifdef HEXA
			calc_PID_YAW(XYZ.z, CtrlStates.yaw, &PID_Z);
 8001400:	f9b8 0006 	ldrsh.w	r0, [r8, #6]
 8001404:	f006 fb54 	bl	8007ab0 <__aeabi_i2f>
 8001408:	4c7d      	ldr	r4, [pc, #500]	; (8001600 <PID_Calculation+0x270>)
 800140a:	4601      	mov	r1, r0
 800140c:	aa28      	add	r2, sp, #160	; 0xa0
 800140e:	68a0      	ldr	r0, [r4, #8]
 8001410:	f7ff fcd6 	bl	8000dc0 <calc_PID_YAW>
//			#define MAXPIDZ 50
//			if(PID_Z.y > MAXPIDZ) PID_Z.y = MAXPIDZ;
//			if(PID_Z.y < -MAXPIDZ) PID_Z.y = -MAXPIDZ;

			//PID-Regler
			calc_PID(XYZ.y, -CtrlStates.nick, &PID_X1);
 8001414:	f9b8 0004 	ldrsh.w	r0, [r8, #4]
 8001418:	4240      	negs	r0, r0
 800141a:	f006 fb49 	bl	8007ab0 <__aeabi_i2f>
 800141e:	aa08      	add	r2, sp, #32
 8001420:	4601      	mov	r1, r0
 8001422:	6860      	ldr	r0, [r4, #4]
 8001424:	f7ff fc9c 	bl	8000d60 <calc_PID>
			calc_PID(XYZ.x, CtrlStates.roll, &PID_X2);
 8001428:	f9b8 0002 	ldrsh.w	r0, [r8, #2]
 800142c:	f006 fb40 	bl	8007ab0 <__aeabi_i2f>
 8001430:	aa10      	add	r2, sp, #64	; 0x40
 8001432:	4601      	mov	r1, r0
 8001434:	6820      	ldr	r0, [r4, #0]
 8001436:	f7ff fc93 	bl	8000d60 <calc_PID>
			calc_PID(XYZ.y, -CtrlStates.nick, &PID_Y1);
 800143a:	f9b8 0004 	ldrsh.w	r0, [r8, #4]
 800143e:	4240      	negs	r0, r0
 8001440:	f006 fb36 	bl	8007ab0 <__aeabi_i2f>
 8001444:	aa18      	add	r2, sp, #96	; 0x60
 8001446:	4601      	mov	r1, r0
 8001448:	6860      	ldr	r0, [r4, #4]
 800144a:	f7ff fc89 	bl	8000d60 <calc_PID>
			calc_PID(XYZ.x, CtrlStates.roll, &PID_Y2);
 800144e:	f9b8 0002 	ldrsh.w	r0, [r8, #2]
 8001452:	f006 fb2d 	bl	8007ab0 <__aeabi_i2f>
 8001456:	aa20      	add	r2, sp, #128	; 0x80
 8001458:	4601      	mov	r1, r0
 800145a:	6820      	ldr	r0, [r4, #0]
 800145c:	f7ff fc80 	bl	8000d60 <calc_PID>

			MOT0 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X1.y + PID_Z.y;
 8001460:	f8bb 5024 	ldrh.w	r5, [fp, #36]	; 0x24
 8001464:	f9b8 0000 	ldrsh.w	r0, [r8]
 8001468:	1828      	adds	r0, r5, r0
 800146a:	f006 fb21 	bl	8007ab0 <__aeabi_i2f>
 800146e:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8001470:	9c29      	ldr	r4, [sp, #164]	; 0xa4
 8001472:	4631      	mov	r1, r6
 8001474:	4680      	mov	r8, r0
 8001476:	f006 fa67 	bl	8007948 <__addsf3>
 800147a:	4621      	mov	r1, r4
 800147c:	f006 fa64 	bl	8007948 <__addsf3>
			MOT2 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
 8001480:	4960      	ldr	r1, [pc, #384]	; (8001604 <PID_Calculation+0x274>)
			calc_PID(XYZ.y, -CtrlStates.nick, &PID_X1);
			calc_PID(XYZ.x, CtrlStates.roll, &PID_X2);
			calc_PID(XYZ.y, -CtrlStates.nick, &PID_Y1);
			calc_PID(XYZ.x, CtrlStates.roll, &PID_Y2);

			MOT0 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X1.y + PID_Z.y;
 8001482:	9005      	str	r0, [sp, #20]
			MOT2 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
 8001484:	4630      	mov	r0, r6
 8001486:	f006 fb67 	bl	8007b58 <__aeabi_fmul>
 800148a:	f8dd a044 	ldr.w	sl, [sp, #68]	; 0x44
 800148e:	4681      	mov	r9, r0
 8001490:	4651      	mov	r1, sl
 8001492:	4640      	mov	r0, r8
 8001494:	f006 fa58 	bl	8007948 <__addsf3>
 8001498:	4649      	mov	r1, r9
 800149a:	f006 fa53 	bl	8007944 <__aeabi_fsub>
 800149e:	4621      	mov	r1, r4
 80014a0:	f006 fa52 	bl	8007948 <__addsf3>
			MOT1 = GlobalSettings.minSpeed + CtrlStates.gas + (0.7*PID_Y1.y) + PID_Y2.y - PID_Z.y;
 80014a4:	9f19      	ldr	r7, [sp, #100]	; 0x64
			calc_PID(XYZ.x, CtrlStates.roll, &PID_X2);
			calc_PID(XYZ.y, -CtrlStates.nick, &PID_Y1);
			calc_PID(XYZ.x, CtrlStates.roll, &PID_Y2);

			MOT0 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X1.y + PID_Z.y;
			MOT2 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
 80014a6:	9006      	str	r0, [sp, #24]
			MOT1 = GlobalSettings.minSpeed + CtrlStates.gas + (0.7*PID_Y1.y) + PID_Y2.y - PID_Z.y;
 80014a8:	4956      	ldr	r1, [pc, #344]	; (8001604 <PID_Calculation+0x274>)
 80014aa:	4638      	mov	r0, r7
 80014ac:	f006 fb54 	bl	8007b58 <__aeabi_fmul>
 80014b0:	4601      	mov	r1, r0
 80014b2:	4640      	mov	r0, r8
 80014b4:	f006 fa48 	bl	8007948 <__addsf3>
 80014b8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80014ba:	9003      	str	r0, [sp, #12]
 80014bc:	4619      	mov	r1, r3
 80014be:	9304      	str	r3, [sp, #16]
 80014c0:	f006 fa42 	bl	8007948 <__addsf3>
 80014c4:	4621      	mov	r1, r4
 80014c6:	f006 fa3d 	bl	8007944 <__aeabi_fsub>
			MOT3 = GlobalSettings.minSpeed + CtrlStates.gas - PID_Y1.y - PID_Z.y;
 80014ca:	4639      	mov	r1, r7
			calc_PID(XYZ.y, -CtrlStates.nick, &PID_Y1);
			calc_PID(XYZ.x, CtrlStates.roll, &PID_Y2);

			MOT0 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X1.y + PID_Z.y;
			MOT2 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
			MOT1 = GlobalSettings.minSpeed + CtrlStates.gas + (0.7*PID_Y1.y) + PID_Y2.y - PID_Z.y;
 80014cc:	4606      	mov	r6, r0
			MOT3 = GlobalSettings.minSpeed + CtrlStates.gas - PID_Y1.y - PID_Z.y;
 80014ce:	4640      	mov	r0, r8
 80014d0:	f006 fa38 	bl	8007944 <__aeabi_fsub>
 80014d4:	4621      	mov	r1, r4
 80014d6:	f006 fa35 	bl	8007944 <__aeabi_fsub>
			MOT4 = GlobalSettings.minSpeed + CtrlStates.gas - PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
 80014da:	4651      	mov	r1, sl
			calc_PID(XYZ.x, CtrlStates.roll, &PID_Y2);

			MOT0 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X1.y + PID_Z.y;
			MOT2 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
			MOT1 = GlobalSettings.minSpeed + CtrlStates.gas + (0.7*PID_Y1.y) + PID_Y2.y - PID_Z.y;
			MOT3 = GlobalSettings.minSpeed + CtrlStates.gas - PID_Y1.y - PID_Z.y;
 80014dc:	4607      	mov	r7, r0
			MOT4 = GlobalSettings.minSpeed + CtrlStates.gas - PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
 80014de:	4640      	mov	r0, r8
 80014e0:	f006 fa30 	bl	8007944 <__aeabi_fsub>
 80014e4:	4649      	mov	r1, r9
 80014e6:	f006 fa2d 	bl	8007944 <__aeabi_fsub>
 80014ea:	4621      	mov	r1, r4
 80014ec:	f006 fa2c 	bl	8007948 <__addsf3>
			MOT5 = GlobalSettings.minSpeed + CtrlStates.gas + (0.7*PID_Y1.y) - PID_Y2.y - PID_Z.y;
 80014f0:	9a03      	ldr	r2, [sp, #12]
 80014f2:	9b04      	ldr	r3, [sp, #16]

			MOT0 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X1.y + PID_Z.y;
			MOT2 = GlobalSettings.minSpeed + CtrlStates.gas + PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
			MOT1 = GlobalSettings.minSpeed + CtrlStates.gas + (0.7*PID_Y1.y) + PID_Y2.y - PID_Z.y;
			MOT3 = GlobalSettings.minSpeed + CtrlStates.gas - PID_Y1.y - PID_Z.y;
			MOT4 = GlobalSettings.minSpeed + CtrlStates.gas - PID_X2.y - (0.7*PID_X1.y) + PID_Z.y;
 80014f4:	9007      	str	r0, [sp, #28]
			MOT5 = GlobalSettings.minSpeed + CtrlStates.gas + (0.7*PID_Y1.y) - PID_Y2.y - PID_Z.y;
 80014f6:	4619      	mov	r1, r3
 80014f8:	4610      	mov	r0, r2
 80014fa:	f006 fa23 	bl	8007944 <__aeabi_fsub>
 80014fe:	4621      	mov	r1, r4
 8001500:	f006 fa20 	bl	8007944 <__aeabi_fsub>
 8001504:	4604      	mov	r4, r0
			#endif

			if(MOT1 < GlobalSettings.minSpeed) MOT1 = GlobalSettings.minSpeed;
 8001506:	4628      	mov	r0, r5
 8001508:	f006 fad2 	bl	8007ab0 <__aeabi_i2f>
 800150c:	4682      	mov	sl, r0
 800150e:	4651      	mov	r1, sl
 8001510:	4630      	mov	r0, r6
 8001512:	f006 fcbf 	bl	8007e94 <__aeabi_fcmplt>
 8001516:	b118      	cbz	r0, 8001520 <PID_Calculation+0x190>
 8001518:	4628      	mov	r0, r5
 800151a:	f006 fac5 	bl	8007aa8 <__aeabi_ui2f>
 800151e:	4606      	mov	r6, r0
			if(MOT1 > GlobalSettings.maxSpeed) MOT1 = GlobalSettings.maxSpeed;
 8001520:	4b35      	ldr	r3, [pc, #212]	; (80015f8 <PID_Calculation+0x268>)
 8001522:	f8b3 8026 	ldrh.w	r8, [r3, #38]	; 0x26
 8001526:	4640      	mov	r0, r8
 8001528:	f006 fac2 	bl	8007ab0 <__aeabi_i2f>
 800152c:	4681      	mov	r9, r0
 800152e:	4649      	mov	r1, r9
 8001530:	4630      	mov	r0, r6
 8001532:	f006 fccd 	bl	8007ed0 <__aeabi_fcmpgt>
 8001536:	b118      	cbz	r0, 8001540 <PID_Calculation+0x1b0>
 8001538:	4640      	mov	r0, r8
 800153a:	f006 fab5 	bl	8007aa8 <__aeabi_ui2f>
 800153e:	4606      	mov	r6, r0

			if(MOT3 < GlobalSettings.minSpeed) MOT3 = GlobalSettings.minSpeed;
 8001540:	4638      	mov	r0, r7
 8001542:	4651      	mov	r1, sl
 8001544:	f006 fca6 	bl	8007e94 <__aeabi_fcmplt>
 8001548:	b118      	cbz	r0, 8001552 <PID_Calculation+0x1c2>
 800154a:	4628      	mov	r0, r5
 800154c:	f006 faac 	bl	8007aa8 <__aeabi_ui2f>
 8001550:	4607      	mov	r7, r0
			if(MOT3 > GlobalSettings.maxSpeed) MOT3 = GlobalSettings.maxSpeed;
 8001552:	4638      	mov	r0, r7
 8001554:	4649      	mov	r1, r9
 8001556:	f006 fcbb 	bl	8007ed0 <__aeabi_fcmpgt>
 800155a:	b118      	cbz	r0, 8001564 <PID_Calculation+0x1d4>
 800155c:	4640      	mov	r0, r8
 800155e:	f006 faa3 	bl	8007aa8 <__aeabi_ui2f>
 8001562:	4607      	mov	r7, r0

			if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
 8001564:	9805      	ldr	r0, [sp, #20]
 8001566:	4651      	mov	r1, sl
 8001568:	f006 fc94 	bl	8007e94 <__aeabi_fcmplt>
 800156c:	b118      	cbz	r0, 8001576 <PID_Calculation+0x1e6>
 800156e:	4628      	mov	r0, r5
 8001570:	f006 fa9a 	bl	8007aa8 <__aeabi_ui2f>
 8001574:	9005      	str	r0, [sp, #20]
			if(MOT0 > GlobalSettings.maxSpeed) MOT0 = GlobalSettings.maxSpeed;
 8001576:	9805      	ldr	r0, [sp, #20]
 8001578:	4649      	mov	r1, r9
 800157a:	f006 fca9 	bl	8007ed0 <__aeabi_fcmpgt>
 800157e:	b118      	cbz	r0, 8001588 <PID_Calculation+0x1f8>
 8001580:	4640      	mov	r0, r8
 8001582:	f006 fa91 	bl	8007aa8 <__aeabi_ui2f>
 8001586:	9005      	str	r0, [sp, #20]

			if(MOT2 < GlobalSettings.minSpeed) MOT2 = GlobalSettings.minSpeed;
 8001588:	9806      	ldr	r0, [sp, #24]
 800158a:	4651      	mov	r1, sl
 800158c:	f006 fc82 	bl	8007e94 <__aeabi_fcmplt>
 8001590:	b118      	cbz	r0, 800159a <PID_Calculation+0x20a>
 8001592:	4628      	mov	r0, r5
 8001594:	f006 fa88 	bl	8007aa8 <__aeabi_ui2f>
 8001598:	9006      	str	r0, [sp, #24]
			if(MOT2 > GlobalSettings.maxSpeed) MOT2 = GlobalSettings.maxSpeed;
 800159a:	9806      	ldr	r0, [sp, #24]
 800159c:	4649      	mov	r1, r9
 800159e:	f006 fc97 	bl	8007ed0 <__aeabi_fcmpgt>
 80015a2:	b118      	cbz	r0, 80015ac <PID_Calculation+0x21c>
 80015a4:	4640      	mov	r0, r8
 80015a6:	f006 fa7f 	bl	8007aa8 <__aeabi_ui2f>
 80015aa:	9006      	str	r0, [sp, #24]

			#ifdef HEXA
			if(MOT4 < GlobalSettings.minSpeed) MOT4 = GlobalSettings.minSpeed;
 80015ac:	9807      	ldr	r0, [sp, #28]
 80015ae:	4651      	mov	r1, sl
 80015b0:	f006 fc70 	bl	8007e94 <__aeabi_fcmplt>
 80015b4:	b118      	cbz	r0, 80015be <PID_Calculation+0x22e>
 80015b6:	4628      	mov	r0, r5
 80015b8:	f006 fa76 	bl	8007aa8 <__aeabi_ui2f>
 80015bc:	9007      	str	r0, [sp, #28]
			if(MOT4 > GlobalSettings.maxSpeed) MOT4 = GlobalSettings.maxSpeed;
 80015be:	9807      	ldr	r0, [sp, #28]
 80015c0:	4649      	mov	r1, r9
 80015c2:	f006 fc85 	bl	8007ed0 <__aeabi_fcmpgt>
 80015c6:	b118      	cbz	r0, 80015d0 <PID_Calculation+0x240>
 80015c8:	4640      	mov	r0, r8
 80015ca:	f006 fa6d 	bl	8007aa8 <__aeabi_ui2f>
 80015ce:	9007      	str	r0, [sp, #28]

			if(MOT5 < GlobalSettings.minSpeed) MOT5 = GlobalSettings.minSpeed;
 80015d0:	4620      	mov	r0, r4
 80015d2:	4651      	mov	r1, sl
 80015d4:	f006 fc5e 	bl	8007e94 <__aeabi_fcmplt>
 80015d8:	b118      	cbz	r0, 80015e2 <PID_Calculation+0x252>
 80015da:	4628      	mov	r0, r5
 80015dc:	f006 fa64 	bl	8007aa8 <__aeabi_ui2f>
 80015e0:	4604      	mov	r4, r0
			if(MOT5 > GlobalSettings.maxSpeed) MOT5 = GlobalSettings.maxSpeed;
 80015e2:	4620      	mov	r0, r4
 80015e4:	4649      	mov	r1, r9
 80015e6:	f006 fc73 	bl	8007ed0 <__aeabi_fcmpgt>
 80015ea:	b178      	cbz	r0, 800160c <PID_Calculation+0x27c>
 80015ec:	4640      	mov	r0, r8
 80015ee:	f006 fa5b 	bl	8007aa8 <__aeabi_ui2f>
 80015f2:	4604      	mov	r4, r0
 80015f4:	e00a      	b.n	800160c <PID_Calculation+0x27c>
 80015f6:	bf00      	nop
 80015f8:	20002b88 	.word	0x20002b88
 80015fc:	3b449ba6 	.word	0x3b449ba6
 8001600:	20002b7c 	.word	0x20002b7c
 8001604:	3f333333 	.word	0x3f333333
 8001608:	20002bc8 	.word	0x20002bc8
			#endif

			taskENTER_CRITICAL();
 800160c:	f004 fa88 	bl	8005b20 <vPortEnterCritical>
			#endif /*enableY_AXIS*/
		#endif
		#ifdef HEXA
			#ifdef enableX_AXIS
			//PWM_Motor(3, (uint16_t)MOT2);
			PWM_Motor(0, (uint16_t)MOT0);
 8001610:	9805      	ldr	r0, [sp, #20]
 8001612:	f006 fc8d 	bl	8007f30 <__aeabi_f2uiz>
 8001616:	b281      	uxth	r1, r0
 8001618:	2000      	movs	r0, #0
 800161a:	f7ff fb79 	bl	8000d10 <PWM_Motor>
			PWM_Motor(2, (uint16_t)MOT2);
 800161e:	9806      	ldr	r0, [sp, #24]
 8001620:	f006 fc86 	bl	8007f30 <__aeabi_f2uiz>
 8001624:	b281      	uxth	r1, r0
 8001626:	2002      	movs	r0, #2
 8001628:	f7ff fb72 	bl	8000d10 <PWM_Motor>
			PWM_Motor(4, (uint16_t)MOT4);
 800162c:	9807      	ldr	r0, [sp, #28]
 800162e:	f006 fc7f 	bl	8007f30 <__aeabi_f2uiz>
 8001632:	b281      	uxth	r1, r0
 8001634:	2004      	movs	r0, #4
 8001636:	f7ff fb6b 	bl	8000d10 <PWM_Motor>
			#endif /*enableX_AXIS*/
			#ifdef enableY_AXIS
			PWM_Motor(5, (uint16_t)MOT5);
 800163a:	4620      	mov	r0, r4
 800163c:	f006 fc78 	bl	8007f30 <__aeabi_f2uiz>
 8001640:	b281      	uxth	r1, r0
 8001642:	2005      	movs	r0, #5
 8001644:	f7ff fb64 	bl	8000d10 <PWM_Motor>
			PWM_Motor(3, (uint16_t)MOT3);
 8001648:	4638      	mov	r0, r7
 800164a:	f006 fc71 	bl	8007f30 <__aeabi_f2uiz>
 800164e:	b281      	uxth	r1, r0
 8001650:	2003      	movs	r0, #3
 8001652:	f7ff fb5d 	bl	8000d10 <PWM_Motor>
			PWM_Motor(1, (uint16_t)MOT1);
 8001656:	4630      	mov	r0, r6
 8001658:	f006 fc6a 	bl	8007f30 <__aeabi_f2uiz>
 800165c:	b281      	uxth	r1, r0
 800165e:	2001      	movs	r0, #1
 8001660:	f7ff fb56 	bl	8000d10 <PWM_Motor>
			#endif /*enableY_AXIS*/
		#endif

			taskEXIT_CRITICAL();
 8001664:	f004 fa6d 	bl	8005b42 <vPortExitCritical>
 8001668:	e02c      	b.n	80016c4 <PID_Calculation+0x334>
			//printf("%d,%d,%d,%d\n\r", (uint16_t)MOT1, (uint16_t)MOT2, (uint16_t)MOT3, (uint16_t)MOT4);
			#endif
		}
		else
		{
			resetIntegralValues_PID(&PID_X1);
 800166a:	a808      	add	r0, sp, #32
 800166c:	f7ff fb73 	bl	8000d56 <resetIntegralValues_PID>
			resetIntegralValues_PID(&PID_X2);
 8001670:	a810      	add	r0, sp, #64	; 0x40
 8001672:	f7ff fb70 	bl	8000d56 <resetIntegralValues_PID>
			resetIntegralValues_PID(&PID_Y1);
 8001676:	a818      	add	r0, sp, #96	; 0x60
 8001678:	f7ff fb6d 	bl	8000d56 <resetIntegralValues_PID>
			resetIntegralValues_PID(&PID_Y2);
 800167c:	a820      	add	r0, sp, #128	; 0x80
 800167e:	f7ff fb6a 	bl	8000d56 <resetIntegralValues_PID>
			resetIntegralValues_PID(&PID_Z);
 8001682:	a828      	add	r0, sp, #160	; 0xa0
 8001684:	f7ff fb67 	bl	8000d56 <resetIntegralValues_PID>

			PWM_Motor(1, (uint16_t)GlobalSettings.stopSpeed);
 8001688:	2001      	movs	r0, #1
 800168a:	f8bb 1022 	ldrh.w	r1, [fp, #34]	; 0x22
 800168e:	f7ff fb3f 	bl	8000d10 <PWM_Motor>
			PWM_Motor(3, (uint16_t)GlobalSettings.stopSpeed);
 8001692:	2003      	movs	r0, #3
 8001694:	f8bb 1022 	ldrh.w	r1, [fp, #34]	; 0x22
 8001698:	f7ff fb3a 	bl	8000d10 <PWM_Motor>
			PWM_Motor(0, (uint16_t)GlobalSettings.stopSpeed);
 800169c:	4628      	mov	r0, r5
 800169e:	f8bb 1022 	ldrh.w	r1, [fp, #34]	; 0x22
 80016a2:	f7ff fb35 	bl	8000d10 <PWM_Motor>
			PWM_Motor(2, (uint16_t)GlobalSettings.stopSpeed);
 80016a6:	2002      	movs	r0, #2
 80016a8:	f8bb 1022 	ldrh.w	r1, [fp, #34]	; 0x22
 80016ac:	f7ff fb30 	bl	8000d10 <PWM_Motor>

			PWM_Motor(4, (uint16_t)GlobalSettings.stopSpeed);
 80016b0:	2004      	movs	r0, #4
 80016b2:	f8bb 1022 	ldrh.w	r1, [fp, #34]	; 0x22
 80016b6:	f7ff fb2b 	bl	8000d10 <PWM_Motor>
			PWM_Motor(5, (uint16_t)GlobalSettings.stopSpeed);
 80016ba:	2005      	movs	r0, #5
 80016bc:	f8bb 1022 	ldrh.w	r1, [fp, #34]	; 0x22
 80016c0:	f7ff fb26 	bl	8000d10 <PWM_Motor>

		/*
		 *  KeinePufferung
		 *  CtrlStates.gas, CtrlStates.nick, CtrlStates.roll,
		 */
		if (loopcnt >= 10) {
 80016c4:	4d17      	ldr	r5, [pc, #92]	; (8001724 <PID_Calculation+0x394>)
 80016c6:	68eb      	ldr	r3, [r5, #12]
 80016c8:	2b09      	cmp	r3, #9
 80016ca:	dd24      	ble.n	8001716 <PID_Calculation+0x386>
			uint32_t Header = 0xFF7F3F1F;
			InttoBuffer(&It_Com.txbuffer[0], Header); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
 80016cc:	4916      	ldr	r1, [pc, #88]	; (8001728 <PID_Calculation+0x398>)
 80016ce:	4817      	ldr	r0, [pc, #92]	; (800172c <PID_Calculation+0x39c>)
 80016d0:	f001 fbce 	bl	8002e70 <InttoBuffer>
			InttoBuffer(&It_Com.txbuffer[4], (uint16_t) MOT1);		//xTemp);
 80016d4:	4630      	mov	r0, r6
 80016d6:	f006 fc2b 	bl	8007f30 <__aeabi_f2uiz>
 80016da:	b281      	uxth	r1, r0
 80016dc:	4814      	ldr	r0, [pc, #80]	; (8001730 <PID_Calculation+0x3a0>)
 80016de:	f001 fbc7 	bl	8002e70 <InttoBuffer>
			InttoBuffer(&It_Com.txbuffer[8], (uint16_t) MOT3);		// yTemp);
 80016e2:	4638      	mov	r0, r7
 80016e4:	f006 fc24 	bl	8007f30 <__aeabi_f2uiz>
 80016e8:	b281      	uxth	r1, r0
 80016ea:	4812      	ldr	r0, [pc, #72]	; (8001734 <PID_Calculation+0x3a4>)
 80016ec:	f001 fbc0 	bl	8002e70 <InttoBuffer>
			InttoBuffer(&It_Com.txbuffer[12], (uint16_t) MOT5);		//zTemp);
 80016f0:	4620      	mov	r0, r4
 80016f2:	f006 fc1d 	bl	8007f30 <__aeabi_f2uiz>
 80016f6:	b281      	uxth	r1, r0
 80016f8:	480f      	ldr	r0, [pc, #60]	; (8001738 <PID_Calculation+0x3a8>)
 80016fa:	f001 fbb9 	bl	8002e70 <InttoBuffer>

			loopcnt = 0;
 80016fe:	2300      	movs	r3, #0
 8001700:	60eb      	str	r3, [r5, #12]
			It_Com.txlen = 16;
 8001702:	4b0e      	ldr	r3, [pc, #56]	; (800173c <PID_Calculation+0x3ac>)
 8001704:	2210      	movs	r2, #16
 8001706:	f8c3 2224 	str.w	r2, [r3, #548]	; 0x224
			USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
 800170a:	480d      	ldr	r0, [pc, #52]	; (8001740 <PID_Calculation+0x3b0>)
 800170c:	490d      	ldr	r1, [pc, #52]	; (8001744 <PID_Calculation+0x3b4>)
 800170e:	2201      	movs	r2, #1
 8001710:	f004 f936 	bl	8005980 <USART_ITConfig>
 8001714:	e001      	b.n	800171a <PID_Calculation+0x38a>
		} else {
			loopcnt++;
 8001716:	3301      	adds	r3, #1
 8001718:	60eb      	str	r3, [r5, #12]
		}




		vTaskDelay( xDelay );
 800171a:	2003      	movs	r0, #3
 800171c:	f005 faaa 	bl	8006c74 <vTaskDelay>
	}
 8001720:	e666      	b.n	80013f0 <PID_Calculation+0x60>
 8001722:	bf00      	nop
 8001724:	20000148 	.word	0x20000148
 8001728:	ff7f3f1f 	.word	0xff7f3f1f
 800172c:	20002ce5 	.word	0x20002ce5
 8001730:	20002ce9 	.word	0x20002ce9
 8001734:	20002ced 	.word	0x20002ced
 8001738:	20002cf1 	.word	0x20002cf1
 800173c:	20002bdc 	.word	0x20002bdc
 8001740:	40004800 	.word	0x40004800
 8001744:	00070107 	.word	0x00070107

08001748 <IMU_Calculation>:
	vTaskStartScheduler();
	while(1);
}

static void IMU_Calculation( void *pvParameters )
{
 8001748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint16_t i = 0;

	struct IMU_values IMU;

	/************ GYRO **************/
	struct gyroValues gyroOffset = {0,0,0};
 800174c:	2400      	movs	r4, #0
	vTaskStartScheduler();
	while(1);
}

static void IMU_Calculation( void *pvParameters )
{
 800174e:	b0f3      	sub	sp, #460	; 0x1cc
	struct gyroValues gyroXYZ = {0,0,0};

	floatFilter xGyroFiltered_float;
	floatFilter yGyroFiltered_float;
	floatFilter zGyroFiltered_float;
	memset(&xGyroFiltered_float, 0, sizeof(xGyroFiltered_float));
 8001750:	4621      	mov	r1, r4
 8001752:	222c      	movs	r2, #44	; 0x2c
 8001754:	a812      	add	r0, sp, #72	; 0x48
	uint16_t i = 0;

	struct IMU_values IMU;

	/************ GYRO **************/
	struct gyroValues gyroOffset = {0,0,0};
 8001756:	f8ad 4008 	strh.w	r4, [sp, #8]
 800175a:	f8ad 400a 	strh.w	r4, [sp, #10]
 800175e:	f8ad 400c 	strh.w	r4, [sp, #12]
	struct gyroValues gyroXYZ = {0,0,0};
 8001762:	f8ad 4010 	strh.w	r4, [sp, #16]
 8001766:	f8ad 4012 	strh.w	r4, [sp, #18]
 800176a:	f8ad 4014 	strh.w	r4, [sp, #20]

	floatFilter xGyroFiltered_float;
	floatFilter yGyroFiltered_float;
	floatFilter zGyroFiltered_float;
	memset(&xGyroFiltered_float, 0, sizeof(xGyroFiltered_float));
 800176e:	f006 fceb 	bl	8008148 <memset>
	memset(&yGyroFiltered_float, 0, sizeof(yGyroFiltered_float));
 8001772:	4621      	mov	r1, r4
 8001774:	222c      	movs	r2, #44	; 0x2c
 8001776:	a81d      	add	r0, sp, #116	; 0x74
 8001778:	f006 fce6 	bl	8008148 <memset>
	memset(&zGyroFiltered_float, 0, sizeof(zGyroFiltered_float));
 800177c:	4621      	mov	r1, r4
 800177e:	222c      	movs	r2, #44	; 0x2c
 8001780:	a828      	add	r0, sp, #160	; 0xa0
 8001782:	f006 fce1 	bl	8008148 <memset>

	/************ ACC ***************/
	struct accValues accXYZ = {0,0,0};
 8001786:	4621      	mov	r1, r4
 8001788:	220c      	movs	r2, #12
 800178a:	a80c      	add	r0, sp, #48	; 0x30
 800178c:	f006 fcdc 	bl	8008148 <memset>
	uint8_t accCount = 0;

	floatFilter xAccFiltered_float;
	floatFilter yAccFiltered_float;
	floatFilter zAccFiltered_float;
	memset(&xAccFiltered_float, 0, sizeof(xAccFiltered_float));
 8001790:	4621      	mov	r1, r4
 8001792:	222c      	movs	r2, #44	; 0x2c
 8001794:	a833      	add	r0, sp, #204	; 0xcc
 8001796:	f006 fcd7 	bl	8008148 <memset>
	memset(&yAccFiltered_float, 0, sizeof(yAccFiltered_float));
 800179a:	4621      	mov	r1, r4
 800179c:	222c      	movs	r2, #44	; 0x2c
 800179e:	a83e      	add	r0, sp, #248	; 0xf8
 80017a0:	f006 fcd2 	bl	8008148 <memset>
	memset(&zAccFiltered_float, 0, sizeof(zAccFiltered_float));
 80017a4:	4621      	mov	r1, r4
 80017a6:	222c      	movs	r2, #44	; 0x2c
 80017a8:	a849      	add	r0, sp, #292	; 0x124
 80017aa:	f006 fccd 	bl	8008148 <memset>
	intFilter xMagFiltered = {0,0};
	intFilter yMagFiltered = {0,0};


	/*Initialize the DCM-variables*/
	IMU_init(&IMU, DT_S);
 80017ae:	a854      	add	r0, sp, #336	; 0x150
 80017b0:	4965      	ldr	r1, [pc, #404]	; (8001948 <IMU_Calculation+0x200>)
	memset(&yAccFiltered_float, 0, sizeof(yAccFiltered_float));
	memset(&zAccFiltered_float, 0, sizeof(zAccFiltered_float));

	/************ MAG ***************/
	uint8_t magCount = 0;
	struct magValues magXYZ = {0,0,0};
 80017b2:	f8ad 4018 	strh.w	r4, [sp, #24]
 80017b6:	f8ad 401a 	strh.w	r4, [sp, #26]
 80017ba:	f8ad 401c 	strh.w	r4, [sp, #28]
	struct EULER_angles eulerTemp;
	intFilter xMagFiltered = {0,0};
 80017be:	9408      	str	r4, [sp, #32]
 80017c0:	9409      	str	r4, [sp, #36]	; 0x24
	intFilter yMagFiltered = {0,0};
 80017c2:	940a      	str	r4, [sp, #40]	; 0x28
 80017c4:	940b      	str	r4, [sp, #44]	; 0x2c


	/*Initialize the DCM-variables*/
	IMU_init(&IMU, DT_S);
 80017c6:	f7fe fcdf 	bl	8000188 <IMU_init>
	if(GlobalSettings.enableDriftCorrection)
 80017ca:	4b60      	ldr	r3, [pc, #384]	; (800194c <IMU_Calculation+0x204>)
 80017cc:	7a9b      	ldrb	r3, [r3, #10]
 80017ce:	b11b      	cbz	r3, 80017d8 <IMU_Calculation+0x90>
	{
		IMU_init_drift_correction(&IMU, 0.00020f/*kp-value*/);
 80017d0:	a854      	add	r0, sp, #336	; 0x150
 80017d2:	495f      	ldr	r1, [pc, #380]	; (8001950 <IMU_Calculation+0x208>)
 80017d4:	f7fe fce9 	bl	80001aa <IMU_init_drift_correction>
	/*
	 * Wait here 2 Seconds to ensure,
	 * that all capacitors are charged
	 * and VCC is stable
	 * */
	vTaskDelay( 2000 );
 80017d8:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80017dc:	f005 fa4a 	bl	8006c74 <vTaskDelay>
 80017e0:	2600      	movs	r6, #0

	while(1)
	{
		Gyro_calibrate(&gyroOffset);
 80017e2:	a802      	add	r0, sp, #8
 80017e4:	f7ff f829 	bl	800083a <Gyro_calibrate>
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 80017e8:	4d58      	ldr	r5, [pc, #352]	; (800194c <IMU_Calculation+0x204>)
	 * */
	vTaskDelay( 2000 );

	while(1)
	{
		Gyro_calibrate(&gyroOffset);
 80017ea:	f241 3788 	movw	r7, #5000	; 0x1388
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
 80017ee:	a804      	add	r0, sp, #16
 80017f0:	f7fe ffed 	bl	80007ce <Gyro_readValues>
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 80017f4:	f8bd 0010 	ldrh.w	r0, [sp, #16]
 80017f8:	f8bd 3008 	ldrh.w	r3, [sp, #8]
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 80017fc:	f8bd 2012 	ldrh.w	r2, [sp, #18]
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 8001800:	1ac0      	subs	r0, r0, r3
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001802:	f8bd 300a 	ldrh.w	r3, [sp, #10]
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 8001806:	f8ad 0010 	strh.w	r0, [sp, #16]
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 800180a:	1ad3      	subs	r3, r2, r3
 800180c:	f8ad 3012 	strh.w	r3, [sp, #18]
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001810:	f8bd 2014 	ldrh.w	r2, [sp, #20]
 8001814:	f8bd 300c 	ldrh.w	r3, [sp, #12]

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001818:	b200      	sxth	r0, r0
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 800181a:	1ad3      	subs	r3, r2, r3
 800181c:	f8ad 3014 	strh.w	r3, [sp, #20]

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001820:	f006 f946 	bl	8007ab0 <__aeabi_i2f>
 8001824:	494b      	ldr	r1, [pc, #300]	; (8001954 <IMU_Calculation+0x20c>)
 8001826:	f006 f997 	bl	8007b58 <__aeabi_fmul>
 800182a:	4947      	ldr	r1, [pc, #284]	; (8001948 <IMU_Calculation+0x200>)
 800182c:	f006 f994 	bl	8007b58 <__aeabi_fmul>
 8001830:	f895 9004 	ldrb.w	r9, [r5, #4]
 8001834:	a972      	add	r1, sp, #456	; 0x1c8
 8001836:	f109 090a 	add.w	r9, r9, #10
 800183a:	4680      	mov	r8, r0
 800183c:	eb01 0989 	add.w	r9, r1, r9, lsl #2
 8001840:	f859 0c78 	ldr.w	r0, [r9, #-120]
 8001844:	4641      	mov	r1, r8
 8001846:	f006 f87f 	bl	8007948 <__addsf3>
 800184a:	f849 0c78 	str.w	r0, [r9, #-120]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 800184e:	f895 9005 	ldrb.w	r9, [r5, #5]
 8001852:	aa72      	add	r2, sp, #456	; 0x1c8
 8001854:	f109 090a 	add.w	r9, r9, #10
 8001858:	eb02 0989 	add.w	r9, r2, r9, lsl #2
 800185c:	f859 0c78 	ldr.w	r0, [r9, #-120]
 8001860:	4641      	mov	r1, r8
 8001862:	f006 f871 	bl	8007948 <__addsf3>
 8001866:	f849 0c78 	str.w	r0, [r9, #-120]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 800186a:	f895 9006 	ldrb.w	r9, [r5, #6]
 800186e:	ab72      	add	r3, sp, #456	; 0x1c8
 8001870:	f109 090a 	add.w	r9, r9, #10
 8001874:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 8001878:	f859 0c78 	ldr.w	r0, [r9, #-120]
 800187c:	4641      	mov	r1, r8
 800187e:	f006 f863 	bl	8007948 <__addsf3>
 8001882:	3f01      	subs	r7, #1
 8001884:	b2bf      	uxth	r7, r7
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001886:	4c31      	ldr	r4, [pc, #196]	; (800194c <IMU_Calculation+0x204>)
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001888:	f849 0c78 	str.w	r0, [r9, #-120]
	vTaskDelay( 2000 );

	while(1)
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
 800188c:	2f00      	cmp	r7, #0
 800188e:	d1ae      	bne.n	80017ee <IMU_Calculation+0xa6>

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
		}
		vTaskDelayUntil( &xNextWakeTime, DT );
 8001890:	a801      	add	r0, sp, #4
 8001892:	2102      	movs	r1, #2
 8001894:	f005 fa08 	bl	8006ca8 <vTaskDelayUntil>

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
 8001898:	7927      	ldrb	r7, [r4, #4]
 800189a:	a972      	add	r1, sp, #456	; 0x1c8
 800189c:	f107 0a0a 	add.w	sl, r7, #10
 80018a0:	eb01 0a8a 	add.w	sl, r1, sl, lsl #2
 80018a4:	f85a 8c78 	ldr.w	r8, [sl, #-120]
 80018a8:	492b      	ldr	r1, [pc, #172]	; (8001958 <IMU_Calculation+0x210>)
 80018aa:	4640      	mov	r0, r8
 80018ac:	f006 fb10 	bl	8007ed0 <__aeabi_fcmpgt>
 80018b0:	2500      	movs	r5, #0
 80018b2:	2800      	cmp	r0, #0
 80018b4:	d033      	beq.n	800191e <IMU_Calculation+0x1d6>
 80018b6:	4640      	mov	r0, r8
 80018b8:	4928      	ldr	r1, [pc, #160]	; (800195c <IMU_Calculation+0x214>)
 80018ba:	f006 faeb 	bl	8007e94 <__aeabi_fcmplt>
 80018be:	b370      	cbz	r0, 800191e <IMU_Calculation+0x1d6>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 80018c0:	f894 9005 	ldrb.w	r9, [r4, #5]
 80018c4:	aa72      	add	r2, sp, #456	; 0x1c8
 80018c6:	f109 090a 	add.w	r9, r9, #10
 80018ca:	eb02 0989 	add.w	r9, r2, r9, lsl #2
 80018ce:	f859 8c78 	ldr.w	r8, [r9, #-120]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
		}
		vTaskDelayUntil( &xNextWakeTime, DT );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
 80018d2:	4921      	ldr	r1, [pc, #132]	; (8001958 <IMU_Calculation+0x210>)
 80018d4:	4640      	mov	r0, r8
 80018d6:	f006 fafb 	bl	8007ed0 <__aeabi_fcmpgt>
 80018da:	b300      	cbz	r0, 800191e <IMU_Calculation+0x1d6>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 80018dc:	4640      	mov	r0, r8
 80018de:	491f      	ldr	r1, [pc, #124]	; (800195c <IMU_Calculation+0x214>)
 80018e0:	f006 fad8 	bl	8007e94 <__aeabi_fcmplt>
 80018e4:	b1d8      	cbz	r0, 800191e <IMU_Calculation+0x1d6>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
 80018e6:	f894 8006 	ldrb.w	r8, [r4, #6]
 80018ea:	ab72      	add	r3, sp, #456	; 0x1c8
 80018ec:	f108 080a 	add.w	r8, r8, #10
 80018f0:	eb03 0888 	add.w	r8, r3, r8, lsl #2
 80018f4:	f858 bc78 	ldr.w	fp, [r8, #-120]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
		}
		vTaskDelayUntil( &xNextWakeTime, DT );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 80018f8:	4917      	ldr	r1, [pc, #92]	; (8001958 <IMU_Calculation+0x210>)
 80018fa:	4658      	mov	r0, fp
 80018fc:	f006 fae8 	bl	8007ed0 <__aeabi_fcmpgt>
 8001900:	b168      	cbz	r0, 800191e <IMU_Calculation+0x1d6>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
 8001902:	4658      	mov	r0, fp
 8001904:	4915      	ldr	r1, [pc, #84]	; (800195c <IMU_Calculation+0x214>)
 8001906:	f006 fac5 	bl	8007e94 <__aeabi_fcmplt>
 800190a:	b140      	cbz	r0, 800191e <IMU_Calculation+0x1d6>
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
		printf("Error Gyro Test!\n\r");
	}

	if(GlobalSettings.enableACC)
 800190c:	7ae3      	ldrb	r3, [r4, #11]

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
		{
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 800190e:	f84a 5c78 	str.w	r5, [sl, #-120]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 8001912:	f849 5c78 	str.w	r5, [r9, #-120]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 8001916:	f848 5c78 	str.w	r5, [r8, #-120]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
		printf("Error Gyro Test!\n\r");
	}

	if(GlobalSettings.enableACC)
 800191a:	b33b      	cbz	r3, 800196c <IMU_Calculation+0x224>
 800191c:	e022      	b.n	8001964 <IMU_Calculation+0x21c>
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 800191e:	4b0b      	ldr	r3, [pc, #44]	; (800194c <IMU_Calculation+0x204>)
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 8001920:	a972      	add	r1, sp, #456	; 0x1c8
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 8001922:	795a      	ldrb	r2, [r3, #5]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 8001924:	799b      	ldrb	r3, [r3, #6]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 8001926:	eb01 0787 	add.w	r7, r1, r7, lsl #2
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 800192a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 800192e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
		printf("Error Gyro Test!\n\r");
 8001932:	480b      	ldr	r0, [pc, #44]	; (8001960 <IMU_Calculation+0x218>)
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 8001934:	f847 6c50 	str.w	r6, [r7, #-80]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 8001938:	f842 6c50 	str.w	r6, [r2, #-80]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 800193c:	f843 6c50 	str.w	r6, [r3, #-80]
		printf("Error Gyro Test!\n\r");
 8001940:	f000 fc76 	bl	8002230 <printf>
	}
 8001944:	e74d      	b.n	80017e2 <IMU_Calculation+0x9a>
 8001946:	bf00      	nop
 8001948:	3b03126f 	.word	0x3b03126f
 800194c:	20002b88 	.word	0x20002b88
 8001950:	3951b717 	.word	0x3951b717
 8001954:	3d8f5c29 	.word	0x3d8f5c29
 8001958:	be19999a 	.word	0xbe19999a
 800195c:	3e19999a 	.word	0x3e19999a
 8001960:	0800acb0 	.word	0x0800acb0

	if(GlobalSettings.enableACC)
	{
		//ADXL345_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
		LSM303DLHC_ACC_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
 8001964:	6960      	ldr	r0, [r4, #20]
 8001966:	a90c      	add	r1, sp, #48	; 0x30
 8001968:	f7ff f8d4 	bl	8000b14 <LSM303DLHC_ACC_calibrate>
	}
	if(GlobalSettings.enableMAG)
 800196c:	4bb0      	ldr	r3, [pc, #704]	; (8001c30 <IMU_Calculation+0x4e8>)
 800196e:	7e1b      	ldrb	r3, [r3, #24]
 8001970:	2b00      	cmp	r3, #0
 8001972:	d03f      	beq.n	80019f4 <IMU_Calculation+0x2ac>
	{
		Mag_calibrate();
 8001974:	f7ff f92d 	bl	8000bd2 <Mag_calibrate>
		vTaskDelay( 200 );
 8001978:	20c8      	movs	r0, #200	; 0xc8
 800197a:	f005 f97b 	bl	8006c74 <vTaskDelay>
		Mag_readValues(&magXYZ);
 800197e:	a806      	add	r0, sp, #24
 8001980:	f7ff f943 	bl	8000c0a <Mag_readValues>
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
 8001984:	f9bd 0018 	ldrsh.w	r0, [sp, #24]
 8001988:	4240      	negs	r0, r0
 800198a:	f006 f891 	bl	8007ab0 <__aeabi_i2f>
 800198e:	f005 ff09 	bl	80077a4 <__aeabi_f2d>
 8001992:	4606      	mov	r6, r0
 8001994:	f9bd 001a 	ldrsh.w	r0, [sp, #26]
 8001998:	460f      	mov	r7, r1
 800199a:	f006 f889 	bl	8007ab0 <__aeabi_i2f>
 800199e:	f005 ff01 	bl	80077a4 <__aeabi_f2d>
 80019a2:	4602      	mov	r2, r0
 80019a4:	460b      	mov	r3, r1
 80019a6:	4630      	mov	r0, r6
 80019a8:	4639      	mov	r1, r7
 80019aa:	f006 fcd7 	bl	800835c <atan2>
 80019ae:	a39e      	add	r3, pc, #632	; (adr r3, 8001c28 <IMU_Calculation+0x4e0>)
 80019b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80019b4:	f005 fd96 	bl	80074e4 <__aeabi_dsub>
 80019b8:	f005 ff70 	bl	800789c <__aeabi_d2f>
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 80019bc:	499d      	ldr	r1, [pc, #628]	; (8001c34 <IMU_Calculation+0x4ec>)
	if(GlobalSettings.enableMAG)
	{
		Mag_calibrate();
		vTaskDelay( 200 );
		Mag_readValues(&magXYZ);
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
 80019be:	9011      	str	r0, [sp, #68]	; 0x44
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 80019c0:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80019c4:	f006 f8c8 	bl	8007b58 <__aeabi_fmul>
 80019c8:	f006 fa8c 	bl	8007ee4 <__aeabi_f2iz>
 80019cc:	4b9a      	ldr	r3, [pc, #616]	; (8001c38 <IMU_Calculation+0x4f0>)
		/* The yaw value needs a special handling */
		if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 80019ce:	b202      	sxth	r2, r0
 80019d0:	2ab4      	cmp	r2, #180	; 0xb4
	{
		Mag_calibrate();
		vTaskDelay( 200 );
		Mag_readValues(&magXYZ);
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 80019d2:	80d8      	strh	r0, [r3, #6]
		/* The yaw value needs a special handling */
		if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 80019d4:	bfc4      	itt	gt
 80019d6:	f5a0 70b4 	subgt.w	r0, r0, #360	; 0x168
 80019da:	80d8      	strhgt	r0, [r3, #6]
		if(CtrlStates.yaw < -180) CtrlStates.yaw += 360;
 80019dc:	88db      	ldrh	r3, [r3, #6]
 80019de:	b21a      	sxth	r2, r3
 80019e0:	32b4      	adds	r2, #180	; 0xb4
 80019e2:	da03      	bge.n	80019ec <IMU_Calculation+0x2a4>
 80019e4:	4a94      	ldr	r2, [pc, #592]	; (8001c38 <IMU_Calculation+0x4f0>)
 80019e6:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 80019ea:	80d3      	strh	r3, [r2, #6]
		IMU_Euler_to_DCM(&IMU, &eulerTemp);
 80019ec:	a854      	add	r0, sp, #336	; 0x150
 80019ee:	a90f      	add	r1, sp, #60	; 0x3c
 80019f0:	f7fe fdb6 	bl	8000560 <IMU_Euler_to_DCM>
	}

	/* Set the START Flag! */
	CtrlStates.copterStatus |= IMU_READY_FLAG;
 80019f4:	4b90      	ldr	r3, [pc, #576]	; (8001c38 <IMU_Calculation+0x4f0>)
	memset(&xAccFiltered_float, 0, sizeof(xAccFiltered_float));
	memset(&yAccFiltered_float, 0, sizeof(yAccFiltered_float));
	memset(&zAccFiltered_float, 0, sizeof(zAccFiltered_float));

	/************ MAG ***************/
	uint8_t magCount = 0;
 80019f6:	2600      	movs	r6, #0
		if(CtrlStates.yaw < -180) CtrlStates.yaw += 360;
		IMU_Euler_to_DCM(&IMU, &eulerTemp);
	}

	/* Set the START Flag! */
	CtrlStates.copterStatus |= IMU_READY_FLAG;
 80019f8:	7a1a      	ldrb	r2, [r3, #8]
 80019fa:	f042 0202 	orr.w	r2, r2, #2
 80019fe:	721a      	strb	r2, [r3, #8]

	xNextWakeTime = xTaskGetTickCount();
 8001a00:	f005 f81c 	bl	8006a3c <xTaskGetTickCount>
 8001a04:	9001      	str	r0, [sp, #4]

	while(1)
	{
		GPIOC->ODR ^= GPIO_Pin_11;
 8001a06:	4a8d      	ldr	r2, [pc, #564]	; (8001c3c <IMU_Calculation+0x4f4>)
		Gyro_readValues(&gyroXYZ);
 8001a08:	a804      	add	r0, sp, #16

	xNextWakeTime = xTaskGetTickCount();

	while(1)
	{
		GPIOC->ODR ^= GPIO_Pin_11;
 8001a0a:	8a93      	ldrh	r3, [r2, #20]
 8001a0c:	b29b      	uxth	r3, r3
 8001a0e:	f483 6300 	eor.w	r3, r3, #2048	; 0x800
 8001a12:	8293      	strh	r3, [r2, #20]
		Gyro_readValues(&gyroXYZ);
 8001a14:	f7fe fedb 	bl	80007ce <Gyro_readValues>
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 8001a18:	f8bd 4010 	ldrh.w	r4, [sp, #16]
 8001a1c:	f8bd 3008 	ldrh.w	r3, [sp, #8]
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001a20:	f8bd 0012 	ldrh.w	r0, [sp, #18]

	while(1)
	{
		GPIOC->ODR ^= GPIO_Pin_11;
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 8001a24:	1ae4      	subs	r4, r4, r3
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001a26:	f8bd 300a 	ldrh.w	r3, [sp, #10]
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001a2a:	f8bd 1014 	ldrh.w	r1, [sp, #20]
	while(1)
	{
		GPIOC->ODR ^= GPIO_Pin_11;
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001a2e:	1ac0      	subs	r0, r0, r3
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001a30:	f8bd 300c 	ldrh.w	r3, [sp, #12]

	while(1)
	{
		GPIOC->ODR ^= GPIO_Pin_11;
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 8001a34:	f8ad 4010 	strh.w	r4, [sp, #16]
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001a38:	1ac9      	subs	r1, r1, r3

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 8001a3a:	4b7d      	ldr	r3, [pc, #500]	; (8001c30 <IMU_Calculation+0x4e8>)
 8001a3c:	b224      	sxth	r4, r4
 8001a3e:	881b      	ldrh	r3, [r3, #0]
	while(1)
	{
		GPIOC->ODR ^= GPIO_Pin_11;
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001a40:	f8ad 0012 	strh.w	r0, [sp, #18]
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 8001a44:	425a      	negs	r2, r3
 8001a46:	4294      	cmp	r4, r2
	{
		GPIOC->ODR ^= GPIO_Pin_11;
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001a48:	f8ad 1014 	strh.w	r1, [sp, #20]

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 8001a4c:	dd04      	ble.n	8001a58 <IMU_Calculation+0x310>
 8001a4e:	429c      	cmp	r4, r3
 8001a50:	da02      	bge.n	8001a58 <IMU_Calculation+0x310>
 8001a52:	2400      	movs	r4, #0
 8001a54:	f8ad 4010 	strh.w	r4, [sp, #16]
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
 8001a58:	b200      	sxth	r0, r0
 8001a5a:	4290      	cmp	r0, r2
 8001a5c:	dd04      	ble.n	8001a68 <IMU_Calculation+0x320>
 8001a5e:	4298      	cmp	r0, r3
 8001a60:	da02      	bge.n	8001a68 <IMU_Calculation+0x320>
 8001a62:	2000      	movs	r0, #0
 8001a64:	f8ad 0012 	strh.w	r0, [sp, #18]
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;
 8001a68:	b209      	sxth	r1, r1
 8001a6a:	4291      	cmp	r1, r2
 8001a6c:	dd04      	ble.n	8001a78 <IMU_Calculation+0x330>
 8001a6e:	4299      	cmp	r1, r3
 8001a70:	da02      	bge.n	8001a78 <IMU_Calculation+0x330>
 8001a72:	2300      	movs	r3, #0
 8001a74:	f8ad 3014 	strh.w	r3, [sp, #20]

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001a78:	a812      	add	r0, sp, #72	; 0x48
 8001a7a:	f9bd 1010 	ldrsh.w	r1, [sp, #16]
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001a7e:	4c6c      	ldr	r4, [pc, #432]	; (8001c30 <IMU_Calculation+0x4e8>)
		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001a80:	f7ff fbf6 	bl	8001270 <floatFilterGyro>
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
 8001a84:	a81d      	add	r0, sp, #116	; 0x74
 8001a86:	f9bd 1012 	ldrsh.w	r1, [sp, #18]
 8001a8a:	f7ff fbf1 	bl	8001270 <floatFilterGyro>
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);
 8001a8e:	f9bd 1014 	ldrsh.w	r1, [sp, #20]
 8001a92:	a828      	add	r0, sp, #160	; 0xa0
 8001a94:	f7ff fbec 	bl	8001270 <floatFilterGyro>

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001a98:	7927      	ldrb	r7, [r4, #4]
 8001a9a:	ab72      	add	r3, sp, #456	; 0x1c8
 8001a9c:	370a      	adds	r7, #10
 8001a9e:	f994 0007 	ldrsb.w	r0, [r4, #7]
 8001aa2:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8001aa6:	f006 f803 	bl	8007ab0 <__aeabi_i2f>
 8001aaa:	4965      	ldr	r1, [pc, #404]	; (8001c40 <IMU_Calculation+0x4f8>)
 8001aac:	4680      	mov	r8, r0
 8001aae:	981c      	ldr	r0, [sp, #112]	; 0x70
 8001ab0:	f006 f852 	bl	8007b58 <__aeabi_fmul>
 8001ab4:	4601      	mov	r1, r0
 8001ab6:	4640      	mov	r0, r8
 8001ab8:	f006 f84e 	bl	8007b58 <__aeabi_fmul>
 8001abc:	4961      	ldr	r1, [pc, #388]	; (8001c44 <IMU_Calculation+0x4fc>)
 8001abe:	f006 f84b 	bl	8007b58 <__aeabi_fmul>
 8001ac2:	f847 0c78 	str.w	r0, [r7, #-120]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001ac6:	7967      	ldrb	r7, [r4, #5]
 8001ac8:	a972      	add	r1, sp, #456	; 0x1c8
 8001aca:	370a      	adds	r7, #10
 8001acc:	f994 0008 	ldrsb.w	r0, [r4, #8]
 8001ad0:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 8001ad4:	f005 ffec 	bl	8007ab0 <__aeabi_i2f>
 8001ad8:	4959      	ldr	r1, [pc, #356]	; (8001c40 <IMU_Calculation+0x4f8>)
 8001ada:	4680      	mov	r8, r0
 8001adc:	9827      	ldr	r0, [sp, #156]	; 0x9c
 8001ade:	f006 f83b 	bl	8007b58 <__aeabi_fmul>
 8001ae2:	4601      	mov	r1, r0
 8001ae4:	4640      	mov	r0, r8
 8001ae6:	f006 f837 	bl	8007b58 <__aeabi_fmul>
 8001aea:	4956      	ldr	r1, [pc, #344]	; (8001c44 <IMU_Calculation+0x4fc>)
 8001aec:	f006 f834 	bl	8007b58 <__aeabi_fmul>
 8001af0:	f847 0c78 	str.w	r0, [r7, #-120]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001af4:	79a7      	ldrb	r7, [r4, #6]
 8001af6:	aa72      	add	r2, sp, #456	; 0x1c8
 8001af8:	370a      	adds	r7, #10
 8001afa:	f994 0009 	ldrsb.w	r0, [r4, #9]
 8001afe:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 8001b02:	f005 ffd5 	bl	8007ab0 <__aeabi_i2f>
 8001b06:	494e      	ldr	r1, [pc, #312]	; (8001c40 <IMU_Calculation+0x4f8>)
 8001b08:	4680      	mov	r8, r0
 8001b0a:	9832      	ldr	r0, [sp, #200]	; 0xc8
 8001b0c:	f006 f824 	bl	8007b58 <__aeabi_fmul>
 8001b10:	4601      	mov	r1, r0
 8001b12:	4640      	mov	r0, r8
 8001b14:	f006 f820 	bl	8007b58 <__aeabi_fmul>
 8001b18:	494a      	ldr	r1, [pc, #296]	; (8001c44 <IMU_Calculation+0x4fc>)
 8001b1a:	f006 f81d 	bl	8007b58 <__aeabi_fmul>

		/*Here the ACC-Compensation, we do this in every tenth round*/
		if(GlobalSettings.enableACC)
 8001b1e:	7ae3      	ldrb	r3, [r4, #11]
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001b20:	f847 0c78 	str.w	r0, [r7, #-120]

		/*Here the ACC-Compensation, we do this in every tenth round*/
		if(GlobalSettings.enableACC)
 8001b24:	2b00      	cmp	r3, #0
 8001b26:	f000 80a1 	beq.w	8001c6c <IMU_Calculation+0x524>
		{
			if(accCount >= 0)
			{
				//ADXL345_readValues(&accXYZ);
				//LSM303DLHC_ACC_readValues(&accXYZ);
				LSM303DLHC_ACC_readValuesDMA(&accXYZ, &accBuffer[0]);
 8001b2a:	a80c      	add	r0, sp, #48	; 0x30
 8001b2c:	4946      	ldr	r1, [pc, #280]	; (8001c48 <IMU_Calculation+0x500>)
 8001b2e:	f7ff f82d 	bl	8000b8c <LSM303DLHC_ACC_readValuesDMA>
//
//				accXYZ.accValueX = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_2)-1700;
//				accXYZ.accValueZ = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_1)-1700;
//				accXYZ.accValueY = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_3)-1700;

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
 8001b32:	a833      	add	r0, sp, #204	; 0xcc
 8001b34:	f9bd 1030 	ldrsh.w	r1, [sp, #48]	; 0x30
 8001b38:	f7ff fb5c 	bl	80011f4 <floatFilterAcc>
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
 8001b3c:	a83e      	add	r0, sp, #248	; 0xf8
 8001b3e:	f9bd 1032 	ldrsh.w	r1, [sp, #50]	; 0x32
 8001b42:	f7ff fb57 	bl	80011f4 <floatFilterAcc>
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);
 8001b46:	a849      	add	r0, sp, #292	; 0x124
 8001b48:	f9bd 1034 	ldrsh.w	r1, [sp, #52]	; 0x34
 8001b4c:	f7ff fb52 	bl	80011f4 <floatFilterAcc>

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001b50:	f8dd a0f4 	ldr.w	sl, [sp, #244]	; 0xf4
 8001b54:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 8001b56:	4650      	mov	r0, sl
 8001b58:	4639      	mov	r1, r7
 8001b5a:	f006 f99b 	bl	8007e94 <__aeabi_fcmplt>
 8001b5e:	2800      	cmp	r0, #0
 8001b60:	d076      	beq.n	8001c50 <IMU_Calculation+0x508>
 8001b62:	f107 4b00 	add.w	fp, r7, #2147483648	; 0x80000000
 8001b66:	4650      	mov	r0, sl
 8001b68:	4659      	mov	r1, fp
 8001b6a:	f006 f9b1 	bl	8007ed0 <__aeabi_fcmpgt>
 8001b6e:	2800      	cmp	r0, #0
 8001b70:	d06e      	beq.n	8001c50 <IMU_Calculation+0x508>
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001b72:	f8dd 9120 	ldr.w	r9, [sp, #288]	; 0x120

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001b76:	4639      	mov	r1, r7
 8001b78:	4648      	mov	r0, r9
 8001b7a:	f006 f98b 	bl	8007e94 <__aeabi_fcmplt>
 8001b7e:	2800      	cmp	r0, #0
 8001b80:	d066      	beq.n	8001c50 <IMU_Calculation+0x508>
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001b82:	4648      	mov	r0, r9
 8001b84:	4659      	mov	r1, fp
 8001b86:	f006 f9a3 	bl	8007ed0 <__aeabi_fcmpgt>
 8001b8a:	2800      	cmp	r0, #0
 8001b8c:	d060      	beq.n	8001c50 <IMU_Calculation+0x508>
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
 8001b8e:	f8dd 814c 	ldr.w	r8, [sp, #332]	; 0x14c
				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001b92:	4639      	mov	r1, r7
 8001b94:	4640      	mov	r0, r8
 8001b96:	f006 f97d 	bl	8007e94 <__aeabi_fcmplt>
 8001b9a:	2800      	cmp	r0, #0
 8001b9c:	d058      	beq.n	8001c50 <IMU_Calculation+0x508>
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
 8001b9e:	4640      	mov	r0, r8
 8001ba0:	4659      	mov	r1, fp
 8001ba2:	f006 f995 	bl	8007ed0 <__aeabi_fcmpgt>
 8001ba6:	2800      	cmp	r0, #0
 8001ba8:	d052      	beq.n	8001c50 <IMU_Calculation+0x508>
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 8001baa:	7b27      	ldrb	r7, [r4, #12]
 8001bac:	ab72      	add	r3, sp, #456	; 0x1c8
 8001bae:	f994 000f 	ldrsb.w	r0, [r4, #15]
 8001bb2:	370c      	adds	r7, #12
 8001bb4:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8001bb8:	f005 ff7a 	bl	8007ab0 <__aeabi_i2f>
 8001bbc:	4651      	mov	r1, sl
 8001bbe:	f005 ffcb 	bl	8007b58 <__aeabi_fmul>
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 8001bc2:	f894 a00d 	ldrb.w	sl, [r4, #13]
 8001bc6:	a972      	add	r1, sp, #456	; 0x1c8
				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 8001bc8:	f847 0c74 	str.w	r0, [r7, #-116]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 8001bcc:	f10a 0a0c 	add.w	sl, sl, #12
 8001bd0:	f994 0010 	ldrsb.w	r0, [r4, #16]
 8001bd4:	eb01 0a8a 	add.w	sl, r1, sl, lsl #2
 8001bd8:	f005 ff6a 	bl	8007ab0 <__aeabi_i2f>
 8001bdc:	4649      	mov	r1, r9
 8001bde:	f005 ffbb 	bl	8007b58 <__aeabi_fmul>
 8001be2:	f84a 0c74 	str.w	r0, [sl, #-116]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]] = GlobalSettings.accDir.sensDirection[sensZ]*zAccFiltered_float.currentValue;
 8001be6:	f994 0011 	ldrsb.w	r0, [r4, #17]
 8001bea:	f005 ff61 	bl	8007ab0 <__aeabi_i2f>
 8001bee:	4641      	mov	r1, r8
 8001bf0:	f005 ffb2 	bl	8007b58 <__aeabi_fmul>
 8001bf4:	7ba3      	ldrb	r3, [r4, #14]
 8001bf6:	aa72      	add	r2, sp, #456	; 0x1c8
 8001bf8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8001bfc:	f843 0c44 	str.w	r0, [r3, #-68]
 8001c00:	4680      	mov	r8, r0

					xTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]];
 8001c02:	f857 0c74 	ldr.w	r0, [r7, #-116]
 8001c06:	f006 f96d 	bl	8007ee4 <__aeabi_f2iz>
 8001c0a:	4c10      	ldr	r4, [pc, #64]	; (8001c4c <IMU_Calculation+0x504>)
 8001c0c:	6020      	str	r0, [r4, #0]
					yTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]];
 8001c0e:	f85a 0c74 	ldr.w	r0, [sl, #-116]
 8001c12:	f006 f967 	bl	8007ee4 <__aeabi_f2iz>
 8001c16:	6060      	str	r0, [r4, #4]
					zTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]];
 8001c18:	4640      	mov	r0, r8
 8001c1a:	f006 f963 	bl	8007ee4 <__aeabi_f2iz>
 8001c1e:	60a0      	str	r0, [r4, #8]
 8001c20:	e01e      	b.n	8001c60 <IMU_Calculation+0x518>
 8001c22:	bf00      	nop
 8001c24:	f3af 8000 	nop.w
 8001c28:	60000000 	.word	0x60000000
 8001c2c:	3ff92196 	.word	0x3ff92196
 8001c30:	20002b88 	.word	0x20002b88
 8001c34:	42652ee0 	.word	0x42652ee0
 8001c38:	20002bc8 	.word	0x20002bc8
 8001c3c:	48000800 	.word	0x48000800
 8001c40:	3d8f5c29 	.word	0x3d8f5c29
 8001c44:	3c8efa35 	.word	0x3c8efa35
 8001c48:	20002bd4 	.word	0x20002bd4
 8001c4c:	20000148 	.word	0x20000148
				{
					IMU.kp_vector_ACC[0] = 0;
					IMU.kp_vector_ACC[1] = 0;
					IMU.kp_vector_ACC[2] = 0;

					xTemp = 0;
 8001c50:	4b2e      	ldr	r3, [pc, #184]	; (8001d0c <IMU_Calculation+0x5c4>)
 8001c52:	2200      	movs	r2, #0
					yTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]];
					zTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]];
				}
				else
				{
					IMU.kp_vector_ACC[0] = 0;
 8001c54:	956c      	str	r5, [sp, #432]	; 0x1b0
					IMU.kp_vector_ACC[1] = 0;
 8001c56:	956d      	str	r5, [sp, #436]	; 0x1b4
					IMU.kp_vector_ACC[2] = 0;
 8001c58:	956e      	str	r5, [sp, #440]	; 0x1b8

					xTemp = 0;
 8001c5a:	601a      	str	r2, [r3, #0]
					yTemp = 0;
 8001c5c:	605a      	str	r2, [r3, #4]
					zTemp = 0;
 8001c5e:	609a      	str	r2, [r3, #8]
				}

				if(GlobalSettings.enableDriftCorrection)
 8001c60:	4b2b      	ldr	r3, [pc, #172]	; (8001d10 <IMU_Calculation+0x5c8>)
 8001c62:	7a9b      	ldrb	r3, [r3, #10]
 8001c64:	b113      	cbz	r3, 8001c6c <IMU_Calculation+0x524>
				{
					IMU_drift_correction_ACC(&IMU);
 8001c66:	a854      	add	r0, sp, #336	; 0x150
 8001c68:	f7fe fba9 	bl	80003be <IMU_drift_correction_ACC>
			}
			accCount++;
		}

		/*Here the ACC-Compensation, we do this in every tenth round*/
		if(GlobalSettings.enableMAG)
 8001c6c:	4c28      	ldr	r4, [pc, #160]	; (8001d10 <IMU_Calculation+0x5c8>)
 8001c6e:	7e23      	ldrb	r3, [r4, #24]
 8001c70:	2b00      	cmp	r3, #0
 8001c72:	d038      	beq.n	8001ce6 <IMU_Calculation+0x59e>
		{
			if(magCount >= 45)
 8001c74:	2e2c      	cmp	r6, #44	; 0x2c
 8001c76:	d934      	bls.n	8001ce2 <IMU_Calculation+0x59a>
			{
				Mag_readValues(&magXYZ);
 8001c78:	a806      	add	r0, sp, #24
 8001c7a:	f7fe ffc6 	bl	8000c0a <Mag_readValues>
				update_intFilter(&xMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueX));
 8001c7e:	a808      	add	r0, sp, #32
 8001c80:	8c21      	ldrh	r1, [r4, #32]
 8001c82:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
 8001c86:	f7ff f993 	bl	8000fb0 <update_intFilter>
				update_intFilter(&yMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueY));
 8001c8a:	f9bd 201a 	ldrsh.w	r2, [sp, #26]
 8001c8e:	8c21      	ldrh	r1, [r4, #32]
 8001c90:	a80a      	add	r0, sp, #40	; 0x28
 8001c92:	f7ff f98d 	bl	8000fb0 <update_intFilter>

				/*Direction setup is the same as above*/
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensX]] = GlobalSettings.magDir.sensDirection[sensX]*xMagFiltered.filtered;
 8001c96:	7e66      	ldrb	r6, [r4, #25]
 8001c98:	ab72      	add	r3, sp, #456	; 0x1c8
 8001c9a:	3610      	adds	r6, #16
 8001c9c:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8001ca0:	9809      	ldr	r0, [sp, #36]	; 0x24
 8001ca2:	f994 301c 	ldrsb.w	r3, [r4, #28]
 8001ca6:	4358      	muls	r0, r3
 8001ca8:	f005 ff02 	bl	8007ab0 <__aeabi_i2f>
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensY]] = GlobalSettings.magDir.sensDirection[sensY]*yMagFiltered.filtered;
 8001cac:	f994 301d 	ldrsb.w	r3, [r4, #29]
				Mag_readValues(&magXYZ);
				update_intFilter(&xMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueX));
				update_intFilter(&yMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueY));

				/*Direction setup is the same as above*/
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensX]] = GlobalSettings.magDir.sensDirection[sensX]*xMagFiltered.filtered;
 8001cb0:	f846 0c78 	str.w	r0, [r6, #-120]
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensY]] = GlobalSettings.magDir.sensDirection[sensY]*yMagFiltered.filtered;
 8001cb4:	7ea6      	ldrb	r6, [r4, #26]
 8001cb6:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8001cb8:	a972      	add	r1, sp, #456	; 0x1c8
 8001cba:	4358      	muls	r0, r3
 8001cbc:	3610      	adds	r6, #16
 8001cbe:	eb01 0686 	add.w	r6, r1, r6, lsl #2
 8001cc2:	f005 fef5 	bl	8007ab0 <__aeabi_i2f>
				//IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = GlobalSettings.magDir.sensDirection[sensZ]*zMagFiltered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = 0;
 8001cc6:	7ee3      	ldrb	r3, [r4, #27]
				update_intFilter(&xMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueX));
				update_intFilter(&yMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueY));

				/*Direction setup is the same as above*/
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensX]] = GlobalSettings.magDir.sensDirection[sensX]*xMagFiltered.filtered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensY]] = GlobalSettings.magDir.sensDirection[sensY]*yMagFiltered.filtered;
 8001cc8:	f846 0c78 	str.w	r0, [r6, #-120]
				//IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = GlobalSettings.magDir.sensDirection[sensZ]*zMagFiltered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = 0;
 8001ccc:	aa72      	add	r2, sp, #456	; 0x1c8

				if(GlobalSettings.enableDriftCorrection)
 8001cce:	7aa6      	ldrb	r6, [r4, #10]

				/*Direction setup is the same as above*/
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensX]] = GlobalSettings.magDir.sensDirection[sensX]*xMagFiltered.filtered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensY]] = GlobalSettings.magDir.sensDirection[sensY]*yMagFiltered.filtered;
				//IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = GlobalSettings.magDir.sensDirection[sensZ]*zMagFiltered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = 0;
 8001cd0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8001cd4:	f843 5c38 	str.w	r5, [r3, #-56]

				if(GlobalSettings.enableDriftCorrection)
 8001cd8:	b11e      	cbz	r6, 8001ce2 <IMU_Calculation+0x59a>
				{
					IMU_drift_correction_MAG(&IMU);
 8001cda:	a854      	add	r0, sp, #336	; 0x150
 8001cdc:	f7fe fbd5 	bl	800048a <IMU_drift_correction_MAG>
				}
				magCount = 0;
 8001ce0:	2600      	movs	r6, #0
				//printf("%d,%d\n\r", (int)xMagFiltered.filtered, (int)yMagFiltered.filtered);
			}
			magCount++;
 8001ce2:	3601      	adds	r6, #1
 8001ce4:	b2f6      	uxtb	r6, r6
		}

		/*This functions here do the DCM-Algorithm stuff*/
		IMU_update(&IMU);
 8001ce6:	a854      	add	r0, sp, #336	; 0x150
 8001ce8:	f7fe fa72 	bl	80001d0 <IMU_update>
		IMU_ortho_adjust(&IMU);
 8001cec:	a854      	add	r0, sp, #336	; 0x150
 8001cee:	f7fe fb39 	bl	8000364 <IMU_ortho_adjust>
		IMU_normalize(&IMU);
 8001cf2:	a854      	add	r0, sp, #336	; 0x150
 8001cf4:	f7fe fab5 	bl	8000262 <IMU_normalize>
		//Euler_angles(&DCM);
		//IMU_DCM_to_Euler_deg(&IMU, &euler);
		IMU_DCM_to_XYZ(&IMU, &XYZ);
 8001cf8:	a854      	add	r0, sp, #336	; 0x150
 8001cfa:	4906      	ldr	r1, [pc, #24]	; (8001d14 <IMU_Calculation+0x5cc>)
 8001cfc:	f7fe fcb1 	bl	8000662 <IMU_DCM_to_XYZ>
		}else{
			loopcnt= loopcnt + 16; // Datenblock
		}
		*/

		vTaskDelayUntil( &xNextWakeTime, DT );
 8001d00:	a801      	add	r0, sp, #4
 8001d02:	2102      	movs	r1, #2
 8001d04:	f004 ffd0 	bl	8006ca8 <vTaskDelayUntil>
	}
 8001d08:	e67d      	b.n	8001a06 <IMU_Calculation+0x2be>
 8001d0a:	bf00      	nop
 8001d0c:	20000148 	.word	0x20000148
 8001d10:	20002b88 	.word	0x20002b88
 8001d14:	20002b7c 	.word	0x20002b7c

08001d18 <vRemoteCtrlWatchdogCoRoutine>:

void vRemoteCtrlWatchdogCoRoutine( xCoRoutineHandle xHandle,
                         unsigned portBASE_TYPE uxIndex )
{
   // Co-routines must start with a call to crSTART().
   crSTART( xHandle );
 8001d18:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   crEND();
}

void vRemoteCtrlWatchdogCoRoutine( xCoRoutineHandle xHandle,
                         unsigned portBASE_TYPE uxIndex )
{
 8001d1a:	b510      	push	{r4, lr}
 8001d1c:	4604      	mov	r4, r0
   // Co-routines must start with a call to crSTART().
   crSTART( xHandle );
 8001d1e:	b123      	cbz	r3, 8001d2a <vRemoteCtrlWatchdogCoRoutine+0x12>
 8001d20:	f240 42ee 	movw	r2, #1262	; 0x4ee
 8001d24:	4293      	cmp	r3, r2
 8001d26:	d119      	bne.n	8001d5c <vRemoteCtrlWatchdogCoRoutine+0x44>
 8001d28:	e008      	b.n	8001d3c <vRemoteCtrlWatchdogCoRoutine+0x24>

   for( ;; )
   {
	   // Delay for a fixed period.
	   crDELAY( xHandle, 1000 );
 8001d2a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001d2e:	2100      	movs	r1, #0
 8001d30:	f003 ffbe 	bl	8005cb0 <vCoRoutineAddToDelayedList>
 8001d34:	f240 43ee 	movw	r3, #1262	; 0x4ee
 8001d38:	86a3      	strh	r3, [r4, #52]	; 0x34
 8001d3a:	bd10      	pop	{r4, pc}
	   CtrlStates.watchDogTimVal++;
 8001d3c:	4b08      	ldr	r3, [pc, #32]	; (8001d60 <vRemoteCtrlWatchdogCoRoutine+0x48>)
 8001d3e:	7a5a      	ldrb	r2, [r3, #9]
 8001d40:	3201      	adds	r2, #1
 8001d42:	b2d2      	uxtb	r2, r2
	   if (CtrlStates.watchDogTimVal >= 2)
 8001d44:	2a01      	cmp	r2, #1

   for( ;; )
   {
	   // Delay for a fixed period.
	   crDELAY( xHandle, 1000 );
	   CtrlStates.watchDogTimVal++;
 8001d46:	725a      	strb	r2, [r3, #9]
	   if (CtrlStates.watchDogTimVal >= 2)
 8001d48:	d9ef      	bls.n	8001d2a <vRemoteCtrlWatchdogCoRoutine+0x12>
	   {
		   CtrlStates.copterStatus &= ~ARMED_FLAG;
 8001d4a:	7a1a      	ldrb	r2, [r3, #8]
		   printf("Watchdog Error!!%d\n", 0);
 8001d4c:	2100      	movs	r1, #0
	   // Delay for a fixed period.
	   crDELAY( xHandle, 1000 );
	   CtrlStates.watchDogTimVal++;
	   if (CtrlStates.watchDogTimVal >= 2)
	   {
		   CtrlStates.copterStatus &= ~ARMED_FLAG;
 8001d4e:	f022 0201 	bic.w	r2, r2, #1
		   printf("Watchdog Error!!%d\n", 0);
 8001d52:	4804      	ldr	r0, [pc, #16]	; (8001d64 <vRemoteCtrlWatchdogCoRoutine+0x4c>)
	   // Delay for a fixed period.
	   crDELAY( xHandle, 1000 );
	   CtrlStates.watchDogTimVal++;
	   if (CtrlStates.watchDogTimVal >= 2)
	   {
		   CtrlStates.copterStatus &= ~ARMED_FLAG;
 8001d54:	721a      	strb	r2, [r3, #8]
		   printf("Watchdog Error!!%d\n", 0);
 8001d56:	f000 fa6b 	bl	8002230 <printf>
 8001d5a:	e7e6      	b.n	8001d2a <vRemoteCtrlWatchdogCoRoutine+0x12>
 8001d5c:	bd10      	pop	{r4, pc}
 8001d5e:	bf00      	nop
 8001d60:	20002bc8 	.word	0x20002bc8
 8001d64:	0800acc3 	.word	0x0800acc3

08001d68 <LED_TOGGLE_NOT_READY>:



void LED_TOGGLE_NOT_READY(void)
{
	GPIOE->ODR ^= GPIO_Pin_8;
 8001d68:	4b0a      	ldr	r3, [pc, #40]	; (8001d94 <LED_TOGGLE_NOT_READY+0x2c>)
 8001d6a:	8a9a      	ldrh	r2, [r3, #20]
 8001d6c:	b292      	uxth	r2, r2
 8001d6e:	f482 7280 	eor.w	r2, r2, #256	; 0x100
 8001d72:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_10;
 8001d74:	8a9a      	ldrh	r2, [r3, #20]
 8001d76:	b292      	uxth	r2, r2
 8001d78:	f482 6280 	eor.w	r2, r2, #1024	; 0x400
 8001d7c:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_12;
 8001d7e:	8a9a      	ldrh	r2, [r3, #20]
 8001d80:	b292      	uxth	r2, r2
 8001d82:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 8001d86:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_14;
 8001d88:	8a9a      	ldrh	r2, [r3, #20]
 8001d8a:	b292      	uxth	r2, r2
 8001d8c:	f482 4280 	eor.w	r2, r2, #16384	; 0x4000
 8001d90:	829a      	strh	r2, [r3, #20]
 8001d92:	4770      	bx	lr
 8001d94:	48001000 	.word	0x48001000

08001d98 <LED_TOGGLE_READY>:
}

void LED_TOGGLE_READY(void)
{
	GPIOE->ODR ^= GPIO_Pin_9;
 8001d98:	4b0a      	ldr	r3, [pc, #40]	; (8001dc4 <LED_TOGGLE_READY+0x2c>)
 8001d9a:	8a9a      	ldrh	r2, [r3, #20]
 8001d9c:	b292      	uxth	r2, r2
 8001d9e:	f482 7200 	eor.w	r2, r2, #512	; 0x200
 8001da2:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_11;
 8001da4:	8a9a      	ldrh	r2, [r3, #20]
 8001da6:	b292      	uxth	r2, r2
 8001da8:	f482 6200 	eor.w	r2, r2, #2048	; 0x800
 8001dac:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_13;
 8001dae:	8a9a      	ldrh	r2, [r3, #20]
 8001db0:	b292      	uxth	r2, r2
 8001db2:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8001db6:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_15;
 8001db8:	8a9a      	ldrh	r2, [r3, #20]
 8001dba:	b292      	uxth	r2, r2
 8001dbc:	f482 4200 	eor.w	r2, r2, #32768	; 0x8000
 8001dc0:	829a      	strh	r2, [r3, #20]
 8001dc2:	4770      	bx	lr
 8001dc4:	48001000 	.word	0x48001000

08001dc8 <LED_TOGGLE_ALL>:
}

void LED_TOGGLE_ALL(void)
{
	if(GPIOE->ODR & GPIO_Pin_9)
 8001dc8:	4b2e      	ldr	r3, [pc, #184]	; (8001e84 <LED_TOGGLE_ALL+0xbc>)
 8001dca:	8a9a      	ldrh	r2, [r3, #20]
 8001dcc:	f402 7200 	and.w	r2, r2, #512	; 0x200
 8001dd0:	b292      	uxth	r2, r2
 8001dd2:	b34a      	cbz	r2, 8001e28 <LED_TOGGLE_ALL+0x60>
	{
		GPIOE->ODR &= ~GPIO_Pin_9;
 8001dd4:	8a9a      	ldrh	r2, [r3, #20]
 8001dd6:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001dda:	0412      	lsls	r2, r2, #16
 8001ddc:	0c12      	lsrs	r2, r2, #16
 8001dde:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_11;
 8001de0:	8a9a      	ldrh	r2, [r3, #20]
 8001de2:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001de6:	0412      	lsls	r2, r2, #16
 8001de8:	0c12      	lsrs	r2, r2, #16
 8001dea:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_13;
 8001dec:	8a9a      	ldrh	r2, [r3, #20]
 8001dee:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001df2:	0412      	lsls	r2, r2, #16
 8001df4:	0c12      	lsrs	r2, r2, #16
 8001df6:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_15;
 8001df8:	8a9a      	ldrh	r2, [r3, #20]
 8001dfa:	0452      	lsls	r2, r2, #17
 8001dfc:	0c52      	lsrs	r2, r2, #17
 8001dfe:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_8;
 8001e00:	8a9a      	ldrh	r2, [r3, #20]
 8001e02:	b292      	uxth	r2, r2
 8001e04:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001e08:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_10;
 8001e0a:	8a9a      	ldrh	r2, [r3, #20]
 8001e0c:	b292      	uxth	r2, r2
 8001e0e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001e12:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_12;
 8001e14:	8a9a      	ldrh	r2, [r3, #20]
 8001e16:	b292      	uxth	r2, r2
 8001e18:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001e1c:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_14;
 8001e1e:	8a9a      	ldrh	r2, [r3, #20]
 8001e20:	b292      	uxth	r2, r2
 8001e22:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001e26:	e02b      	b.n	8001e80 <LED_TOGGLE_ALL+0xb8>
	}
	else
	{
		GPIOE->ODR |= GPIO_Pin_9;
 8001e28:	8a9a      	ldrh	r2, [r3, #20]
 8001e2a:	b292      	uxth	r2, r2
 8001e2c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001e30:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_11;
 8001e32:	8a9a      	ldrh	r2, [r3, #20]
 8001e34:	b292      	uxth	r2, r2
 8001e36:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001e3a:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_13;
 8001e3c:	8a9a      	ldrh	r2, [r3, #20]
 8001e3e:	b292      	uxth	r2, r2
 8001e40:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001e44:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_15;
 8001e46:	8a9a      	ldrh	r2, [r3, #20]
 8001e48:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8001e4c:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 8001e50:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_8;
 8001e52:	8a9a      	ldrh	r2, [r3, #20]
 8001e54:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001e58:	0412      	lsls	r2, r2, #16
 8001e5a:	0c12      	lsrs	r2, r2, #16
 8001e5c:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_10;
 8001e5e:	8a9a      	ldrh	r2, [r3, #20]
 8001e60:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001e64:	0412      	lsls	r2, r2, #16
 8001e66:	0c12      	lsrs	r2, r2, #16
 8001e68:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_12;
 8001e6a:	8a9a      	ldrh	r2, [r3, #20]
 8001e6c:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001e70:	0412      	lsls	r2, r2, #16
 8001e72:	0c12      	lsrs	r2, r2, #16
 8001e74:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_14;
 8001e76:	8a9a      	ldrh	r2, [r3, #20]
 8001e78:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001e7c:	0412      	lsls	r2, r2, #16
 8001e7e:	0c12      	lsrs	r2, r2, #16
 8001e80:	829a      	strh	r2, [r3, #20]
 8001e82:	4770      	bx	lr
 8001e84:	48001000 	.word	0x48001000

08001e88 <vLedCtrlCoRoutine>:

void vLedCtrlCoRoutine( xCoRoutineHandle xHandle,
                         unsigned portBASE_TYPE uxIndex )
{
   // Co-routines must start with a call to crSTART().
   crSTART( xHandle );
 8001e88:	8e83      	ldrh	r3, [r0, #52]	; 0x34
	}
}

void vLedCtrlCoRoutine( xCoRoutineHandle xHandle,
                         unsigned portBASE_TYPE uxIndex )
{
 8001e8a:	b510      	push	{r4, lr}
 8001e8c:	4604      	mov	r4, r0
   // Co-routines must start with a call to crSTART().
   crSTART( xHandle );
 8001e8e:	b123      	cbz	r3, 8001e9a <vLedCtrlCoRoutine+0x12>
 8001e90:	f240 42b4 	movw	r2, #1204	; 0x4b4
 8001e94:	4293      	cmp	r3, r2
 8001e96:	d117      	bne.n	8001ec8 <vLedCtrlCoRoutine+0x40>
 8001e98:	e007      	b.n	8001eaa <vLedCtrlCoRoutine+0x22>

   for( ;; )
   {
	   // Delay for a fixed period.
	   crDELAY( xHandle, 200 );
 8001e9a:	20c8      	movs	r0, #200	; 0xc8
 8001e9c:	2100      	movs	r1, #0
 8001e9e:	f003 ff07 	bl	8005cb0 <vCoRoutineAddToDelayedList>
 8001ea2:	f240 43b4 	movw	r3, #1204	; 0x4b4
 8001ea6:	86a3      	strh	r3, [r4, #52]	; 0x34
 8001ea8:	bd10      	pop	{r4, pc}

	   if(CtrlStates.copterStatus == IMU_READY_FLAG)
 8001eaa:	4b08      	ldr	r3, [pc, #32]	; (8001ecc <vLedCtrlCoRoutine+0x44>)
 8001eac:	7a1b      	ldrb	r3, [r3, #8]
 8001eae:	2b02      	cmp	r3, #2
 8001eb0:	d102      	bne.n	8001eb8 <vLedCtrlCoRoutine+0x30>
	   {
		   LED_TOGGLE_READY();
 8001eb2:	f7ff ff71 	bl	8001d98 <LED_TOGGLE_READY>
 8001eb6:	e7f0      	b.n	8001e9a <vLedCtrlCoRoutine+0x12>
	   }
	   else if (CtrlStates.copterStatus & ARMED_FLAG)
 8001eb8:	07db      	lsls	r3, r3, #31
 8001eba:	d502      	bpl.n	8001ec2 <vLedCtrlCoRoutine+0x3a>
	   {
		   LED_TOGGLE_ALL();
 8001ebc:	f7ff ff84 	bl	8001dc8 <LED_TOGGLE_ALL>
 8001ec0:	e7eb      	b.n	8001e9a <vLedCtrlCoRoutine+0x12>
	   }
	   else
	   {
		   LED_TOGGLE_NOT_READY();
 8001ec2:	f7ff ff51 	bl	8001d68 <LED_TOGGLE_NOT_READY>
 8001ec6:	e7e8      	b.n	8001e9a <vLedCtrlCoRoutine+0x12>
 8001ec8:	bd10      	pop	{r4, pc}
 8001eca:	bf00      	nop
 8001ecc:	20002bc8 	.word	0x20002bc8

08001ed0 <vApplicationMallocFailedHook>:




void vApplicationMallocFailedHook( void )
{
 8001ed0:	e7fe      	b.n	8001ed0 <vApplicationMallocFailedHook>

08001ed2 <vApplicationStackOverflowHook>:
	for( ;; );
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName )
{
 8001ed2:	e7fe      	b.n	8001ed2 <vApplicationStackOverflowHook>

08001ed4 <vApplicationIdleHook>:
{

	/* This function is called on each cycle of the idle task.  In this case it
	does nothing useful, other than report the amout of FreeRTOS heap that
	remains unallocated. */
	vCoRoutineSchedule();
 8001ed4:	f003 bf0a 	b.w	8005cec <vCoRoutineSchedule>

08001ed8 <vApplicationTickHook>:
}


void vApplicationTickHook( void )
{
 8001ed8:	4770      	bx	lr

08001eda <USART3_IRQHandler>:
//***************************************************************************
// *  USART3 Interrupt
//    Dient zur schnellen Übertragung der aktuellen Telemetriedaten
// **************************************************************************
void USART3_IRQHandler(void)
{
 8001eda:	b508      	push	{r3, lr}
  	// Transmit Data Register empty interrupt
    if(USART_GetITStatus(USART3, USART_IT_TXE) != RESET)
 8001edc:	4814      	ldr	r0, [pc, #80]	; (8001f30 <USART3_IRQHandler+0x56>)
 8001ede:	4915      	ldr	r1, [pc, #84]	; (8001f34 <USART3_IRQHandler+0x5a>)
 8001ee0:	f003 fd7d 	bl	80059de <USART_GetITStatus>
 8001ee4:	2800      	cmp	r0, #0
 8001ee6:	d021      	beq.n	8001f2c <USART3_IRQHandler+0x52>
  	{
  		USART_ClearITPendingBit(USART3, USART_IT_TXE);
 8001ee8:	4912      	ldr	r1, [pc, #72]	; (8001f34 <USART3_IRQHandler+0x5a>)
 8001eea:	4811      	ldr	r0, [pc, #68]	; (8001f30 <USART3_IRQHandler+0x56>)
 8001eec:	f003 fd94 	bl	8005a18 <USART_ClearITPendingBit>

  		//if(ModbusData.txcnt <= ModbusData.txlen)
  		if(It_Com.txcnt <= (It_Com.txlen-1))
 8001ef0:	4b11      	ldr	r3, [pc, #68]	; (8001f38 <USART3_IRQHandler+0x5e>)
 8001ef2:	f8d3 1224 	ldr.w	r1, [r3, #548]	; 0x224
 8001ef6:	f8d3 2220 	ldr.w	r2, [r3, #544]	; 0x220
 8001efa:	3901      	subs	r1, #1
 8001efc:	428a      	cmp	r2, r1
 8001efe:	d80a      	bhi.n	8001f16 <USART3_IRQHandler+0x3c>
  		{
            USART_SendData(USART3,It_Com.txbuffer[It_Com.txcnt++]);
 8001f00:	1899      	adds	r1, r3, r2
 8001f02:	f891 1109 	ldrb.w	r1, [r1, #265]	; 0x109
 8001f06:	480a      	ldr	r0, [pc, #40]	; (8001f30 <USART3_IRQHandler+0x56>)
 8001f08:	3201      	adds	r2, #1
 8001f0a:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220
  			It_Com.txready = 0;
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
  		}
  	}
}
 8001f0e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  		USART_ClearITPendingBit(USART3, USART_IT_TXE);

  		//if(ModbusData.txcnt <= ModbusData.txlen)
  		if(It_Com.txcnt <= (It_Com.txlen-1))
  		{
            USART_SendData(USART3,It_Com.txbuffer[It_Com.txcnt++]);
 8001f12:	f003 bc80 	b.w	8005816 <USART_SendData>
  		else
  		{
  			It_Com.txcnt = 0;
  			It_Com.txready = 0;
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 8001f16:	4806      	ldr	r0, [pc, #24]	; (8001f30 <USART3_IRQHandler+0x56>)
 8001f18:	4906      	ldr	r1, [pc, #24]	; (8001f34 <USART3_IRQHandler+0x5a>)
  		{
            USART_SendData(USART3,It_Com.txbuffer[It_Com.txcnt++]);
  		}
  		else
  		{
  			It_Com.txcnt = 0;
 8001f1a:	2200      	movs	r2, #0
 8001f1c:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220
  			It_Com.txready = 0;
 8001f20:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
  		}
  	}
}
 8001f24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  		else
  		{
  			It_Com.txcnt = 0;
  			It_Com.txready = 0;
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 8001f28:	f003 bd2a 	b.w	8005980 <USART_ITConfig>
 8001f2c:	bd08      	pop	{r3, pc}
 8001f2e:	bf00      	nop
 8001f30:	40004800 	.word	0x40004800
 8001f34:	00070107 	.word	0x00070107
 8001f38:	20002bdc 	.word	0x20002bdc
 8001f3c:	f3af 8000 	nop.w

08001f40 <SETTINGS_init>:


void SETTINGS_init(MulticopterSettings *settings)
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
 8001f40:	22ff      	movs	r2, #255	; 0xff
#include <string.h>


void SETTINGS_init(MulticopterSettings *settings)
{
	settings->gyroSensTreshold = 20;
 8001f42:	2314      	movs	r3, #20
	settings->gyroDir.sensDirection[sensX] = -1;
 8001f44:	71c2      	strb	r2, [r0, #7]
	settings->gyroDir.sensDirection[sensY] = -1;
 8001f46:	7202      	strb	r2, [r0, #8]

	settings->enableDriftCorrection = 1;

	settings->enableACC = 1;
	settings->accDir.sensDirection[sensX] = 1;
	settings->accDir.sensDirection[sensY] = -1;
 8001f48:	7402      	strb	r2, [r0, #16]
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 1;
	settings->magLowpassValue = 5;//20;
	settings->magDir.sensDirection[sensX] = 1;
	settings->magDir.sensDirection[sensY] = -1;
 8001f4a:	7742      	strb	r2, [r0, #29]
	settings->PID_yaw.PID_ki = 0.0f;
	settings->PID_yaw.PID_kd = 1.5f;
#endif
#ifdef HEXA
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
	settings->PID_rollPitch.PID_ki = 0.20f; //0.12 //0.25
 8001f4c:	4a18      	ldr	r2, [pc, #96]	; (8001fb0 <SETTINGS_init+0x70>)
#include <string.h>


void SETTINGS_init(MulticopterSettings *settings)
{
	settings->gyroSensTreshold = 20;
 8001f4e:	8003      	strh	r3, [r0, #0]
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
 8001f50:	2301      	movs	r3, #1
 8001f52:	7243      	strb	r3, [r0, #9]
	settings->gyroDir.sensOrder[sensX] = 0;
	settings->gyroDir.sensOrder[sensY] = 1;
 8001f54:	7143      	strb	r3, [r0, #5]
	settings->gyroDir.sensOrder[sensZ] = 2;

	settings->enableDriftCorrection = 1;
 8001f56:	7283      	strb	r3, [r0, #10]

	settings->enableACC = 1;
 8001f58:	72c3      	strb	r3, [r0, #11]
	settings->accDir.sensDirection[sensX] = 1;
 8001f5a:	73c3      	strb	r3, [r0, #15]
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
 8001f5c:	7443      	strb	r3, [r0, #17]
	settings->accDir.sensOrder[sensX] = 1;
 8001f5e:	7303      	strb	r3, [r0, #12]
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 2;
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 1;
 8001f60:	7603      	strb	r3, [r0, #24]
	settings->magLowpassValue = 5;//20;
	settings->magDir.sensDirection[sensX] = 1;
 8001f62:	7703      	strb	r3, [r0, #28]
	settings->magDir.sensDirection[sensY] = -1;
	settings->magDir.sensDirection[sensZ] = 1;
 8001f64:	7783      	strb	r3, [r0, #30]
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
 8001f66:	7683      	strb	r3, [r0, #26]
	settings->PID_yaw.PID_ki = 0.0f;
	settings->PID_yaw.PID_kd = 1.5f;
#endif
#ifdef HEXA
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
	settings->PID_rollPitch.PID_ki = 0.20f; //0.12 //0.25
 8001f68:	62c2      	str	r2, [r0, #44]	; 0x2c
	settings->magDir.sensDirection[sensZ] = 1;
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 50*PRESCALEVALUE;
 8001f6a:	f44f 7396 	mov.w	r3, #300	; 0x12c
	settings->PID_yaw.PID_kd = 1.5f;
#endif
#ifdef HEXA
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
	settings->PID_rollPitch.PID_ki = 0.20f; //0.12 //0.25
	settings->PID_rollPitch.PID_kd = 0.150f; //0.04//0.30
 8001f6e:	4a11      	ldr	r2, [pc, #68]	; (8001fb4 <SETTINGS_init+0x74>)
#include <stm32_configuration.h>
#include <string.h>


void SETTINGS_init(MulticopterSettings *settings)
{
 8001f70:	b530      	push	{r4, r5, lr}
	settings->magDir.sensDirection[sensZ] = 1;
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 50*PRESCALEVALUE;
 8001f72:	8443      	strh	r3, [r0, #34]	; 0x22
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 1;
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 2;
	settings->accMaxGOverflow = 1.3;
 8001f74:	4d10      	ldr	r5, [pc, #64]	; (8001fb8 <SETTINGS_init+0x78>)
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 50*PRESCALEVALUE;
	settings->minSpeed = 55*PRESCALEVALUE;
 8001f76:	f44f 73a5 	mov.w	r3, #330	; 0x14a
 8001f7a:	8483      	strh	r3, [r0, #36]	; 0x24
	settings->PID_yaw.PID_kd = 1.5f;
#endif
#ifdef HEXA
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
	settings->PID_rollPitch.PID_ki = 0.20f; //0.12 //0.25
	settings->PID_rollPitch.PID_kd = 0.150f; //0.04//0.30
 8001f7c:	6302      	str	r2, [r0, #48]	; 0x30
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 50*PRESCALEVALUE;
	settings->minSpeed = 55*PRESCALEVALUE;
	settings->maxSpeed = 100*PRESCALEVALUE;
 8001f7e:	f44f 7316 	mov.w	r3, #600	; 0x258
#ifdef HEXA
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
	settings->PID_rollPitch.PID_ki = 0.20f; //0.12 //0.25
	settings->PID_rollPitch.PID_kd = 0.150f; //0.04//0.30

	settings->PID_yaw.PID_kp = 1.0f;		//2.0
 8001f82:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
 8001f86:	2400      	movs	r4, #0
	settings->gyroDir.sensOrder[sensY] = 1;
	settings->gyroDir.sensOrder[sensZ] = 2;
 8001f88:	2102      	movs	r1, #2
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 1;
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 2;
	settings->accMaxGOverflow = 1.3;
 8001f8a:	6145      	str	r5, [r0, #20]
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 50*PRESCALEVALUE;
	settings->minSpeed = 55*PRESCALEVALUE;
	settings->maxSpeed = 100*PRESCALEVALUE;
 8001f8c:	84c3      	strh	r3, [r0, #38]	; 0x26
#ifdef HEXA
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
	settings->PID_rollPitch.PID_ki = 0.20f; //0.12 //0.25
	settings->PID_rollPitch.PID_kd = 0.150f; //0.04//0.30

	settings->PID_yaw.PID_kp = 1.0f;		//2.0
 8001f8e:	6342      	str	r2, [r0, #52]	; 0x34
	settings->PID_yaw.PID_kp = 1.5f;
	settings->PID_yaw.PID_ki = 0.0f;
	settings->PID_yaw.PID_kd = 1.5f;
#endif
#ifdef HEXA
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
 8001f90:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 2;
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 1;
	settings->magLowpassValue = 5;//20;
 8001f94:	2505      	movs	r5, #5
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
	settings->PID_rollPitch.PID_ki = 0.20f; //0.12 //0.25
	settings->PID_rollPitch.PID_kd = 0.150f; //0.04//0.30

	settings->PID_yaw.PID_kp = 1.0f;		//2.0
	settings->PID_yaw.PID_ki = 0.0f;		//0.0
 8001f96:	2200      	movs	r2, #0
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
 8001f98:	7104      	strb	r4, [r0, #4]
	settings->gyroDir.sensOrder[sensY] = 1;
	settings->gyroDir.sensOrder[sensZ] = 2;
 8001f9a:	7181      	strb	r1, [r0, #6]
	settings->enableACC = 1;
	settings->accDir.sensDirection[sensX] = 1;
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 1;
	settings->accDir.sensOrder[sensY] = 0;
 8001f9c:	7344      	strb	r4, [r0, #13]
	settings->accDir.sensOrder[sensZ] = 2;
 8001f9e:	7381      	strb	r1, [r0, #14]
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 1;
	settings->magLowpassValue = 5;//20;
 8001fa0:	8405      	strh	r5, [r0, #32]
	settings->magDir.sensDirection[sensX] = 1;
	settings->magDir.sensDirection[sensY] = -1;
	settings->magDir.sensDirection[sensZ] = 1;
	settings->magDir.sensOrder[sensX] = 0;
 8001fa2:	7644      	strb	r4, [r0, #25]
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;
 8001fa4:	76c1      	strb	r1, [r0, #27]
	settings->PID_yaw.PID_kp = 1.5f;
	settings->PID_yaw.PID_ki = 0.0f;
	settings->PID_yaw.PID_kd = 1.5f;
#endif
#ifdef HEXA
	settings->PID_rollPitch.PID_kp = 0.50f;	//0.65 //0.6l
 8001fa6:	6283      	str	r3, [r0, #40]	; 0x28
	settings->PID_rollPitch.PID_ki = 0.20f; //0.12 //0.25
	settings->PID_rollPitch.PID_kd = 0.150f; //0.04//0.30

	settings->PID_yaw.PID_kp = 1.0f;		//2.0
	settings->PID_yaw.PID_ki = 0.0f;		//0.0
 8001fa8:	6382      	str	r2, [r0, #56]	; 0x38
	settings->PID_yaw.PID_kd = 0.50f;		//2.0
 8001faa:	63c3      	str	r3, [r0, #60]	; 0x3c
 8001fac:	bd30      	pop	{r4, r5, pc}
 8001fae:	bf00      	nop
 8001fb0:	3e4ccccd 	.word	0x3e4ccccd
 8001fb4:	3e19999a 	.word	0x3e19999a
 8001fb8:	3fa66666 	.word	0x3fa66666

08001fbc <CTRLSTATES_init>:
#endif
}

void CTRLSTATES_init(MulticopterCtrlStates *states)
{
	memset(states, 0, sizeof(MulticopterCtrlStates));
 8001fbc:	2100      	movs	r1, #0
 8001fbe:	220a      	movs	r2, #10
 8001fc0:	f006 b8c2 	b.w	8008148 <memset>

08001fc4 <printchar>:

static void printchar(char **str, int c)
{
    //extern int putchar(int c);

    if (str) {
 8001fc4:	b128      	cbz	r0, 8001fd2 <printchar+0xe>
        **str = c;
 8001fc6:	6803      	ldr	r3, [r0, #0]
 8001fc8:	7019      	strb	r1, [r3, #0]
        ++(*str);
 8001fca:	6803      	ldr	r3, [r0, #0]
 8001fcc:	3301      	adds	r3, #1
 8001fce:	6003      	str	r3, [r0, #0]
 8001fd0:	4770      	bx	lr
    }
    else (void)putchar(c);
 8001fd2:	b2c8      	uxtb	r0, r1
 8001fd4:	f000 bf22 	b.w	8002e1c <Usart2Put>

08001fd8 <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 8001fd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    register int pc = 0, padchar = ' ';

    if (width > 0) {
 8001fdc:	1e14      	subs	r4, r2, #0

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 8001fde:	4607      	mov	r7, r0
 8001fe0:	4688      	mov	r8, r1
    register int pc = 0, padchar = ' ';

    if (width > 0) {
 8001fe2:	dc03      	bgt.n	8001fec <prints+0x14>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
    register int pc = 0, padchar = ' ';
 8001fe4:	2620      	movs	r6, #32
 8001fe6:	e010      	b.n	800200a <prints+0x32>

    if (width > 0) {
        register int len = 0;
        register const char *ptr;
        for (ptr = string; *ptr; ++ptr) ++len;
 8001fe8:	3201      	adds	r2, #1
 8001fea:	e000      	b.n	8001fee <prints+0x16>

static int prints(char **out, const char *string, int width, int pad)
{
    register int pc = 0, padchar = ' ';

    if (width > 0) {
 8001fec:	2200      	movs	r2, #0
        register int len = 0;
        register const char *ptr;
        for (ptr = string; *ptr; ++ptr) ++len;
 8001fee:	f818 1002 	ldrb.w	r1, [r8, r2]
 8001ff2:	2900      	cmp	r1, #0
 8001ff4:	d1f8      	bne.n	8001fe8 <prints+0x10>
        if (len >= width) width = 0;
 8001ff6:	42a2      	cmp	r2, r4
        else width -= len;
 8001ff8:	bfb4      	ite	lt
 8001ffa:	ebc2 0404 	rsblt	r4, r2, r4

    if (width > 0) {
        register int len = 0;
        register const char *ptr;
        for (ptr = string; *ptr; ++ptr) ++len;
        if (len >= width) width = 0;
 8001ffe:	460c      	movge	r4, r1
        else width -= len;
        if (pad & PAD_ZERO) padchar = '0';
 8002000:	f013 0f02 	tst.w	r3, #2
 8002004:	bf0c      	ite	eq
 8002006:	2620      	moveq	r6, #32
 8002008:	2630      	movne	r6, #48	; 0x30
    }
    if (!(pad & PAD_RIGHT)) {
 800200a:	07db      	lsls	r3, r3, #31
 800200c:	d40c      	bmi.n	8002028 <prints+0x50>
 800200e:	4625      	mov	r5, r4
 8002010:	e004      	b.n	800201c <prints+0x44>
        for ( ; width > 0; --width) {
            printchar (out, padchar);
 8002012:	4638      	mov	r0, r7
 8002014:	4631      	mov	r1, r6
 8002016:	f7ff ffd5 	bl	8001fc4 <printchar>
        if (len >= width) width = 0;
        else width -= len;
        if (pad & PAD_ZERO) padchar = '0';
    }
    if (!(pad & PAD_RIGHT)) {
        for ( ; width > 0; --width) {
 800201a:	3d01      	subs	r5, #1
 800201c:	2d00      	cmp	r5, #0
 800201e:	dcf8      	bgt.n	8002012 <prints+0x3a>
}

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
 8002020:	ea24 75e4 	bic.w	r5, r4, r4, asr #31
 8002024:	1b64      	subs	r4, r4, r5
 8002026:	e000      	b.n	800202a <prints+0x52>
{
    register int pc = 0, padchar = ' ';
 8002028:	2500      	movs	r5, #0
}

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
 800202a:	ebc5 0808 	rsb	r8, r5, r8
 800202e:	e003      	b.n	8002038 <prints+0x60>
            printchar (out, padchar);
            ++pc;
        }
    }
    for ( ; *string ; ++string) {
        printchar (out, *string);
 8002030:	4638      	mov	r0, r7
 8002032:	f7ff ffc7 	bl	8001fc4 <printchar>
        ++pc;
 8002036:	3501      	adds	r5, #1
        for ( ; width > 0; --width) {
            printchar (out, padchar);
            ++pc;
        }
    }
    for ( ; *string ; ++string) {
 8002038:	f818 1005 	ldrb.w	r1, [r8, r5]
 800203c:	2900      	cmp	r1, #0
 800203e:	d1f7      	bne.n	8002030 <prints+0x58>
 8002040:	46a0      	mov	r8, r4
 8002042:	e005      	b.n	8002050 <prints+0x78>
        printchar (out, *string);
        ++pc;
    }
    for ( ; width > 0; --width) {
        printchar (out, padchar);
 8002044:	4638      	mov	r0, r7
 8002046:	4631      	mov	r1, r6
 8002048:	f7ff ffbc 	bl	8001fc4 <printchar>
    }
    for ( ; *string ; ++string) {
        printchar (out, *string);
        ++pc;
    }
    for ( ; width > 0; --width) {
 800204c:	f108 38ff 	add.w	r8, r8, #4294967295
 8002050:	f1b8 0f00 	cmp.w	r8, #0
 8002054:	dcf6      	bgt.n	8002044 <prints+0x6c>
        printchar (out, padchar);
        ++pc;
    }

    return pc;
}
 8002056:	2c00      	cmp	r4, #0
 8002058:	bfac      	ite	ge
 800205a:	1928      	addge	r0, r5, r4
 800205c:	1c28      	addlt	r0, r5, #0
 800205e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002062 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 8002062:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8002066:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8002068:	4681      	mov	r9, r0
 800206a:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
    register unsigned int u = i;
 800206e:	460c      	mov	r4, r1

    if (i == 0) {
 8002070:	b951      	cbnz	r1, 8002088 <printi+0x26>
        print_buf[0] = '0';
 8002072:	2330      	movs	r3, #48	; 0x30
 8002074:	f88d 3004 	strb.w	r3, [sp, #4]
        print_buf[1] = '\0';
 8002078:	f88d 1005 	strb.w	r1, [sp, #5]
        return prints (out, print_buf, width, pad);
 800207c:	4632      	mov	r2, r6
 800207e:	a901      	add	r1, sp, #4
 8002080:	4643      	mov	r3, r8
 8002082:	f7ff ffa9 	bl	8001fd8 <prints>
 8002086:	e037      	b.n	80020f8 <printi+0x96>
    }

    if (sg && b == 10 && i < 0) {
 8002088:	b133      	cbz	r3, 8002098 <printi+0x36>
 800208a:	2a0a      	cmp	r2, #10
 800208c:	d104      	bne.n	8002098 <printi+0x36>
 800208e:	2900      	cmp	r1, #0
 8002090:	da02      	bge.n	8002098 <printi+0x36>
        neg = 1;
        u = -i;
 8002092:	424c      	negs	r4, r1
        print_buf[1] = '\0';
        return prints (out, print_buf, width, pad);
    }

    if (sg && b == 10 && i < 0) {
        neg = 1;
 8002094:	2701      	movs	r7, #1
 8002096:	e000      	b.n	800209a <printi+0x38>

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
 8002098:	2700      	movs	r7, #0
        neg = 1;
        u = -i;
    }

    s = print_buf + PRINT_BUF_LEN-1;
    *s = '\0';
 800209a:	2300      	movs	r3, #0
 800209c:	ad04      	add	r5, sp, #16
 800209e:	f805 3d01 	strb.w	r3, [r5, #-1]!

    while (u) {
        t = u % b;
        if( t >= 10 )
            t += letbase - '0' - 10;
 80020a2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80020a4:	f1a3 013a 	sub.w	r1, r3, #58	; 0x3a
    }

    s = print_buf + PRINT_BUF_LEN-1;
    *s = '\0';

    while (u) {
 80020a8:	e00a      	b.n	80020c0 <printi+0x5e>
        t = u % b;
 80020aa:	fbb4 f3f2 	udiv	r3, r4, r2
 80020ae:	fb02 4413 	mls	r4, r2, r3, r4
        if( t >= 10 )
 80020b2:	2c09      	cmp	r4, #9
            t += letbase - '0' - 10;
 80020b4:	bfc8      	it	gt
 80020b6:	1864      	addgt	r4, r4, r1
        *--s = t + '0';
 80020b8:	3430      	adds	r4, #48	; 0x30
 80020ba:	f805 4d01 	strb.w	r4, [r5, #-1]!
        u /= b;
 80020be:	461c      	mov	r4, r3
 80020c0:	46aa      	mov	sl, r5
    }

    s = print_buf + PRINT_BUF_LEN-1;
    *s = '\0';

    while (u) {
 80020c2:	2c00      	cmp	r4, #0
 80020c4:	d1f1      	bne.n	80020aa <printi+0x48>
            t += letbase - '0' - 10;
        *--s = t + '0';
        u /= b;
    }

    if (neg) {
 80020c6:	b187      	cbz	r7, 80020ea <printi+0x88>
        if( width && (pad & PAD_ZERO) ) {
 80020c8:	b14e      	cbz	r6, 80020de <printi+0x7c>
 80020ca:	f018 0f02 	tst.w	r8, #2
 80020ce:	d006      	beq.n	80020de <printi+0x7c>
            printchar (out, '-');
 80020d0:	4648      	mov	r0, r9
 80020d2:	212d      	movs	r1, #45	; 0x2d
 80020d4:	f7ff ff76 	bl	8001fc4 <printchar>
            ++pc;
            --width;
 80020d8:	3e01      	subs	r6, #1
    }

    if (neg) {
        if( width && (pad & PAD_ZERO) ) {
            printchar (out, '-');
            ++pc;
 80020da:	2701      	movs	r7, #1
            --width;
 80020dc:	e005      	b.n	80020ea <printi+0x88>
        }
        else {
            *--s = '-';
 80020de:	232d      	movs	r3, #45	; 0x2d
 80020e0:	f105 3aff 	add.w	sl, r5, #4294967295
 80020e4:	f805 3c01 	strb.w	r3, [r5, #-1]

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
 80020e8:	2700      	movs	r7, #0
        else {
            *--s = '-';
        }
    }

    return pc + prints (out, s, width, pad);
 80020ea:	4648      	mov	r0, r9
 80020ec:	4651      	mov	r1, sl
 80020ee:	4632      	mov	r2, r6
 80020f0:	4643      	mov	r3, r8
 80020f2:	f7ff ff71 	bl	8001fd8 <prints>
 80020f6:	1838      	adds	r0, r7, r0
}
 80020f8:	b004      	add	sp, #16
 80020fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080020fe <print>:

static int print( char **out, const char *format, va_list args )
{
 80020fe:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    register int width, pad;
    register int pc = 0;
 8002102:	2400      	movs	r4, #0

    return pc + prints (out, s, width, pad);
}

static int print( char **out, const char *format, va_list args )
{
 8002104:	b088      	sub	sp, #32
 8002106:	4606      	mov	r6, r0
 8002108:	460d      	mov	r5, r1
 800210a:	9205      	str	r2, [sp, #20]
            if (*format == '%') goto out;
            if (*format == '-') {
                ++format;
                pad = PAD_RIGHT;
            }
            while (*format == '0') {
 800210c:	4627      	mov	r7, r4
                width *= 10;
                width += *format - '0';
            }
            if( *format == 's' ) {
                register char *s = (char *)va_arg( args, int );
                pc += prints (out, s?s:"(null)", width, pad);
 800210e:	f8df 811c 	ldr.w	r8, [pc, #284]	; 800222c <print+0x12e>
{
    register int width, pad;
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
 8002112:	e07f      	b.n	8002214 <print+0x116>
        if (*format == '%') {
 8002114:	2b25      	cmp	r3, #37	; 0x25
 8002116:	d177      	bne.n	8002208 <print+0x10a>
            ++format;
            width = pad = 0;
            if (*format == '\0') break;
 8002118:	786b      	ldrb	r3, [r5, #1]
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
 800211a:	1c6a      	adds	r2, r5, #1
            width = pad = 0;
            if (*format == '\0') break;
 800211c:	b913      	cbnz	r3, 8002124 <print+0x26>
        out:
            printchar (out, *format);
            ++pc;
        }
    }
    if (out) **out = '\0';
 800211e:	2e00      	cmp	r6, #0
 8002120:	d17d      	bne.n	800221e <print+0x120>
 8002122:	e07f      	b.n	8002224 <print+0x126>
    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
            width = pad = 0;
            if (*format == '\0') break;
            if (*format == '%') goto out;
 8002124:	2b25      	cmp	r3, #37	; 0x25
 8002126:	d06e      	beq.n	8002206 <print+0x108>
            if (*format == '-') {
 8002128:	2b2d      	cmp	r3, #45	; 0x2d
 800212a:	d102      	bne.n	8002132 <print+0x34>
                ++format;
 800212c:	1caa      	adds	r2, r5, #2
                pad = PAD_RIGHT;
 800212e:	2301      	movs	r3, #1
 8002130:	e003      	b.n	800213a <print+0x3c>
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
            width = pad = 0;
 8002132:	2300      	movs	r3, #0
 8002134:	e001      	b.n	800213a <print+0x3c>
                ++format;
                pad = PAD_RIGHT;
            }
            while (*format == '0') {
                ++format;
                pad |= PAD_ZERO;
 8002136:	f043 0302 	orr.w	r3, r3, #2
 800213a:	4611      	mov	r1, r2
            if (*format == '%') goto out;
            if (*format == '-') {
                ++format;
                pad = PAD_RIGHT;
            }
            while (*format == '0') {
 800213c:	7808      	ldrb	r0, [r1, #0]
 800213e:	3201      	adds	r2, #1
 8002140:	2830      	cmp	r0, #48	; 0x30
 8002142:	d0f8      	beq.n	8002136 <print+0x38>
 8002144:	468c      	mov	ip, r1
 8002146:	2200      	movs	r2, #0
                ++format;
                pad |= PAD_ZERO;
            }
            for ( ; *format >= '0' && *format <= '9'; ++format) {
                width *= 10;
 8002148:	f04f 0a0a 	mov.w	sl, #10
 800214c:	e001      	b.n	8002152 <print+0x54>
                width += *format - '0';
 800214e:	fb0a 0202 	mla	r2, sl, r2, r0
 8002152:	4665      	mov	r5, ip
            }
            while (*format == '0') {
                ++format;
                pad |= PAD_ZERO;
            }
            for ( ; *format >= '0' && *format <= '9'; ++format) {
 8002154:	7829      	ldrb	r1, [r5, #0]
 8002156:	f10c 0c01 	add.w	ip, ip, #1
 800215a:	f1a1 0030 	sub.w	r0, r1, #48	; 0x30
 800215e:	fa5f f980 	uxtb.w	r9, r0
 8002162:	f1b9 0f09 	cmp.w	r9, #9
 8002166:	d9f2      	bls.n	800214e <print+0x50>
                width *= 10;
                width += *format - '0';
            }
            if( *format == 's' ) {
 8002168:	2973      	cmp	r1, #115	; 0x73
 800216a:	d108      	bne.n	800217e <print+0x80>
                register char *s = (char *)va_arg( args, int );
 800216c:	9905      	ldr	r1, [sp, #20]
 800216e:	1d08      	adds	r0, r1, #4
 8002170:	6809      	ldr	r1, [r1, #0]
 8002172:	9005      	str	r0, [sp, #20]
                pc += prints (out, s?s:"(null)", width, pad);
 8002174:	2900      	cmp	r1, #0
 8002176:	bf08      	it	eq
 8002178:	4641      	moveq	r1, r8
 800217a:	4630      	mov	r0, r6
 800217c:	e040      	b.n	8002200 <print+0x102>
                continue;
            }
            if( *format == 'd' ) {
 800217e:	2964      	cmp	r1, #100	; 0x64
 8002180:	d10e      	bne.n	80021a0 <print+0xa2>
                pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 8002182:	e88d 000c 	stmia.w	sp, {r2, r3}
 8002186:	9905      	ldr	r1, [sp, #20]
 8002188:	2361      	movs	r3, #97	; 0x61
 800218a:	9302      	str	r3, [sp, #8]
 800218c:	1d08      	adds	r0, r1, #4
 800218e:	6809      	ldr	r1, [r1, #0]
 8002190:	9005      	str	r0, [sp, #20]
 8002192:	220a      	movs	r2, #10
 8002194:	4630      	mov	r0, r6
 8002196:	2301      	movs	r3, #1
 8002198:	f7ff ff63 	bl	8002062 <printi>
 800219c:	1824      	adds	r4, r4, r0
                continue;
 800219e:	e038      	b.n	8002212 <print+0x114>
            }
            if( *format == 'x' ) {
 80021a0:	2978      	cmp	r1, #120	; 0x78
 80021a2:	d106      	bne.n	80021b2 <print+0xb4>
                pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 80021a4:	9905      	ldr	r1, [sp, #20]
 80021a6:	e88d 000c 	stmia.w	sp, {r2, r3}
 80021aa:	1d08      	adds	r0, r1, #4
 80021ac:	9005      	str	r0, [sp, #20]
 80021ae:	2361      	movs	r3, #97	; 0x61
 80021b0:	e007      	b.n	80021c2 <print+0xc4>
                continue;
            }
            if( *format == 'X' ) {
 80021b2:	2958      	cmp	r1, #88	; 0x58
 80021b4:	d10a      	bne.n	80021cc <print+0xce>
                pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 80021b6:	9905      	ldr	r1, [sp, #20]
 80021b8:	e88d 000c 	stmia.w	sp, {r2, r3}
 80021bc:	1d08      	adds	r0, r1, #4
 80021be:	9005      	str	r0, [sp, #20]
 80021c0:	2341      	movs	r3, #65	; 0x41
 80021c2:	9302      	str	r3, [sp, #8]
 80021c4:	4630      	mov	r0, r6
 80021c6:	6809      	ldr	r1, [r1, #0]
 80021c8:	2210      	movs	r2, #16
 80021ca:	e00b      	b.n	80021e4 <print+0xe6>
                continue;
            }
            if( *format == 'u' ) {
 80021cc:	2975      	cmp	r1, #117	; 0x75
 80021ce:	d10b      	bne.n	80021e8 <print+0xea>
                pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 80021d0:	e88d 000c 	stmia.w	sp, {r2, r3}
 80021d4:	9905      	ldr	r1, [sp, #20]
 80021d6:	2361      	movs	r3, #97	; 0x61
 80021d8:	9302      	str	r3, [sp, #8]
 80021da:	1d08      	adds	r0, r1, #4
 80021dc:	6809      	ldr	r1, [r1, #0]
 80021de:	9005      	str	r0, [sp, #20]
 80021e0:	220a      	movs	r2, #10
 80021e2:	4630      	mov	r0, r6
 80021e4:	2300      	movs	r3, #0
 80021e6:	e7d7      	b.n	8002198 <print+0x9a>
                continue;
            }
            if( *format == 'c' ) {
 80021e8:	2963      	cmp	r1, #99	; 0x63
 80021ea:	d112      	bne.n	8002212 <print+0x114>
                /* char are converted to int then pushed on the stack */
                scr[0] = (char)va_arg( args, int );
 80021ec:	9905      	ldr	r1, [sp, #20]
                scr[1] = '\0';
 80021ee:	f88d 701d 	strb.w	r7, [sp, #29]
                pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
                continue;
            }
            if( *format == 'c' ) {
                /* char are converted to int then pushed on the stack */
                scr[0] = (char)va_arg( args, int );
 80021f2:	1d08      	adds	r0, r1, #4
 80021f4:	6809      	ldr	r1, [r1, #0]
 80021f6:	9005      	str	r0, [sp, #20]
 80021f8:	f88d 101c 	strb.w	r1, [sp, #28]
                scr[1] = '\0';
                pc += prints (out, scr, width, pad);
 80021fc:	4630      	mov	r0, r6
 80021fe:	a907      	add	r1, sp, #28
 8002200:	f7ff feea 	bl	8001fd8 <prints>
 8002204:	e7ca      	b.n	800219c <print+0x9e>
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
 8002206:	4615      	mov	r5, r2
                continue;
            }
        }
        else {
        out:
            printchar (out, *format);
 8002208:	4630      	mov	r0, r6
 800220a:	7829      	ldrb	r1, [r5, #0]
 800220c:	f7ff feda 	bl	8001fc4 <printchar>
            ++pc;
 8002210:	3401      	adds	r4, #1
{
    register int width, pad;
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
 8002212:	3501      	adds	r5, #1
 8002214:	782b      	ldrb	r3, [r5, #0]
 8002216:	2b00      	cmp	r3, #0
 8002218:	f47f af7c 	bne.w	8002114 <print+0x16>
 800221c:	e77f      	b.n	800211e <print+0x20>
        out:
            printchar (out, *format);
            ++pc;
        }
    }
    if (out) **out = '\0';
 800221e:	6833      	ldr	r3, [r6, #0]
 8002220:	2200      	movs	r2, #0
 8002222:	701a      	strb	r2, [r3, #0]
    va_end( args );
    return pc;
}
 8002224:	4620      	mov	r0, r4
 8002226:	b008      	add	sp, #32
 8002228:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800222c:	0800acf5 	.word	0x0800acf5

08002230 <printf>:

int printf(const char *format, ...)
{
 8002230:	b40f      	push	{r0, r1, r2, r3}
 8002232:	b507      	push	{r0, r1, r2, lr}
 8002234:	aa04      	add	r2, sp, #16
 8002236:	f852 1b04 	ldr.w	r1, [r2], #4
        va_list args;

        va_start( args, format );
        return print( 0, format, args );
 800223a:	2000      	movs	r0, #0

int printf(const char *format, ...)
{
        va_list args;

        va_start( args, format );
 800223c:	9201      	str	r2, [sp, #4]
        return print( 0, format, args );
 800223e:	f7ff ff5e 	bl	80020fe <print>
}
 8002242:	e8bd 400e 	ldmia.w	sp!, {r1, r2, r3, lr}
 8002246:	b004      	add	sp, #16
 8002248:	4770      	bx	lr

0800224a <sprintf>:

int sprintf(char *out, const char *format, ...)
{
 800224a:	b40e      	push	{r1, r2, r3}
 800224c:	b50f      	push	{r0, r1, r2, r3, lr}
 800224e:	aa05      	add	r2, sp, #20
 8002250:	f852 1b04 	ldr.w	r1, [r2], #4
 8002254:	9001      	str	r0, [sp, #4]
        va_list args;

        va_start( args, format );
        return print( &out, format, args );
 8002256:	a801      	add	r0, sp, #4

int sprintf(char *out, const char *format, ...)
{
        va_list args;

        va_start( args, format );
 8002258:	9203      	str	r2, [sp, #12]
        return print( &out, format, args );
 800225a:	f7ff ff50 	bl	80020fe <print>
}
 800225e:	b004      	add	sp, #16
 8002260:	f85d eb04 	ldr.w	lr, [sp], #4
 8002264:	b003      	add	sp, #12
 8002266:	4770      	bx	lr

08002268 <snprintf>:


int snprintf( char *buf, unsigned int count, const char *format, ... )
{
 8002268:	b40c      	push	{r2, r3}
 800226a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800226c:	aa06      	add	r2, sp, #24
 800226e:	f852 1b04 	ldr.w	r1, [r2], #4
 8002272:	9001      	str	r0, [sp, #4]
        va_list args;

        ( void ) count;

        va_start( args, format );
        return print( &buf, format, args );
 8002274:	a801      	add	r0, sp, #4
{
        va_list args;

        ( void ) count;

        va_start( args, format );
 8002276:	9203      	str	r2, [sp, #12]
        return print( &buf, format, args );
 8002278:	f7ff ff41 	bl	80020fe <print>
}
 800227c:	b005      	add	sp, #20
 800227e:	f85d eb04 	ldr.w	lr, [sp], #4
 8002282:	b002      	add	sp, #8
 8002284:	4770      	bx	lr
 8002286:	bf00      	nop

08002288 <CalcRXValues>:
#include <filter_Lib.h>
#include <remote_control.h>
#include <multicopter_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 8002288:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static intFilter nickFiltered = {0,0};
	static intFilter yawFiltered = {0,0};
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;
 800228c:	4d68      	ldr	r5, [pc, #416]	; (8002430 <CalcRXValues+0x1a8>)
 800228e:	2300      	movs	r3, #0
 8002290:	726b      	strb	r3, [r5, #9]
#include <filter_Lib.h>
#include <remote_control.h>
#include <multicopter_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 8002292:	4607      	mov	r7, r0
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);
 8002294:	7903      	ldrb	r3, [r0, #4]

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 8002296:	7940      	ldrb	r0, [r0, #5]
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);
 8002298:	4c66      	ldr	r4, [pc, #408]	; (8002434 <CalcRXValues+0x1ac>)
 800229a:	1a5b      	subs	r3, r3, r1

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 800229c:	1a40      	subs	r0, r0, r1
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);
 800229e:	8023      	strh	r3, [r4, #0]
#include <filter_Lib.h>
#include <remote_control.h>
#include <multicopter_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 80022a0:	460e      	mov	r6, r1
	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 80022a2:	f005 fc05 	bl	8007ab0 <__aeabi_i2f>
 80022a6:	4964      	ldr	r1, [pc, #400]	; (8002438 <CalcRXValues+0x1b0>)
 80022a8:	f005 fc56 	bl	8007b58 <__aeabi_fmul>
 80022ac:	4963      	ldr	r1, [pc, #396]	; (800243c <CalcRXValues+0x1b4>)
 80022ae:	f005 fb4b 	bl	8007948 <__addsf3>
 80022b2:	f005 fe17 	bl	8007ee4 <__aeabi_f2iz>
 80022b6:	2101      	movs	r1, #1
 80022b8:	4602      	mov	r2, r0
 80022ba:	1d20      	adds	r0, r4, #4
 80022bc:	f7fe fe78 	bl	8000fb0 <update_intFilter>
	update_intFilter(&nickFiltered, 1, ((uint8_t)msgPointer[3]-adjValue)*2.0f);
 80022c0:	78f8      	ldrb	r0, [r7, #3]
 80022c2:	1b80      	subs	r0, r0, r6
 80022c4:	f005 fbf4 	bl	8007ab0 <__aeabi_i2f>
 80022c8:	4601      	mov	r1, r0
 80022ca:	f005 fb3d 	bl	8007948 <__addsf3>
 80022ce:	f005 fe09 	bl	8007ee4 <__aeabi_f2iz>
 80022d2:	2101      	movs	r1, #1
 80022d4:	4602      	mov	r2, r0
 80022d6:	f104 000c 	add.w	r0, r4, #12
 80022da:	f7fe fe69 	bl	8000fb0 <update_intFilter>
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
 80022de:	78b8      	ldrb	r0, [r7, #2]
 80022e0:	1b80      	subs	r0, r0, r6
 80022e2:	f005 fbe5 	bl	8007ab0 <__aeabi_i2f>
 80022e6:	4601      	mov	r1, r0
 80022e8:	f005 fb2e 	bl	8007948 <__addsf3>
 80022ec:	f005 fdfa 	bl	8007ee4 <__aeabi_f2iz>
 80022f0:	2101      	movs	r1, #1
 80022f2:	4602      	mov	r2, r0
 80022f4:	f104 0014 	add.w	r0, r4, #20
 80022f8:	f7fe fe5a 	bl	8000fb0 <update_intFilter>
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);
 80022fc:	f9b4 0000 	ldrsh.w	r0, [r4]
 8002300:	f005 fbd6 	bl	8007ab0 <__aeabi_i2f>
 8002304:	494e      	ldr	r1, [pc, #312]	; (8002440 <CalcRXValues+0x1b8>)
 8002306:	f005 fc27 	bl	8007b58 <__aeabi_fmul>
 800230a:	f005 fdeb 	bl	8007ee4 <__aeabi_f2iz>
 800230e:	2101      	movs	r1, #1
 8002310:	4602      	mov	r2, r0
 8002312:	f104 001c 	add.w	r0, r4, #28
 8002316:	f7fe fe4b 	bl	8000fb0 <update_intFilter>
	CtrlStates.gas = gasFiltered.filtered;
	CtrlStates.roll = rollFiltered.filtered;
	CtrlStates.nick = nickFiltered.filtered;

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 800231a:	7a2e      	ldrb	r6, [r5, #8]
	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
	update_intFilter(&nickFiltered, 1, ((uint8_t)msgPointer[3]-adjValue)*2.0f);
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);

	CtrlStates.gas = gasFiltered.filtered;
 800231c:	f8b4 9008 	ldrh.w	r9, [r4, #8]
	CtrlStates.roll = rollFiltered.filtered;
 8002320:	f8d4 8018 	ldr.w	r8, [r4, #24]
	CtrlStates.nick = nickFiltered.filtered;
 8002324:	6927      	ldr	r7, [r4, #16]

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 8002326:	07f3      	lsls	r3, r6, #31
	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
	update_intFilter(&nickFiltered, 1, ((uint8_t)msgPointer[3]-adjValue)*2.0f);
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);

	CtrlStates.gas = gasFiltered.filtered;
 8002328:	f8a5 9000 	strh.w	r9, [r5]
	CtrlStates.roll = rollFiltered.filtered;
 800232c:	f8a5 8002 	strh.w	r8, [r5, #2]
	CtrlStates.nick = nickFiltered.filtered;
 8002330:	80af      	strh	r7, [r5, #4]

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 8002332:	d504      	bpl.n	800233e <CalcRXValues+0xb6>
	{
		CtrlStates.yaw -= yawFiltered.filtered;
 8002334:	88ea      	ldrh	r2, [r5, #6]
 8002336:	6a23      	ldr	r3, [r4, #32]
 8002338:	1ad3      	subs	r3, r2, r3
 800233a:	80eb      	strh	r3, [r5, #6]
 800233c:	e004      	b.n	8002348 <CalcRXValues+0xc0>
	}
	else
	{
		CtrlStates.yaw = XYZ.z;
 800233e:	4b41      	ldr	r3, [pc, #260]	; (8002444 <CalcRXValues+0x1bc>)
 8002340:	6898      	ldr	r0, [r3, #8]
 8002342:	f005 fdcf 	bl	8007ee4 <__aeabi_f2iz>
 8002346:	80e8      	strh	r0, [r5, #6]
	}

#define ROLL_NICK_TRSHLD 3

	/* Narrow down all ctrl values */
	if(CtrlStates.gas > MAX_GAS) CtrlStates.gas = MAX_GAS;
 8002348:	fa0f f989 	sxth.w	r9, r9
 800234c:	f1b9 0fc8 	cmp.w	r9, #200	; 0xc8
 8002350:	4b37      	ldr	r3, [pc, #220]	; (8002430 <CalcRXValues+0x1a8>)
 8002352:	dd01      	ble.n	8002358 <CalcRXValues+0xd0>
 8002354:	22c8      	movs	r2, #200	; 0xc8
 8002356:	801a      	strh	r2, [r3, #0]
	if(CtrlStates.gas < 0) CtrlStates.gas = 0;
 8002358:	f9b3 3000 	ldrsh.w	r3, [r3]
 800235c:	2b00      	cmp	r3, #0
 800235e:	da02      	bge.n	8002366 <CalcRXValues+0xde>
 8002360:	4b33      	ldr	r3, [pc, #204]	; (8002430 <CalcRXValues+0x1a8>)
 8002362:	2200      	movs	r2, #0
 8002364:	801a      	strh	r2, [r3, #0]

	if(CtrlStates.roll > -ROLL_NICK_TRSHLD && CtrlStates.roll < ROLL_NICK_TRSHLD) CtrlStates.roll = 0;
 8002366:	f108 0802 	add.w	r8, r8, #2
 800236a:	fa1f f888 	uxth.w	r8, r8
 800236e:	f1b8 0f04 	cmp.w	r8, #4
 8002372:	4b2f      	ldr	r3, [pc, #188]	; (8002430 <CalcRXValues+0x1a8>)
 8002374:	d801      	bhi.n	800237a <CalcRXValues+0xf2>
 8002376:	2200      	movs	r2, #0
 8002378:	805a      	strh	r2, [r3, #2]
	if(CtrlStates.roll > MAX_ROLL) CtrlStates.roll = MAX_ROLL;
 800237a:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800237e:	2a23      	cmp	r2, #35	; 0x23
 8002380:	dd02      	ble.n	8002388 <CalcRXValues+0x100>
 8002382:	4a2b      	ldr	r2, [pc, #172]	; (8002430 <CalcRXValues+0x1a8>)
 8002384:	2123      	movs	r1, #35	; 0x23
 8002386:	8051      	strh	r1, [r2, #2]
	if(CtrlStates.roll < -MAX_ROLL) CtrlStates.roll = -MAX_ROLL;
 8002388:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800238c:	3323      	adds	r3, #35	; 0x23
 800238e:	da03      	bge.n	8002398 <CalcRXValues+0x110>
 8002390:	4b27      	ldr	r3, [pc, #156]	; (8002430 <CalcRXValues+0x1a8>)
 8002392:	f64f 72dd 	movw	r2, #65501	; 0xffdd
 8002396:	805a      	strh	r2, [r3, #2]

	if(CtrlStates.nick > -ROLL_NICK_TRSHLD && CtrlStates.nick < ROLL_NICK_TRSHLD) CtrlStates.nick = 0;
 8002398:	3702      	adds	r7, #2
 800239a:	b2bf      	uxth	r7, r7
 800239c:	2f04      	cmp	r7, #4
 800239e:	4b24      	ldr	r3, [pc, #144]	; (8002430 <CalcRXValues+0x1a8>)
 80023a0:	d801      	bhi.n	80023a6 <CalcRXValues+0x11e>
 80023a2:	2200      	movs	r2, #0
 80023a4:	809a      	strh	r2, [r3, #4]
	if(CtrlStates.nick > MAX_NICK) CtrlStates.nick = MAX_NICK;
 80023a6:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 80023aa:	2a23      	cmp	r2, #35	; 0x23
 80023ac:	dd02      	ble.n	80023b4 <CalcRXValues+0x12c>
 80023ae:	4a20      	ldr	r2, [pc, #128]	; (8002430 <CalcRXValues+0x1a8>)
 80023b0:	2123      	movs	r1, #35	; 0x23
 80023b2:	8091      	strh	r1, [r2, #4]
	if(CtrlStates.nick < -MAX_NICK) CtrlStates.nick = -MAX_NICK;
 80023b4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80023b8:	3323      	adds	r3, #35	; 0x23
 80023ba:	da03      	bge.n	80023c4 <CalcRXValues+0x13c>
 80023bc:	4b1c      	ldr	r3, [pc, #112]	; (8002430 <CalcRXValues+0x1a8>)
 80023be:	f64f 72dd 	movw	r2, #65501	; 0xffdd
 80023c2:	809a      	strh	r2, [r3, #4]

	/* The yaw value needs a special handling */
	if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 80023c4:	4b1a      	ldr	r3, [pc, #104]	; (8002430 <CalcRXValues+0x1a8>)
 80023c6:	88da      	ldrh	r2, [r3, #6]
 80023c8:	b211      	sxth	r1, r2
 80023ca:	29b4      	cmp	r1, #180	; 0xb4
 80023cc:	bfc4      	itt	gt
 80023ce:	f5a2 72b4 	subgt.w	r2, r2, #360	; 0x168
 80023d2:	80da      	strhgt	r2, [r3, #6]
	if(CtrlStates.yaw < -180) CtrlStates.yaw += 360;
 80023d4:	88db      	ldrh	r3, [r3, #6]
 80023d6:	b21a      	sxth	r2, r3
 80023d8:	32b4      	adds	r2, #180	; 0xb4
 80023da:	da03      	bge.n	80023e4 <CalcRXValues+0x15c>
 80023dc:	4a14      	ldr	r2, [pc, #80]	; (8002430 <CalcRXValues+0x1a8>)
 80023de:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 80023e2:	80d3      	strh	r3, [r2, #6]
	else
	{
		COPTER_STATUS &= ~(READY_FLAG);
	}
#else
	if(currentYaw < -20 && CtrlStates.gas < 5)
 80023e4:	4b13      	ldr	r3, [pc, #76]	; (8002434 <CalcRXValues+0x1ac>)
 80023e6:	8818      	ldrh	r0, [r3, #0]
 80023e8:	b203      	sxth	r3, r0
 80023ea:	3314      	adds	r3, #20
 80023ec:	da0b      	bge.n	8002406 <CalcRXValues+0x17e>
 80023ee:	4b10      	ldr	r3, [pc, #64]	; (8002430 <CalcRXValues+0x1a8>)
 80023f0:	f9b3 2000 	ldrsh.w	r2, [r3]
 80023f4:	2a04      	cmp	r2, #4
 80023f6:	dc06      	bgt.n	8002406 <CalcRXValues+0x17e>
	{
		if(CtrlStates.copterStatus & IMU_READY_FLAG)
 80023f8:	f006 0202 	and.w	r2, r6, #2
 80023fc:	b2d2      	uxtb	r2, r2
 80023fe:	b1aa      	cbz	r2, 800242c <CalcRXValues+0x1a4>
		{
			CtrlStates.copterStatus |= ARMED_FLAG;
 8002400:	f046 0601 	orr.w	r6, r6, #1
 8002404:	e011      	b.n	800242a <CalcRXValues+0x1a2>
		}
	}
	else if((currentYaw*1.5) > 20 && CtrlStates.gas < 5)
 8002406:	b200      	sxth	r0, r0
 8002408:	f005 fb52 	bl	8007ab0 <__aeabi_i2f>
 800240c:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 8002410:	f005 fba2 	bl	8007b58 <__aeabi_fmul>
 8002414:	490c      	ldr	r1, [pc, #48]	; (8002448 <CalcRXValues+0x1c0>)
 8002416:	f005 fd5b 	bl	8007ed0 <__aeabi_fcmpgt>
 800241a:	b138      	cbz	r0, 800242c <CalcRXValues+0x1a4>
 800241c:	4b04      	ldr	r3, [pc, #16]	; (8002430 <CalcRXValues+0x1a8>)
 800241e:	f9b3 2000 	ldrsh.w	r2, [r3]
 8002422:	2a04      	cmp	r2, #4
 8002424:	dc02      	bgt.n	800242c <CalcRXValues+0x1a4>
	{
		CtrlStates.copterStatus &= ~(ARMED_FLAG);
 8002426:	f026 0601 	bic.w	r6, r6, #1
 800242a:	721e      	strb	r6, [r3, #8]
 800242c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002430:	20002bc8 	.word	0x20002bc8
 8002434:	20000158 	.word	0x20000158
 8002438:	40f00000 	.word	0x40f00000
 800243c:	42700000 	.word	0x42700000
 8002440:	3e99999a 	.word	0x3e99999a
 8002444:	20002b7c 	.word	0x20002b7c
 8002448:	41a00000 	.word	0x41a00000

0800244c <RCC_Configuration>:
#include <stm32_configuration.h>



void RCC_Configuration(void)
{
 800244c:	b508      	push	{r3, lr}
	/* Enable I2C1 periph */
	RCC_APB1PeriphClockCmd( RCC_APB1Periph_I2C1 |
 800244e:	2101      	movs	r1, #1
 8002450:	4808      	ldr	r0, [pc, #32]	; (8002474 <RCC_Configuration+0x28>)
 8002452:	f001 ffd1 	bl	80043f8 <RCC_APB1PeriphClockCmd>
							RCC_APB1Periph_USART3 |
							RCC_APB1Periph_TIM2 |
							RCC_APB1Periph_TIM3 |
							RCC_APB1Periph_TIM4, ENABLE);
	/* Enable the SPI periph */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1 |
 8002456:	2101      	movs	r1, #1
 8002458:	f241 0001 	movw	r0, #4097	; 0x1001
 800245c:	f001 ffc0 	bl	80043e0 <RCC_APB2PeriphClockCmd>
						   RCC_APB2Periph_SYSCFG, ENABLE);

	/* Enable Periph clock enable, SPI, GPIOs */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA |
 8002460:	4805      	ldr	r0, [pc, #20]	; (8002478 <RCC_Configuration+0x2c>)
 8002462:	2101      	movs	r1, #1
 8002464:	f001 ffb0 	bl	80043c8 <RCC_AHBPeriphClockCmd>
						  RCC_AHBPeriph_GPIOE |
						  RCC_AHBPeriph_ADC12 |
						  RCC_AHBPeriph_DMA1, ENABLE);

	/* Configure the ADC clock */
	RCC_ADCCLKConfig(RCC_ADC12PLLCLK_Div2);
 8002468:	f44f 7088 	mov.w	r0, #272	; 0x110
}
 800246c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
						  RCC_AHBPeriph_GPIOE |
						  RCC_AHBPeriph_ADC12 |
						  RCC_AHBPeriph_DMA1, ENABLE);

	/* Configure the ADC clock */
	RCC_ADCCLKConfig(RCC_ADC12PLLCLK_Div2);
 8002470:	f001 bf36 	b.w	80042e0 <RCC_ADCCLKConfig>
 8002474:	00260007 	.word	0x00260007
 8002478:	103e0001 	.word	0x103e0001

0800247c <NVIC_Configuration>:




void NVIC_Configuration(void)
{
 800247c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	#ifdef  VECT_TAB_RAM
	  /* Set the Vector Table base location at 0x20000000 */
	  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
	#else  /* VECT_TAB_FLASH  */
	  /* Set the Vector Table base location at 0x08000000 */
	  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
 800247e:	2100      	movs	r1, #0
 8002480:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8002484:	f001 fd1c 	bl	8003ec0 <NVIC_SetVectorTable>
	#endif

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
 8002488:	f44f 7040 	mov.w	r0, #768	; 0x300
 800248c:	f001 fcda 	bl	8003e44 <NVIC_PriorityGroupConfig>

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
 8002490:	2326      	movs	r3, #38	; 0x26
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je höher desto niedriger
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto höher desto höher
 8002492:	2500      	movs	r5, #0
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8002494:	2401      	movs	r4, #1
	#endif

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
 8002496:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je höher desto niedriger
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto höher desto höher
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 800249a:	a801      	add	r0, sp, #4

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je höher desto niedriger
 800249c:	230e      	movs	r3, #14
 800249e:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto höher desto höher
 80024a2:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80024a6:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 80024aa:	f001 fcd5 	bl	8003e58 <NVIC_Init>

	/* Config the USART3 Interrupt*/
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
 80024ae:	2327      	movs	r3, #39	; 0x27
 80024b0:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;  // wie war das noch mal mit den Interrupt prioritäten??
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 80024b4:	a801      	add	r0, sp, #4
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Config the USART3 Interrupt*/
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;  // wie war das noch mal mit den Interrupt prioritäten??
 80024b6:	230a      	movs	r3, #10
 80024b8:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80024bc:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80024c0:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 80024c4:	f001 fcc8 	bl	8003e58 <NVIC_Init>

	/* Enable and set EXTI0 Interrupt to the lowest priority */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
 80024c8:	2328      	movs	r3, #40	; 0x28
 80024ca:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 80024ce:	a801      	add	r0, sp, #4
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Enable and set EXTI0 Interrupt to the lowest priority */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
 80024d0:	230d      	movs	r3, #13
 80024d2:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80024d6:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80024da:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 80024de:	f001 fcbb 	bl	8003e58 <NVIC_Init>
}
 80024e2:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

080024e4 <GPIO_Configuration>:



void GPIO_Configuration(void)
{
 80024e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 80024e8:	f8df c260 	ldr.w	ip, [pc, #608]	; 800274c <GPIO_Configuration+0x268>
}



void GPIO_Configuration(void)
{
 80024ec:	b085      	sub	sp, #20
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80024ee:	f8df 8260 	ldr.w	r8, [pc, #608]	; 8002750 <GPIO_Configuration+0x26c>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80024f2:	2400      	movs	r4, #0
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 80024f4:	4660      	mov	r0, ip
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80024f6:	2603      	movs	r6, #3
	/* Configure PE14 and PE15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80024f8:	f04f 0901 	mov.w	r9, #1
void GPIO_Configuration(void)
{
	/************************GPIO***************************/
	GPIO_InitTypeDef GPIO_InitStructure;
	/* Configure PE14 and PE15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
 80024fc:	f44f 437f 	mov.w	r3, #65280	; 0xff00
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8002500:	a902      	add	r1, sp, #8
 8002502:	f8cd c000 	str.w	ip, [sp]
void GPIO_Configuration(void)
{
	/************************GPIO***************************/
	GPIO_InitTypeDef GPIO_InitStructure;
	/* Configure PE14 and PE15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
 8002506:	9302      	str	r3, [sp, #8]
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002508:	f88d 900c 	strb.w	r9, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800250c:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002510:	f88d 600d 	strb.w	r6, [sp, #13]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002514:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8002518:	f001 fa50 	bl	80039bc <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 800251c:	f44f 6300 	mov.w	r3, #2048	; 0x800
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002520:	4640      	mov	r0, r8
 8002522:	a902      	add	r1, sp, #8
	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002524:	2502      	movs	r5, #2
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 8002526:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002528:	f88d 900c 	strb.w	r9, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800252c:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002530:	f88d 600d 	strb.w	r6, [sp, #13]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002534:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002538:	f001 fa40 	bl	80039bc <GPIO_Init>

	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 800253c:	230c      	movs	r3, #12
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800253e:	a902      	add	r1, sp, #8
 8002540:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002544:	4f80      	ldr	r7, [pc, #512]	; (8002748 <GPIO_Configuration+0x264>)

	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 8002546:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 8002548:	f88d 900f 	strb.w	r9, [sp, #15]
	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800254c:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002550:	f88d 600d 	strb.w	r6, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002554:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002558:	f001 fa30 	bl	80039bc <GPIO_Init>

	/* Connect USART2 pins to AF2 */
	// TX = PA2
	// RX = PA3
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_7);
 800255c:	4629      	mov	r1, r5
 800255e:	2207      	movs	r2, #7
 8002560:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8002564:	f001 faad 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7);
 8002568:	2207      	movs	r2, #7
 800256a:	4631      	mov	r1, r6
 800256c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8002570:	f001 faa7 	bl	8003ac2 <GPIO_PinAFConfig>


	/* GPIOB Configuration:  USART3 RX on PB11 and TX on PB10 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
 8002574:	f44f 6340 	mov.w	r3, #3072	; 0xc00
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002578:	4638      	mov	r0, r7
 800257a:	a902      	add	r1, sp, #8
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_7);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7);


	/* GPIOB Configuration:  USART3 RX on PB11 and TX on PB10 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
 800257c:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 800257e:	f88d 900f 	strb.w	r9, [sp, #15]
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7);


	/* GPIOB Configuration:  USART3 RX on PB11 and TX on PB10 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002582:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002586:	f88d 600d 	strb.w	r6, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800258a:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800258e:	f001 fa15 	bl	80039bc <GPIO_Init>

	/* Connect USART3 pins to AF7  */
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_7);
 8002592:	4638      	mov	r0, r7
 8002594:	210a      	movs	r1, #10
 8002596:	2207      	movs	r2, #7
 8002598:	f001 fa93 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_7);
 800259c:	4638      	mov	r0, r7
 800259e:	210b      	movs	r1, #11
 80025a0:	2207      	movs	r2, #7
 80025a2:	f001 fa8e 	bl	8003ac2 <GPIO_PinAFConfig>


	/*************************END USART***************************/

	/******************************* SPI config ********************************/
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_5);
 80025a6:	2105      	movs	r1, #5
 80025a8:	460a      	mov	r2, r1
 80025aa:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80025ae:	f001 fa88 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_5);
 80025b2:	2106      	movs	r1, #6
 80025b4:	2205      	movs	r2, #5
 80025b6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80025ba:	f001 fa82 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_5);
 80025be:	2205      	movs	r2, #5
 80025c0:	2107      	movs	r1, #7
 80025c2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80025c6:	f001 fa7c 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 80025ca:	2320      	movs	r3, #32
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025cc:	a902      	add	r1, sp, #8
 80025ce:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 80025d2:	9302      	str	r3, [sp, #8]
	/******************************* SPI config ********************************/
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_5);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_5);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_5);

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80025d4:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80025d8:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
 80025dc:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80025e0:	f88d 600d 	strb.w	r6, [sp, #13]

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025e4:	f001 f9ea 	bl	80039bc <GPIO_Init>

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 80025e8:	2340      	movs	r3, #64	; 0x40
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025ea:	a902      	add	r1, sp, #8
 80025ec:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 80025f0:	9302      	str	r3, [sp, #8]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025f2:	9301      	str	r3, [sp, #4]

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 80025f4:	f04f 0b80 	mov.w	fp, #128	; 0x80
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025f8:	f001 f9e0 	bl	80039bc <GPIO_Init>

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025fc:	a902      	add	r1, sp, #8
 80025fe:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 8002602:	f8cd b008 	str.w	fp, [sp, #8]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002606:	f001 f9d9 	bl	80039bc <GPIO_Init>
	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 800260a:	f8dd c000 	ldr.w	ip, [sp]
	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
 800260e:	f04f 0a08 	mov.w	sl, #8
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8002612:	4660      	mov	r0, ip
 8002614:	eb0d 010a 	add.w	r1, sp, sl
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002618:	f88d 900c 	strb.w	r9, [sp, #12]
	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
 800261c:	f8cd a008 	str.w	sl, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002620:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002624:	f88d 600d 	strb.w	r6, [sp, #13]
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8002628:	f001 f9c8 	bl	80039bc <GPIO_Init>
	/******************************* END SPI ********************************/

	/****************************** I2C *************************************/
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6 , GPIO_AF_4 );
 800262c:	4638      	mov	r0, r7
 800262e:	2106      	movs	r1, #6
 8002630:	2204      	movs	r2, #4
 8002632:	f001 fa46 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7 , GPIO_AF_4 );
 8002636:	2204      	movs	r2, #4
 8002638:	4638      	mov	r0, r7
 800263a:	2107      	movs	r1, #7
 800263c:	f001 fa41 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 8002640:	9b01      	ldr	r3, [sp, #4]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002642:	4638      	mov	r0, r7
 8002644:	eb0d 010a 	add.w	r1, sp, sl
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 8002648:	9302      	str	r3, [sp, #8]

	/****************************** I2C *************************************/
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6 , GPIO_AF_4 );
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7 , GPIO_AF_4 );

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800264a:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800264e:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
 8002652:	f88d 500f 	strb.w	r5, [sp, #15]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002656:	f88d 600d 	strb.w	r6, [sp, #13]

	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800265a:	f001 f9af 	bl	80039bc <GPIO_Init>

	/* I2C SDA pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800265e:	4638      	mov	r0, r7
 8002660:	eb0d 010a 	add.w	r1, sp, sl
	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* I2C SDA pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 8002664:	f8cd b008 	str.w	fp, [sp, #8]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002668:	f001 f9a8 	bl	80039bc <GPIO_Init>
	/****************************** END I2C **********************************/

	/****************************** TIM3 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
 800266c:	f44f 7370 	mov.w	r3, #960	; 0x3c0
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002670:	4640      	mov	r0, r8
 8002672:	eb0d 010a 	add.w	r1, sp, sl
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	/****************************** END I2C **********************************/

	/****************************** TIM3 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
 8002676:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 8002678:	f88d 900f 	strb.w	r9, [sp, #15]
	/****************************** END I2C **********************************/

	/****************************** TIM3 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800267c:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002680:	f88d 600d 	strb.w	r6, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002684:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002688:	f001 f998 	bl	80039bc <GPIO_Init>

	GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_2);
 800268c:	4640      	mov	r0, r8
 800268e:	2106      	movs	r1, #6
 8002690:	462a      	mov	r2, r5
 8002692:	f001 fa16 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_2);
 8002696:	4640      	mov	r0, r8
 8002698:	2107      	movs	r1, #7
 800269a:	462a      	mov	r2, r5
 800269c:	f001 fa11 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource8, GPIO_AF_2);
 80026a0:	4640      	mov	r0, r8
 80026a2:	4651      	mov	r1, sl
 80026a4:	462a      	mov	r2, r5
 80026a6:	f001 fa0c 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource9, GPIO_AF_2);
 80026aa:	462a      	mov	r2, r5
 80026ac:	4640      	mov	r0, r8
 80026ae:	2109      	movs	r1, #9
 80026b0:	f001 fa07 	bl	8003ac2 <GPIO_PinAFConfig>
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_6 | GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 80026b4:	f88d 900f 	strb.w	r9, [sp, #15]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 80026b8:	f8df 9098 	ldr.w	r9, [pc, #152]	; 8002754 <GPIO_Configuration+0x270>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource9, GPIO_AF_2);
	/****************************** END TIM3 PWM OUT *************************/

	/****************************** TIM2 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_6 | GPIO_Pin_7;
 80026bc:	23d8      	movs	r3, #216	; 0xd8
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 80026be:	4648      	mov	r0, r9
 80026c0:	eb0d 010a 	add.w	r1, sp, sl
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource9, GPIO_AF_2);
	/****************************** END TIM3 PWM OUT *************************/

	/****************************** TIM2 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_6 | GPIO_Pin_7;
 80026c4:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80026c6:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80026ca:	f88d 600d 	strb.w	r6, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80026ce:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 80026d2:	f001 f973 	bl	80039bc <GPIO_Init>

	GPIO_PinAFConfig(GPIOD, GPIO_PinSource3, GPIO_AF_2);
 80026d6:	4648      	mov	r0, r9
 80026d8:	4631      	mov	r1, r6
 80026da:	462a      	mov	r2, r5
 80026dc:	f001 f9f1 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_2);
 80026e0:	4648      	mov	r0, r9
 80026e2:	2104      	movs	r1, #4
 80026e4:	462a      	mov	r2, r5
 80026e6:	f001 f9ec 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_2);
 80026ea:	4648      	mov	r0, r9
 80026ec:	2106      	movs	r1, #6
 80026ee:	462a      	mov	r2, r5
 80026f0:	f001 f9e7 	bl	8003ac2 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOD, GPIO_PinSource7, GPIO_AF_2);
 80026f4:	462a      	mov	r2, r5
 80026f6:	4648      	mov	r0, r9
 80026f8:	2107      	movs	r1, #7
 80026fa:	f001 f9e2 	bl	8003ac2 <GPIO_PinAFConfig>
	/****************************** END TIM3 PWM OUT *************************/

	/* EXTI Lines */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
 80026fe:	f44f 4370 	mov.w	r3, #61440	; 0xf000
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8002702:	4648      	mov	r0, r9
 8002704:	eb0d 010a 	add.w	r1, sp, sl
	GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_2);
	GPIO_PinAFConfig(GPIOD, GPIO_PinSource7, GPIO_AF_2);
	/****************************** END TIM3 PWM OUT *************************/

	/* EXTI Lines */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
 8002708:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
 800270a:	f88d 400c 	strb.w	r4, [sp, #12]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800270e:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8002712:	f001 f953 	bl	80039bc <GPIO_Init>

	/* ADC Config */
	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
 8002716:	2330      	movs	r3, #48	; 0x30
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002718:	4640      	mov	r0, r8
 800271a:	eb0d 010a 	add.w	r1, sp, sl
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure);

	/* ADC Config */
	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
 800271e:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8002720:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8002724:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002728:	f001 f948 	bl	80039bc <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 ;
 800272c:	2304      	movs	r3, #4
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800272e:	4638      	mov	r0, r7
 8002730:	eb0d 010a 	add.w	r1, sp, sl
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOC, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 ;
 8002734:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8002736:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 800273a:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800273e:	f001 f93d 	bl	80039bc <GPIO_Init>
}
 8002742:	b005      	add	sp, #20
 8002744:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002748:	48000400 	.word	0x48000400
 800274c:	48001000 	.word	0x48001000
 8002750:	48000800 	.word	0x48000800
 8002754:	48000c00 	.word	0x48000c00

08002758 <USART_Configuration>:


void USART_Configuration(void)
{
 8002758:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART2, &USART_InitStructure);
 800275c:	4d1c      	ldr	r5, [pc, #112]	; (80027d0 <USART_Configuration+0x78>)
	GPIO_Init(GPIOB, &GPIO_InitStructure);
}


void USART_Configuration(void)
{
 800275e:	b086      	sub	sp, #24
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART2, &USART_InitStructure);

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt
 8002760:	4e1c      	ldr	r6, [pc, #112]	; (80027d4 <USART_Configuration+0x7c>)
void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8002762:	2400      	movs	r4, #0

void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
 8002764:	f44f 38e1 	mov.w	r8, #115200	; 0x1c200
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 8002768:	270c      	movs	r7, #12
	USART_Init(USART2, &USART_InitStructure);
 800276a:	4628      	mov	r0, r5
 800276c:	4669      	mov	r1, sp

void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
 800276e:	f8cd 8000 	str.w	r8, [sp]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8002772:	9401      	str	r4, [sp, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8002774:	9402      	str	r4, [sp, #8]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8002776:	9403      	str	r4, [sp, #12]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8002778:	9405      	str	r4, [sp, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 800277a:	9704      	str	r7, [sp, #16]
	USART_Init(USART2, &USART_InitStructure);
 800277c:	f002 ff4e 	bl	800561c <USART_Init>

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt
 8002780:	2201      	movs	r2, #1
 8002782:	4628      	mov	r0, r5
 8002784:	4631      	mov	r1, r6
 8002786:	f003 f8fb 	bl	8005980 <USART_ITConfig>

	USART_Cmd(USART2, ENABLE); // enable USART2
 800278a:	4628      	mov	r0, r5
 800278c:	2101      	movs	r1, #1
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART3, &USART_InitStructure);
 800278e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART2, &USART_InitStructure);

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt

	USART_Cmd(USART2, ENABLE); // enable USART2
 8002792:	f002 ffbe 	bl	8005712 <USART_Cmd>
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART3, &USART_InitStructure);
 8002796:	4628      	mov	r0, r5
 8002798:	4669      	mov	r1, sp

	/*
	 * Configure USART 3
	 * */
	//USART_InitTypeDef USART_InitStructure;
	USART_InitStructure.USART_BaudRate = 115200;
 800279a:	f8cd 8000 	str.w	r8, [sp]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800279e:	9401      	str	r4, [sp, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 80027a0:	9402      	str	r4, [sp, #8]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 80027a2:	9403      	str	r4, [sp, #12]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 80027a4:	9405      	str	r4, [sp, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 80027a6:	9704      	str	r7, [sp, #16]
	USART_Init(USART3, &USART_InitStructure);
 80027a8:	f002 ff38 	bl	800561c <USART_Init>

	USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);
 80027ac:	4628      	mov	r0, r5
 80027ae:	4631      	mov	r1, r6
 80027b0:	4622      	mov	r2, r4
 80027b2:	f003 f8e5 	bl	8005980 <USART_ITConfig>
	USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 80027b6:	4628      	mov	r0, r5
 80027b8:	4907      	ldr	r1, [pc, #28]	; (80027d8 <USART_Configuration+0x80>)
 80027ba:	4622      	mov	r2, r4
 80027bc:	f003 f8e0 	bl	8005980 <USART_ITConfig>

	USART_Cmd(USART3, ENABLE); // enable USART3
 80027c0:	4628      	mov	r0, r5
 80027c2:	2101      	movs	r1, #1
 80027c4:	f002 ffa5 	bl	8005712 <USART_Cmd>
}
 80027c8:	b006      	add	sp, #24
 80027ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80027ce:	bf00      	nop
 80027d0:	40004400 	.word	0x40004400
 80027d4:	00050105 	.word	0x00050105
 80027d8:	00070107 	.word	0x00070107

080027dc <SPI_Configuration>:


void SPI_Configuration(void)
{
 80027dc:	b510      	push	{r4, lr}
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
 80027de:	4c17      	ldr	r4, [pc, #92]	; (800283c <SPI_Configuration+0x60>)
	USART_Cmd(USART3, ENABLE); // enable USART3
}


void SPI_Configuration(void)
{
 80027e0:	b086      	sub	sp, #24
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
 80027e2:	4620      	mov	r0, r4
 80027e4:	f001 fe88 	bl	80044f8 <SPI_I2S_DeInit>
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 80027e8:	2300      	movs	r3, #0
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 80027ea:	f44f 62e0 	mov.w	r2, #1792	; 0x700
void SPI_Configuration(void)
{
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 80027ee:	f8ad 3004 	strh.w	r3, [sp, #4]
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 80027f2:	f8ad 2008 	strh.w	r2, [sp, #8]
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 80027f6:	f8ad 300a 	strh.w	r3, [sp, #10]
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 80027fa:	f8ad 300c 	strh.w	r3, [sp, #12]
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 80027fe:	f8ad 3012 	strh.w	r3, [sp, #18]
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8002802:	f44f 7200 	mov.w	r2, #512	; 0x200
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 8002806:	2307      	movs	r3, #7
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8002808:	f8ad 200e 	strh.w	r2, [sp, #14]
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 800280c:	f8ad 3014 	strh.w	r3, [sp, #20]
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 8002810:	2210      	movs	r2, #16
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8002812:	f44f 7382 	mov.w	r3, #260	; 0x104
	SPI_Init(SPI1, &SPI_InitStructure);
 8002816:	4620      	mov	r0, r4
 8002818:	a901      	add	r1, sp, #4
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 800281a:	f8ad 2010 	strh.w	r2, [sp, #16]
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 800281e:	f8ad 3006 	strh.w	r3, [sp, #6]
	SPI_Init(SPI1, &SPI_InitStructure);
 8002822:	f001 fea9 	bl	8004578 <SPI_Init>

	/* Configure the RX FIFO Threshold */
	SPI_RxFIFOThresholdConfig(SPI1, SPI_RxFIFOThreshold_QF);
 8002826:	4620      	mov	r0, r4
 8002828:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800282c:	f001 ff6a 	bl	8004704 <SPI_RxFIFOThresholdConfig>
	/* Enable SPI1  */
	SPI_Cmd(SPI1, ENABLE);
 8002830:	4620      	mov	r0, r4
 8002832:	2101      	movs	r1, #1
 8002834:	f001 ff3a 	bl	80046ac <SPI_Cmd>
}
 8002838:	b006      	add	sp, #24
 800283a:	bd10      	pop	{r4, pc}
 800283c:	40013000 	.word	0x40013000

08002840 <I2C_Configuration>:


void I2C_Configuration(void)
{
 8002840:	b510      	push	{r4, lr}
	I2C_InitTypeDef  I2C_InitStructure;

	I2C_DeInit(I2C1);
 8002842:	4c0c      	ldr	r4, [pc, #48]	; (8002874 <I2C_Configuration+0x34>)
	SPI_Cmd(SPI1, ENABLE);
}


void I2C_Configuration(void)
{
 8002844:	b088      	sub	sp, #32
	I2C_InitTypeDef  I2C_InitStructure;

	I2C_DeInit(I2C1);
 8002846:	4620      	mov	r0, r4
 8002848:	f001 f952 	bl	8003af0 <I2C_DeInit>

    /* I2C configuration -------------------------------------------------------*/
    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 800284c:	2300      	movs	r3, #0
 800284e:	9304      	str	r3, [sp, #16]
    I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
 8002850:	9302      	str	r3, [sp, #8]
    I2C_InitStructure.I2C_DigitalFilter = 0x00;
 8002852:	9303      	str	r3, [sp, #12]
    I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 8002854:	9305      	str	r3, [sp, #20]
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8002856:	9306      	str	r3, [sp, #24]
    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8002858:	9307      	str	r3, [sp, #28]
    I2C_InitStructure.I2C_Timing = 0x00902025;
 800285a:	4b07      	ldr	r3, [pc, #28]	; (8002878 <I2C_Configuration+0x38>)
 800285c:	a908      	add	r1, sp, #32
 800285e:	f841 3d1c 	str.w	r3, [r1, #-28]!

    /* Apply LSM303DLHC_I2C configuration after enabling it */
    I2C_Init(I2C1, &I2C_InitStructure);
 8002862:	4620      	mov	r0, r4
 8002864:	f001 f95e 	bl	8003b24 <I2C_Init>

    /* LSM303DLHC_I2C Peripheral Enable */
    I2C_Cmd(I2C1, ENABLE);
 8002868:	4620      	mov	r0, r4
 800286a:	2101      	movs	r1, #1
 800286c:	f001 f995 	bl	8003b9a <I2C_Cmd>
}
 8002870:	b008      	add	sp, #32
 8002872:	bd10      	pop	{r4, pc}
 8002874:	40005400 	.word	0x40005400
 8002878:	00902025 	.word	0x00902025

0800287c <DMA_Configuration>:


void DMA_Configuration(uint8_t *buffer)
{
 800287c:	b530      	push	{r4, r5, lr}
	DMA_DeInit(DMA1_Channel7);
 800287e:	4c0f      	ldr	r4, [pc, #60]	; (80028bc <DMA_Configuration+0x40>)
    I2C_Cmd(I2C1, ENABLE);
}


void DMA_Configuration(uint8_t *buffer)
{
 8002880:	b08d      	sub	sp, #52	; 0x34
 8002882:	4605      	mov	r5, r0
	DMA_DeInit(DMA1_Channel7);
 8002884:	4620      	mov	r0, r4
 8002886:	f000 fe65 	bl	8003554 <DMA_DeInit>
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
 800288a:	4b0d      	ldr	r3, [pc, #52]	; (80028c0 <DMA_Configuration+0x44>)
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
 800288c:	2280      	movs	r2, #128	; 0x80

void DMA_Configuration(uint8_t *buffer)
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
 800288e:	9301      	str	r3, [sp, #4]
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
 8002890:	9206      	str	r2, [sp, #24]
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
 8002892:	2306      	movs	r3, #6
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
 8002894:	2220      	movs	r2, #32
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
 8002896:	f8ad 3010 	strh.w	r3, [sp, #16]
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
 800289a:	9209      	str	r2, [sp, #36]	; 0x24
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
 800289c:	2300      	movs	r3, #0
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority           = DMA_Priority_VeryHigh;
 800289e:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    DMA_InitStructure.DMA_M2M                = DMA_M2M_Disable;
    DMA_Init(DMA1_Channel7, &DMA_InitStructure);
 80028a2:	4620      	mov	r0, r4
 80028a4:	a901      	add	r1, sp, #4
void DMA_Configuration(uint8_t *buffer)
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
 80028a6:	9502      	str	r5, [sp, #8]
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
 80028a8:	9303      	str	r3, [sp, #12]
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
 80028aa:	9305      	str	r3, [sp, #20]
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 80028ac:	9307      	str	r3, [sp, #28]
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
 80028ae:	9308      	str	r3, [sp, #32]
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority           = DMA_Priority_VeryHigh;
 80028b0:	920a      	str	r2, [sp, #40]	; 0x28
    DMA_InitStructure.DMA_M2M                = DMA_M2M_Disable;
 80028b2:	930b      	str	r3, [sp, #44]	; 0x2c
    DMA_Init(DMA1_Channel7, &DMA_InitStructure);
 80028b4:	f000 feca 	bl	800364c <DMA_Init>

    //DMA_Cmd(DMA1_Channel1, ENABLE);
}
 80028b8:	b00d      	add	sp, #52	; 0x34
 80028ba:	bd30      	pop	{r4, r5, pc}
 80028bc:	40020080 	.word	0x40020080
 80028c0:	40005424 	.word	0x40005424

080028c4 <TIM2_PWM_Configuration>:


void TIM2_PWM_Configuration(void)
{
 80028c4:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 80028c6:	4b30      	ldr	r3, [pc, #192]	; (8002988 <TIM2_PWM_Configuration+0xc4>)
    //DMA_Cmd(DMA1_Channel1, ENABLE);
}


void TIM2_PWM_Configuration(void)
{
 80028c8:	b085      	sub	sp, #20
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 80028ca:	681c      	ldr	r4, [r3, #0]
 80028cc:	4b2f      	ldr	r3, [pc, #188]	; (800298c <TIM2_PWM_Configuration+0xc8>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80028ce:	a801      	add	r0, sp, #4
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 80028d0:	fbb4 f4f3 	udiv	r4, r4, r3
 80028d4:	3c01      	subs	r4, #1

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80028d6:	f002 f983 	bl	8004be0 <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 80028da:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 80028de:	4c2c      	ldr	r4, [pc, #176]	; (8002990 <TIM2_PWM_Configuration+0xcc>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80028e0:	2700      	movs	r7, #0
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 80028e2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 80028e6:	a901      	add	r1, sp, #4
 80028e8:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80028ec:	2501      	movs	r5, #1
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 80028ee:	f44f 7696 	mov.w	r6, #300	; 0x12c
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 80028f2:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80028f4:	f8ad 700c 	strh.w	r7, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80028f8:	f8ad 7006 	strh.w	r7, [sp, #6]
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 80028fc:	f002 f92a 	bl	8004b54 <TIM_TimeBaseInit>

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8002900:	2360      	movs	r3, #96	; 0x60
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
 8002902:	4621      	mov	r1, r4
 8002904:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8002908:	6023      	str	r3, [r4, #0]
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 800290a:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 800290c:	60a6      	str	r6, [r4, #8]
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 800290e:	81a7      	strh	r7, [r4, #12]
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
 8002910:	f002 f9d5 	bl	8004cbe <TIM_OC1Init>
	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);
 8002914:	2108      	movs	r1, #8
 8002916:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800291a:	f002 fb6e 	bl	8004ffa <TIM_OC1PreloadConfig>

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
 800291e:	4621      	mov	r1, r4
 8002920:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002924:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 8002926:	60a6      	str	r6, [r4, #8]
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
 8002928:	f002 fa06 	bl	8004d38 <TIM_OC2Init>
	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);
 800292c:	2108      	movs	r1, #8
 800292e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002932:	f002 fb68 	bl	8005006 <TIM_OC2PreloadConfig>

	/* PWM1 Mode configuration: Channel3 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
 8002936:	4621      	mov	r1, r4
 8002938:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel3 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 800293c:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 800293e:	60a6      	str	r6, [r4, #8]
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
 8002940:	f002 fa30 	bl	8004da4 <TIM_OC3Init>
	TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);
 8002944:	2108      	movs	r1, #8
 8002946:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800294a:	f002 fb63 	bl	8005014 <TIM_OC3PreloadConfig>

	/* PWM1 Mode configuration: Channel4 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC4Init(TIM2, &TIM_OCInitStructure);
 800294e:	4621      	mov	r1, r4
 8002950:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
	TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel4 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002954:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 8002956:	60a6      	str	r6, [r4, #8]
	TIM_OC4Init(TIM2, &TIM_OCInitStructure);
 8002958:	f002 fa58 	bl	8004e0c <TIM_OC4Init>
	TIM_OC4PreloadConfig(TIM2, TIM_OCPreload_Enable);
 800295c:	2108      	movs	r1, #8
 800295e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002962:	f002 fb5d 	bl	8005020 <TIM_OC4PreloadConfig>

	TIM_ARRPreloadConfig(TIM2, ENABLE);
 8002966:	4629      	mov	r1, r5
 8002968:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800296c:	f002 f979 	bl	8004c62 <TIM_ARRPreloadConfig>
	TIM_CtrlPWMOutputs(TIM2, ENABLE);
 8002970:	4629      	mov	r1, r5
 8002972:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002976:	f002 fd10 	bl	800539a <TIM_CtrlPWMOutputs>

	/* TIM3 enable counter */
	TIM_Cmd(TIM2, ENABLE);
 800297a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800297e:	4629      	mov	r1, r5
 8002980:	f002 f991 	bl	8004ca6 <TIM_Cmd>
}
 8002984:	b005      	add	sp, #20
 8002986:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002988:	20000034 	.word	0x20000034
 800298c:	000493e0 	.word	0x000493e0
 8002990:	2000017c 	.word	0x2000017c

08002994 <TIM3_PWM_Configuration>:


void TIM3_PWM_Configuration(void)
{
 8002994:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 8002998:	4b2d      	ldr	r3, [pc, #180]	; (8002a50 <TIM3_PWM_Configuration+0xbc>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 800299a:	a801      	add	r0, sp, #4
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 800299c:	681c      	ldr	r4, [r3, #0]
 800299e:	4b2d      	ldr	r3, [pc, #180]	; (8002a54 <TIM3_PWM_Configuration+0xc0>)
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 80029a0:	4d2d      	ldr	r5, [pc, #180]	; (8002a58 <TIM3_PWM_Configuration+0xc4>)
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 80029a2:	fbb4 f4f3 	udiv	r4, r4, r3
 80029a6:	3c01      	subs	r4, #1

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80029a8:	f002 f91a 	bl	8004be0 <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 80029ac:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 80029b0:	4c2a      	ldr	r4, [pc, #168]	; (8002a5c <TIM3_PWM_Configuration+0xc8>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80029b2:	2700      	movs	r7, #0
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 80029b4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 80029b8:	4620      	mov	r0, r4
 80029ba:	a901      	add	r1, sp, #4
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 80029bc:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80029be:	f8ad 700c 	strh.w	r7, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80029c2:	f8ad 7006 	strh.w	r7, [sp, #6]
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 80029c6:	f002 f8c5 	bl	8004b54 <TIM_TimeBaseInit>

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 80029ca:	842f      	strh	r7, [r5, #32]
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 80029cc:	f105 0714 	add.w	r7, r5, #20
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 80029d0:	2360      	movs	r3, #96	; 0x60
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80029d2:	2601      	movs	r6, #1
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 80029d4:	f44f 7896 	mov.w	r8, #300	; 0x12c
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 80029d8:	4620      	mov	r0, r4
 80029da:	4639      	mov	r1, r7
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 80029dc:	616b      	str	r3, [r5, #20]
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80029de:	832e      	strh	r6, [r5, #24]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 80029e0:	f8c5 801c 	str.w	r8, [r5, #28]
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 80029e4:	f002 f96b 	bl	8004cbe <TIM_OC1Init>
	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);
 80029e8:	4620      	mov	r0, r4
 80029ea:	2108      	movs	r1, #8
 80029ec:	f002 fb05 	bl	8004ffa <TIM_OC1PreloadConfig>

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC2Init(TIM3, &TIM_OCInitStructure);
 80029f0:	4620      	mov	r0, r4
 80029f2:	4639      	mov	r1, r7
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80029f4:	832e      	strh	r6, [r5, #24]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 80029f6:	f8c5 801c 	str.w	r8, [r5, #28]
	TIM_OC2Init(TIM3, &TIM_OCInitStructure);
 80029fa:	f002 f99d 	bl	8004d38 <TIM_OC2Init>
	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);
 80029fe:	4620      	mov	r0, r4
 8002a00:	2108      	movs	r1, #8
 8002a02:	f002 fb00 	bl	8005006 <TIM_OC2PreloadConfig>

	/* PWM1 Mode configuration: Channel3 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC3Init(TIM3, &TIM_OCInitStructure);
 8002a06:	4620      	mov	r0, r4
 8002a08:	4639      	mov	r1, r7
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC2Init(TIM3, &TIM_OCInitStructure);
	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel3 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002a0a:	832e      	strh	r6, [r5, #24]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 8002a0c:	f8c5 801c 	str.w	r8, [r5, #28]
	TIM_OC3Init(TIM3, &TIM_OCInitStructure);
 8002a10:	f002 f9c8 	bl	8004da4 <TIM_OC3Init>
	TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);
 8002a14:	4620      	mov	r0, r4
 8002a16:	2108      	movs	r1, #8
 8002a18:	f002 fafc 	bl	8005014 <TIM_OC3PreloadConfig>

	/* PWM1 Mode configuration: Channel4 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC4Init(TIM3, &TIM_OCInitStructure);
 8002a1c:	4620      	mov	r0, r4
 8002a1e:	4639      	mov	r1, r7
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC3Init(TIM3, &TIM_OCInitStructure);
	TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel4 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002a20:	832e      	strh	r6, [r5, #24]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 8002a22:	f8c5 801c 	str.w	r8, [r5, #28]
	TIM_OC4Init(TIM3, &TIM_OCInitStructure);
 8002a26:	f002 f9f1 	bl	8004e0c <TIM_OC4Init>
	TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable);
 8002a2a:	4620      	mov	r0, r4
 8002a2c:	2108      	movs	r1, #8
 8002a2e:	f002 faf7 	bl	8005020 <TIM_OC4PreloadConfig>

	TIM_ARRPreloadConfig(TIM3, ENABLE);
 8002a32:	4620      	mov	r0, r4
 8002a34:	4631      	mov	r1, r6
 8002a36:	f002 f914 	bl	8004c62 <TIM_ARRPreloadConfig>
	TIM_CtrlPWMOutputs(TIM3, ENABLE);
 8002a3a:	4620      	mov	r0, r4
 8002a3c:	4631      	mov	r1, r6
 8002a3e:	f002 fcac 	bl	800539a <TIM_CtrlPWMOutputs>

	/* TIM3 enable counter */
	TIM_Cmd(TIM3, ENABLE);
 8002a42:	4620      	mov	r0, r4
 8002a44:	4631      	mov	r1, r6
 8002a46:	f002 f92e 	bl	8004ca6 <TIM_Cmd>
}
 8002a4a:	e8bd 81ff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}
 8002a4e:	bf00      	nop
 8002a50:	20000034 	.word	0x20000034
 8002a54:	000493e0 	.word	0x000493e0
 8002a58:	2000017c 	.word	0x2000017c
 8002a5c:	40000400 	.word	0x40000400

08002a60 <TIM4_Configuration>:


void TIM4_Configuration(void)
{
 8002a60:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
 8002a62:	4b0f      	ldr	r3, [pc, #60]	; (8002aa0 <TIM4_Configuration+0x40>)
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 8002a64:	a801      	add	r0, sp, #4
{
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
 8002a66:	681c      	ldr	r4, [r3, #0]
 8002a68:	f24c 3350 	movw	r3, #50000	; 0xc350
 8002a6c:	fbb4 f4f3 	udiv	r4, r4, r3
 8002a70:	3c01      	subs	r4, #1
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 8002a72:	f002 f8b5 	bl	8004be0 <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 8002a76:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 8002a7a:	4c0a      	ldr	r4, [pc, #40]	; (8002aa4 <TIM4_Configuration+0x44>)

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 8002a7c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8002a80:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 8002a82:	4620      	mov	r0, r4
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8002a84:	2300      	movs	r3, #0
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 8002a86:	a901      	add	r1, sp, #4
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8002a88:	f8ad 300c 	strh.w	r3, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8002a8c:	f8ad 3006 	strh.w	r3, [sp, #6]
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 8002a90:	f002 f860 	bl	8004b54 <TIM_TimeBaseInit>

	/* TIM3 enable counter */
	TIM_Cmd(TIM4, ENABLE);
 8002a94:	4620      	mov	r0, r4
 8002a96:	2101      	movs	r1, #1
 8002a98:	f002 f905 	bl	8004ca6 <TIM_Cmd>
}
 8002a9c:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8002a9e:	bf00      	nop
 8002aa0:	20000034 	.word	0x20000034
 8002aa4:	40000800 	.word	0x40000800

08002aa8 <getEXTI_Config>:

EXTI_InitTypeDef *getEXTI_Config(void)
{
	static EXTI_InitTypeDef   EXTI_InitStructure;
	return &EXTI_InitStructure;
}
 8002aa8:	4800      	ldr	r0, [pc, #0]	; (8002aac <getEXTI_Config+0x4>)
 8002aaa:	4770      	bx	lr
 8002aac:	200001a4 	.word	0x200001a4

08002ab0 <EXTI_Configuration>:

void EXTI_Configuration(void)
{
 8002ab0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	EXTI_InitTypeDef   *EXTI_InitStructure = getEXTI_Config();

	/* Connect EXTI0 Line to PA0 pin */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource12);
 8002ab4:	2003      	movs	r0, #3
 8002ab6:	210c      	movs	r1, #12
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource13);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource14);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource15);

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line12;
 8002ab8:	4c21      	ldr	r4, [pc, #132]	; (8002b40 <EXTI_Configuration+0x90>)
void EXTI_Configuration(void)
{
	EXTI_InitTypeDef   *EXTI_InitStructure = getEXTI_Config();

	/* Connect EXTI0 Line to PA0 pin */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource12);
 8002aba:	f001 ff5d 	bl	8004978 <SYSCFG_EXTILineConfig>
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource13);
 8002abe:	2003      	movs	r0, #3
 8002ac0:	210d      	movs	r1, #13
 8002ac2:	f001 ff59 	bl	8004978 <SYSCFG_EXTILineConfig>
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource14);
 8002ac6:	2003      	movs	r0, #3
 8002ac8:	210e      	movs	r1, #14
 8002aca:	f001 ff55 	bl	8004978 <SYSCFG_EXTILineConfig>


EXTI_InitTypeDef *getEXTI_Config(void)
{
	static EXTI_InitTypeDef   EXTI_InitStructure;
	return &EXTI_InitStructure;
 8002ace:	f104 0528 	add.w	r5, r4, #40	; 0x28

	/* Connect EXTI0 Line to PA0 pin */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource12);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource13);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource14);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource15);
 8002ad2:	210f      	movs	r1, #15
 8002ad4:	2003      	movs	r0, #3
 8002ad6:	f001 ff4f 	bl	8004978 <SYSCFG_EXTILineConfig>

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line12;
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
 8002ada:	f04f 0800 	mov.w	r8, #0
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8002ade:	2710      	movs	r7, #16
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
 8002ae0:	2601      	movs	r6, #1
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource13);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource14);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource15);

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line12;
 8002ae2:	230c      	movs	r3, #12
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
	EXTI_Init(EXTI_InitStructure);
 8002ae4:	4628      	mov	r0, r5
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource13);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource14);
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource15);

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line12;
 8002ae6:	62a3      	str	r3, [r4, #40]	; 0x28
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
 8002ae8:	f884 802c 	strb.w	r8, [r4, #44]	; 0x2c
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8002aec:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
 8002af0:	f884 602e 	strb.w	r6, [r4, #46]	; 0x2e
	EXTI_Init(EXTI_InitStructure);
 8002af4:	f000 fe36 	bl	8003764 <EXTI_Init>

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line13;
 8002af8:	230d      	movs	r3, #13
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
	EXTI_Init(EXTI_InitStructure);
 8002afa:	4628      	mov	r0, r5
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
	EXTI_Init(EXTI_InitStructure);

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line13;
 8002afc:	62a3      	str	r3, [r4, #40]	; 0x28
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
 8002afe:	f884 802c 	strb.w	r8, [r4, #44]	; 0x2c
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8002b02:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
 8002b06:	f884 602e 	strb.w	r6, [r4, #46]	; 0x2e
	EXTI_Init(EXTI_InitStructure);
 8002b0a:	f000 fe2b 	bl	8003764 <EXTI_Init>

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line14;
 8002b0e:	230e      	movs	r3, #14
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
	EXTI_Init(EXTI_InitStructure);
 8002b10:	4628      	mov	r0, r5
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
	EXTI_Init(EXTI_InitStructure);

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line14;
 8002b12:	62a3      	str	r3, [r4, #40]	; 0x28
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
 8002b14:	f884 802c 	strb.w	r8, [r4, #44]	; 0x2c
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8002b18:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
 8002b1c:	f884 602e 	strb.w	r6, [r4, #46]	; 0x2e
	EXTI_Init(EXTI_InitStructure);
 8002b20:	f000 fe20 	bl	8003764 <EXTI_Init>

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line15;
 8002b24:	230f      	movs	r3, #15
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
	EXTI_Init(EXTI_InitStructure);
 8002b26:	4628      	mov	r0, r5
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
	EXTI_Init(EXTI_InitStructure);

	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line15;
 8002b28:	62a3      	str	r3, [r4, #40]	; 0x28
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
 8002b2a:	f884 802c 	strb.w	r8, [r4, #44]	; 0x2c
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8002b2e:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
 8002b32:	f884 602e 	strb.w	r6, [r4, #46]	; 0x2e
	EXTI_Init(EXTI_InitStructure);
}
 8002b36:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	/* Configure EXTI0 line */
	EXTI_InitStructure->EXTI_Line = EXTI_Line15;
	EXTI_InitStructure->EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure->EXTI_LineCmd = ENABLE;
	EXTI_Init(EXTI_InitStructure);
 8002b3a:	f000 be13 	b.w	8003764 <EXTI_Init>
 8002b3e:	bf00      	nop
 8002b40:	2000017c 	.word	0x2000017c

08002b44 <ADC_Configuration>:
}



void ADC_Configuration(void)
{
 8002b44:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002b46:	b097      	sub	sp, #92	; 0x5c
	__IO uint16_t  calibration_value = 0;
 8002b48:	2400      	movs	r4, #0

	ADC_InitTypeDef       ADC_InitStructure;
	ADC_CommonInitTypeDef ADC_CommonInitStructure;
	ADC_InjectedInitTypeDef ADC_InjInitStructure;

	ADC_StructInit(&ADC_InitStructure);
 8002b4a:	a80e      	add	r0, sp, #56	; 0x38



void ADC_Configuration(void)
{
	__IO uint16_t  calibration_value = 0;
 8002b4c:	f8ad 4006 	strh.w	r4, [sp, #6]

	ADC_InitTypeDef       ADC_InitStructure;
	ADC_CommonInitTypeDef ADC_CommonInitStructure;
	ADC_InjectedInitTypeDef ADC_InjInitStructure;

	ADC_StructInit(&ADC_InitStructure);
 8002b50:	f000 f9de 	bl	8002f10 <ADC_StructInit>

	/* Calibration procedure */
	ADC_VoltageRegulatorCmd(ADC2, ENABLE);
 8002b54:	2101      	movs	r1, #1
 8002b56:	4830      	ldr	r0, [pc, #192]	; (8002c18 <ADC_Configuration+0xd4>)
 8002b58:	f000 fa63 	bl	8003022 <ADC_VoltageRegulatorCmd>

	/* Insert delay equal to 10 µs */
	Delay(10);
 8002b5c:	200a      	movs	r0, #10
 8002b5e:	f7fe fbfb 	bl	8001358 <Delay>

	ADC_SelectCalibrationMode(ADC2, ADC_CalibrationMode_Single);
 8002b62:	482d      	ldr	r0, [pc, #180]	; (8002c18 <ADC_Configuration+0xd4>)
 8002b64:	4621      	mov	r1, r4
 8002b66:	f000 fa48 	bl	8002ffa <ADC_SelectCalibrationMode>
	ADC_StartCalibration(ADC2);
 8002b6a:	482b      	ldr	r0, [pc, #172]	; (8002c18 <ADC_Configuration+0xd4>)
 8002b6c:	f000 fa3a 	bl	8002fe4 <ADC_StartCalibration>

	while(ADC_GetCalibrationStatus(ADC2) != RESET );
 8002b70:	4829      	ldr	r0, [pc, #164]	; (8002c18 <ADC_Configuration+0xd4>)
 8002b72:	f000 fa4a 	bl	800300a <ADC_GetCalibrationStatus>
 8002b76:	4604      	mov	r4, r0
 8002b78:	2800      	cmp	r0, #0
 8002b7a:	d1f9      	bne.n	8002b70 <ADC_Configuration+0x2c>
	calibration_value = ADC_GetCalibrationValue(ADC2);
 8002b7c:	4826      	ldr	r0, [pc, #152]	; (8002c18 <ADC_Configuration+0xd4>)
 8002b7e:	f000 fa36 	bl	8002fee <ADC_GetCalibrationValue>

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_InjSimul;
 8002b82:	2605      	movs	r6, #5

	ADC_SelectCalibrationMode(ADC2, ADC_CalibrationMode_Single);
	ADC_StartCalibration(ADC2);

	while(ADC_GetCalibrationStatus(ADC2) != RESET );
	calibration_value = ADC_GetCalibrationValue(ADC2);
 8002b84:	f8ad 0006 	strh.w	r0, [sp, #6]
	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_InjSimul;
	ADC_CommonInitStructure.ADC_Clock = ADC_Clock_AsynClkMode;
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);
 8002b88:	a902      	add	r1, sp, #8
 8002b8a:	4823      	ldr	r0, [pc, #140]	; (8002c18 <ADC_Configuration+0xd4>)

	while(ADC_GetCalibrationStatus(ADC2) != RESET );
	calibration_value = ADC_GetCalibrationValue(ADC2);

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_InjSimul;
	ADC_CommonInitStructure.ADC_Clock = ADC_Clock_AsynClkMode;
 8002b8c:	9403      	str	r4, [sp, #12]
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8002b8e:	9404      	str	r4, [sp, #16]
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
 8002b90:	9405      	str	r4, [sp, #20]
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
 8002b92:	f88d 4018 	strb.w	r4, [sp, #24]
	ADC_StartCalibration(ADC2);

	while(ADC_GetCalibrationStatus(ADC2) != RESET );
	calibration_value = ADC_GetCalibrationValue(ADC2);

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_InjSimul;
 8002b96:	9602      	str	r6, [sp, #8]
	ADC_CommonInitStructure.ADC_Clock = ADC_Clock_AsynClkMode;
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);
 8002b98:	f000 f9e4 	bl	8002f64 <ADC_CommonInit>

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
 8002b9c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
 8002ba0:	2503      	movs	r5, #3
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
 8002ba2:	930e      	str	r3, [sp, #56]	; 0x38
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);
 8002ba4:	481c      	ldr	r0, [pc, #112]	; (8002c18 <ADC_Configuration+0xd4>)
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
 8002ba6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);
 8002baa:	a90e      	add	r1, sp, #56	; 0x38
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
 8002bac:	9314      	str	r3, [sp, #80]	; 0x50
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 8002bae:	940f      	str	r4, [sp, #60]	; 0x3c
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
 8002bb0:	9410      	str	r4, [sp, #64]	; 0x40
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
 8002bb2:	9411      	str	r4, [sp, #68]	; 0x44
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8002bb4:	9412      	str	r4, [sp, #72]	; 0x48
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
 8002bb6:	9413      	str	r4, [sp, #76]	; 0x4c

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
 8002bb8:	270b      	movs	r7, #11
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
 8002bba:	f88d 5054 	strb.w	r5, [sp, #84]	; 0x54
	ADC_Init(ADC2, &ADC_InitStructure);
 8002bbe:	f000 f989 	bl	8002ed4 <ADC_Init>

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
 8002bc2:	9407      	str	r4, [sp, #28]
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
 8002bc4:	9408      	str	r4, [sp, #32]
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 8002bc6:	4814      	ldr	r0, [pc, #80]	; (8002c18 <ADC_Configuration+0xd4>)
	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
 8002bc8:	240c      	movs	r4, #12
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 8002bca:	a907      	add	r1, sp, #28
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
 8002bcc:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
 8002bd0:	960a      	str	r6, [sp, #40]	; 0x28
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
 8002bd2:	970b      	str	r7, [sp, #44]	; 0x2c
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
 8002bd4:	940c      	str	r4, [sp, #48]	; 0x30
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 8002bd6:	f000 f9a6 	bl	8002f26 <ADC_InjectedInit>

	/* ADC1 regular channel7 configuration */
	//ADC_RegularChannelConfig(ADC2, ADC_Channel_5, 1, ADC_SampleTime_7Cycles5);
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_5, ADC_SampleTime_7Cycles5);
 8002bda:	480f      	ldr	r0, [pc, #60]	; (8002c18 <ADC_Configuration+0xd4>)
 8002bdc:	4631      	mov	r1, r6
 8002bde:	462a      	mov	r2, r5
 8002be0:	f000 fc1b 	bl	800341a <ADC_InjectedChannelSampleTimeConfig>
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_11,ADC_SampleTime_7Cycles5);
 8002be4:	480c      	ldr	r0, [pc, #48]	; (8002c18 <ADC_Configuration+0xd4>)
 8002be6:	4639      	mov	r1, r7
 8002be8:	462a      	mov	r2, r5
 8002bea:	f000 fc16 	bl	800341a <ADC_InjectedChannelSampleTimeConfig>
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_12,ADC_SampleTime_7Cycles5);
 8002bee:	480a      	ldr	r0, [pc, #40]	; (8002c18 <ADC_Configuration+0xd4>)
 8002bf0:	4621      	mov	r1, r4
 8002bf2:	462a      	mov	r2, r5
 8002bf4:	f000 fc11 	bl	800341a <ADC_InjectedChannelSampleTimeConfig>

	/* Enable ADC1 */
	ADC_Cmd(ADC2, ENABLE);
 8002bf8:	4807      	ldr	r0, [pc, #28]	; (8002c18 <ADC_Configuration+0xd4>)
 8002bfa:	2101      	movs	r1, #1
 8002bfc:	f000 f9e9 	bl	8002fd2 <ADC_Cmd>

	/* wait for ADRDY */
	while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_RDY));
 8002c00:	4805      	ldr	r0, [pc, #20]	; (8002c18 <ADC_Configuration+0xd4>)
 8002c02:	2101      	movs	r1, #1
 8002c04:	f000 fc64 	bl	80034d0 <ADC_GetFlagStatus>
 8002c08:	2800      	cmp	r0, #0
 8002c0a:	d0f9      	beq.n	8002c00 <ADC_Configuration+0xbc>

	/* Start ADC1 Software Conversion */
	ADC_StartConversion(ADC2);
 8002c0c:	4802      	ldr	r0, [pc, #8]	; (8002c18 <ADC_Configuration+0xd4>)
 8002c0e:	f000 fb53 	bl	80032b8 <ADC_StartConversion>

}
 8002c12:	b017      	add	sp, #92	; 0x5c
 8002c14:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002c16:	bf00      	nop
 8002c18:	50000100 	.word	0x50000100

08002c1c <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8002c1c:	4770      	bx	lr

08002c1e <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8002c1e:	e7fe      	b.n	8002c1e <HardFault_Handler>

08002c20 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8002c20:	e7fe      	b.n	8002c20 <MemManage_Handler>

08002c22 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8002c22:	e7fe      	b.n	8002c22 <BusFault_Handler>

08002c24 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8002c24:	e7fe      	b.n	8002c24 <UsageFault_Handler>

08002c26 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8002c26:	4770      	bx	lr

08002c28 <USART2_IRQHandler>:
//}

// this is the interrupt request handler (IRQ) for ALL USART1 interrupts
/*USART Reception*/
void USART2_IRQHandler(void)
{
 8002c28:	b538      	push	{r3, r4, r5, lr}
	static unsigned char rxBuffer[5];
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
 8002c2a:	4816      	ldr	r0, [pc, #88]	; (8002c84 <USART2_IRQHandler+0x5c>)
 8002c2c:	4916      	ldr	r1, [pc, #88]	; (8002c88 <USART2_IRQHandler+0x60>)
 8002c2e:	f002 fed6 	bl	80059de <USART_GetITStatus>
 8002c32:	b1e0      	cbz	r0, 8002c6e <USART2_IRQHandler+0x46>
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002c34:	4c15      	ldr	r4, [pc, #84]	; (8002c8c <USART2_IRQHandler+0x64>)
 8002c36:	4813      	ldr	r0, [pc, #76]	; (8002c84 <USART2_IRQHandler+0x5c>)
 8002c38:	7825      	ldrb	r5, [r4, #0]
 8002c3a:	f002 fdf0 	bl	800581e <USART_ReceiveData>
		if(i >= 4)
 8002c3e:	7823      	ldrb	r3, [r4, #0]
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002c40:	1965      	adds	r5, r4, r5
		if(i >= 4)
 8002c42:	2b03      	cmp	r3, #3
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002c44:	7068      	strb	r0, [r5, #1]
		if(i >= 4)
 8002c46:	d905      	bls.n	8002c54 <USART2_IRQHandler+0x2c>
		{
			//xQueueSendFromISR( usartRxQueue, &msgPointer, &xYieldRequired );
			CalcRXValues(&rxBuffer[0], 55);
 8002c48:	1c60      	adds	r0, r4, #1
 8002c4a:	2137      	movs	r1, #55	; 0x37
 8002c4c:	f7ff fb1c 	bl	8002288 <CalcRXValues>
			i = 0;
 8002c50:	2300      	movs	r3, #0
 8002c52:	e003      	b.n	8002c5c <USART2_IRQHandler+0x34>
		}
		else
		{
			if(rxBuffer[0] == 'A')
 8002c54:	7862      	ldrb	r2, [r4, #1]
 8002c56:	2a41      	cmp	r2, #65	; 0x41
 8002c58:	d102      	bne.n	8002c60 <USART2_IRQHandler+0x38>
			{
				i++;
 8002c5a:	3301      	adds	r3, #1
 8002c5c:	7023      	strb	r3, [r4, #0]
 8002c5e:	e006      	b.n	8002c6e <USART2_IRQHandler+0x46>
			}
			else
			{
				i = 0;
 8002c60:	2300      	movs	r3, #0
 8002c62:	7023      	strb	r3, [r4, #0]
				rxBuffer[0] = 0;
 8002c64:	7063      	strb	r3, [r4, #1]
				rxBuffer[1] = 0;
 8002c66:	70a3      	strb	r3, [r4, #2]
				rxBuffer[2] = 0;
 8002c68:	70e3      	strb	r3, [r4, #3]
				rxBuffer[3] = 0;
 8002c6a:	7123      	strb	r3, [r4, #4]
				rxBuffer[4] = 0;
 8002c6c:	7163      	strb	r3, [r4, #5]
			}
		}
	}
	USART_ClearITPendingBit(USART2, USART_IT_RXNE);
 8002c6e:	4805      	ldr	r0, [pc, #20]	; (8002c84 <USART2_IRQHandler+0x5c>)
 8002c70:	4905      	ldr	r1, [pc, #20]	; (8002c88 <USART2_IRQHandler+0x60>)
 8002c72:	f002 fed1 	bl	8005a18 <USART_ClearITPendingBit>
	USART_ClearFlag(USART2, USART_IT_RXNE);
 8002c76:	4803      	ldr	r0, [pc, #12]	; (8002c84 <USART2_IRQHandler+0x5c>)
 8002c78:	4903      	ldr	r1, [pc, #12]	; (8002c88 <USART2_IRQHandler+0x60>)
}
 8002c7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				rxBuffer[4] = 0;
			}
		}
	}
	USART_ClearITPendingBit(USART2, USART_IT_RXNE);
	USART_ClearFlag(USART2, USART_IT_RXNE);
 8002c7e:	f002 beac 	b.w	80059da <USART_ClearFlag>
 8002c82:	bf00      	nop
 8002c84:	40004400 	.word	0x40004400
 8002c88:	00050105 	.word	0x00050105
 8002c8c:	200001ac 	.word	0x200001ac

08002c90 <disableEXTI>:
}

void disableEXTI(uint32_t EXTINr)
{
 8002c90:	b510      	push	{r4, lr}
 8002c92:	4604      	mov	r4, r0
	getEXTI_Config()->EXTI_Line = EXTINr;
 8002c94:	f7ff ff08 	bl	8002aa8 <getEXTI_Config>
 8002c98:	6004      	str	r4, [r0, #0]
	getEXTI_Config()->EXTI_LineCmd = DISABLE;
 8002c9a:	f7ff ff05 	bl	8002aa8 <getEXTI_Config>
 8002c9e:	2300      	movs	r3, #0
 8002ca0:	7183      	strb	r3, [r0, #6]
	EXTI_Init(getEXTI_Config());
 8002ca2:	f7ff ff01 	bl	8002aa8 <getEXTI_Config>
}
 8002ca6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void disableEXTI(uint32_t EXTINr)
{
	getEXTI_Config()->EXTI_Line = EXTINr;
	getEXTI_Config()->EXTI_LineCmd = DISABLE;
	EXTI_Init(getEXTI_Config());
 8002caa:	f000 bd5b 	b.w	8003764 <EXTI_Init>

08002cae <enableEXTI>:
}

void enableEXTI(uint32_t EXTINr)
{
 8002cae:	b510      	push	{r4, lr}
 8002cb0:	4604      	mov	r4, r0
	getEXTI_Config()->EXTI_Line = EXTINr;
 8002cb2:	f7ff fef9 	bl	8002aa8 <getEXTI_Config>
 8002cb6:	6004      	str	r4, [r0, #0]
	getEXTI_Config()->EXTI_LineCmd = ENABLE;
 8002cb8:	f7ff fef6 	bl	8002aa8 <getEXTI_Config>
 8002cbc:	2301      	movs	r3, #1
 8002cbe:	7183      	strb	r3, [r0, #6]
	EXTI_Init(getEXTI_Config());
 8002cc0:	f7ff fef2 	bl	8002aa8 <getEXTI_Config>
}
 8002cc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void enableEXTI(uint32_t EXTINr)
{
	getEXTI_Config()->EXTI_Line = EXTINr;
	getEXTI_Config()->EXTI_LineCmd = ENABLE;
	EXTI_Init(getEXTI_Config());
 8002cc8:	f000 bd4c 	b.w	8003764 <EXTI_Init>

08002ccc <EXTI15_10_IRQHandler>:
}

/* Interupt Handlers */
void EXTI15_10_IRQHandler(void)
{
 8002ccc:	b510      	push	{r4, lr}
	static uint8_t timNr = 0;
	static uint8_t timStage = 0;
	static unsigned char rxBuffer[6];

	switch(timNr)
 8002cce:	4b4f      	ldr	r3, [pc, #316]	; (8002e0c <EXTI15_10_IRQHandler+0x140>)
 8002cd0:	799a      	ldrb	r2, [r3, #6]
 8002cd2:	2a03      	cmp	r2, #3
 8002cd4:	f200 8082 	bhi.w	8002ddc <EXTI15_10_IRQHandler+0x110>
 8002cd8:	e8df f002 	tbb	[pc, r2]
 8002cdc:	5c3f2002 	.word	0x5c3f2002
	{
	case 0:
		if (EXTI_GetITStatus(EXTI_Line12) == SET)
 8002ce0:	200c      	movs	r0, #12
 8002ce2:	f000 fdf5 	bl	80038d0 <EXTI_GetITStatus>
 8002ce6:	2801      	cmp	r0, #1
 8002ce8:	f040 8082 	bne.w	8002df0 <EXTI15_10_IRQHandler+0x124>
		{
			if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_12) == 1)
 8002cec:	4848      	ldr	r0, [pc, #288]	; (8002e10 <EXTI15_10_IRQHandler+0x144>)
 8002cee:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002cf2:	f000 fec9 	bl	8003a88 <GPIO_ReadInputDataBit>
 8002cf6:	2801      	cmp	r0, #1
 8002cf8:	4c44      	ldr	r4, [pc, #272]	; (8002e0c <EXTI15_10_IRQHandler+0x140>)
 8002cfa:	d100      	bne.n	8002cfe <EXTI15_10_IRQHandler+0x32>
 8002cfc:	e057      	b.n	8002dae <EXTI15_10_IRQHandler+0xe2>
			{
				timStage += 1;
				TIM_SetCounter(TIM4, 0);
			}
			else if (timStage == (timNr+1))
 8002cfe:	79a2      	ldrb	r2, [r4, #6]
 8002d00:	79e3      	ldrb	r3, [r4, #7]
 8002d02:	3201      	adds	r2, #1
 8002d04:	4293      	cmp	r3, r2
 8002d06:	d173      	bne.n	8002df0 <EXTI15_10_IRQHandler+0x124>
			{
				timNr += 1;
				/* add an offset to zero the GAS-value */
				rxBuffer[2] = TIM_GetCounter(TIM4);
 8002d08:	4842      	ldr	r0, [pc, #264]	; (8002e14 <EXTI15_10_IRQHandler+0x148>)
				timStage += 1;
				TIM_SetCounter(TIM4, 0);
			}
			else if (timStage == (timNr+1))
			{
				timNr += 1;
 8002d0a:	71a3      	strb	r3, [r4, #6]
				/* add an offset to zero the GAS-value */
				rxBuffer[2] = TIM_GetCounter(TIM4);
 8002d0c:	f001 ff80 	bl	8004c10 <TIM_GetCounter>
 8002d10:	72a0      	strb	r0, [r4, #10]
				//GAS = TIM_GetCounter(TIM4);
				disableEXTI(EXTI_Line12);
 8002d12:	200c      	movs	r0, #12
 8002d14:	f7ff ffbc 	bl	8002c90 <disableEXTI>
				enableEXTI(EXTI_Line13);
 8002d18:	200d      	movs	r0, #13
 8002d1a:	e01b      	b.n	8002d54 <EXTI15_10_IRQHandler+0x88>
			}
		}
		break;
	case  1:
		if (EXTI_GetITStatus(EXTI_Line13) == SET)
 8002d1c:	200d      	movs	r0, #13
 8002d1e:	f000 fdd7 	bl	80038d0 <EXTI_GetITStatus>
 8002d22:	2801      	cmp	r0, #1
 8002d24:	d164      	bne.n	8002df0 <EXTI15_10_IRQHandler+0x124>
		{
			if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_13) == 1)
 8002d26:	483a      	ldr	r0, [pc, #232]	; (8002e10 <EXTI15_10_IRQHandler+0x144>)
 8002d28:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8002d2c:	f000 feac 	bl	8003a88 <GPIO_ReadInputDataBit>
 8002d30:	2801      	cmp	r0, #1
 8002d32:	4c36      	ldr	r4, [pc, #216]	; (8002e0c <EXTI15_10_IRQHandler+0x140>)
 8002d34:	d100      	bne.n	8002d38 <EXTI15_10_IRQHandler+0x6c>
 8002d36:	e03a      	b.n	8002dae <EXTI15_10_IRQHandler+0xe2>
			{
				timStage += 1;
				TIM_SetCounter(TIM4, 0);
			}
			else if (timStage == (timNr+1))
 8002d38:	79a2      	ldrb	r2, [r4, #6]
 8002d3a:	79e3      	ldrb	r3, [r4, #7]
 8002d3c:	3201      	adds	r2, #1
 8002d3e:	4293      	cmp	r3, r2
 8002d40:	d156      	bne.n	8002df0 <EXTI15_10_IRQHandler+0x124>
			{
				timNr += 1;
				rxBuffer[3] = TIM_GetCounter(TIM4);
 8002d42:	4834      	ldr	r0, [pc, #208]	; (8002e14 <EXTI15_10_IRQHandler+0x148>)
				timStage += 1;
				TIM_SetCounter(TIM4, 0);
			}
			else if (timStage == (timNr+1))
			{
				timNr += 1;
 8002d44:	71a3      	strb	r3, [r4, #6]
				rxBuffer[3] = TIM_GetCounter(TIM4);
 8002d46:	f001 ff63 	bl	8004c10 <TIM_GetCounter>
 8002d4a:	72e0      	strb	r0, [r4, #11]
				disableEXTI(EXTI_Line13);
 8002d4c:	200d      	movs	r0, #13
 8002d4e:	f7ff ff9f 	bl	8002c90 <disableEXTI>
				enableEXTI(EXTI_Line14);
 8002d52:	200e      	movs	r0, #14
 8002d54:	f7ff ffab 	bl	8002cae <enableEXTI>
 8002d58:	e04a      	b.n	8002df0 <EXTI15_10_IRQHandler+0x124>
			}
		}
		break;
	case  2:
		if (EXTI_GetITStatus(EXTI_Line14) == SET)
 8002d5a:	200e      	movs	r0, #14
 8002d5c:	f000 fdb8 	bl	80038d0 <EXTI_GetITStatus>
 8002d60:	2801      	cmp	r0, #1
 8002d62:	d145      	bne.n	8002df0 <EXTI15_10_IRQHandler+0x124>
		{
			if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_14) == 1)
 8002d64:	482a      	ldr	r0, [pc, #168]	; (8002e10 <EXTI15_10_IRQHandler+0x144>)
 8002d66:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8002d6a:	f000 fe8d 	bl	8003a88 <GPIO_ReadInputDataBit>
 8002d6e:	2801      	cmp	r0, #1
 8002d70:	4c26      	ldr	r4, [pc, #152]	; (8002e0c <EXTI15_10_IRQHandler+0x140>)
 8002d72:	d100      	bne.n	8002d76 <EXTI15_10_IRQHandler+0xaa>
 8002d74:	e01b      	b.n	8002dae <EXTI15_10_IRQHandler+0xe2>
			{
				timStage += 1;
				TIM_SetCounter(TIM4, 0);
			}
			else if (timStage == (timNr+1))
 8002d76:	79a2      	ldrb	r2, [r4, #6]
 8002d78:	79e3      	ldrb	r3, [r4, #7]
 8002d7a:	3201      	adds	r2, #1
 8002d7c:	4293      	cmp	r3, r2
 8002d7e:	d137      	bne.n	8002df0 <EXTI15_10_IRQHandler+0x124>
			{
				timNr += 1;
				rxBuffer[4] = TIM_GetCounter(TIM4);
 8002d80:	4824      	ldr	r0, [pc, #144]	; (8002e14 <EXTI15_10_IRQHandler+0x148>)
				timStage += 1;
				TIM_SetCounter(TIM4, 0);
			}
			else if (timStage == (timNr+1))
			{
				timNr += 1;
 8002d82:	71a3      	strb	r3, [r4, #6]
				rxBuffer[4] = TIM_GetCounter(TIM4);
 8002d84:	f001 ff44 	bl	8004c10 <TIM_GetCounter>
 8002d88:	7320      	strb	r0, [r4, #12]
				disableEXTI(EXTI_Line14);
 8002d8a:	200e      	movs	r0, #14
 8002d8c:	f7ff ff80 	bl	8002c90 <disableEXTI>
				enableEXTI(EXTI_Line15);
 8002d90:	200f      	movs	r0, #15
 8002d92:	e7df      	b.n	8002d54 <EXTI15_10_IRQHandler+0x88>
			}
		}
		break;
	case  3:
		if (EXTI_GetITStatus(EXTI_Line15) == SET)
 8002d94:	200f      	movs	r0, #15
 8002d96:	f000 fd9b 	bl	80038d0 <EXTI_GetITStatus>
 8002d9a:	2801      	cmp	r0, #1
 8002d9c:	d128      	bne.n	8002df0 <EXTI15_10_IRQHandler+0x124>
		{
			if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_15) == 1)
 8002d9e:	481c      	ldr	r0, [pc, #112]	; (8002e10 <EXTI15_10_IRQHandler+0x144>)
 8002da0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8002da4:	f000 fe70 	bl	8003a88 <GPIO_ReadInputDataBit>
 8002da8:	2801      	cmp	r0, #1
 8002daa:	4c18      	ldr	r4, [pc, #96]	; (8002e0c <EXTI15_10_IRQHandler+0x140>)
 8002dac:	d107      	bne.n	8002dbe <EXTI15_10_IRQHandler+0xf2>
			{
				timStage += 1;
 8002dae:	79e3      	ldrb	r3, [r4, #7]
				TIM_SetCounter(TIM4, 0);
 8002db0:	4818      	ldr	r0, [pc, #96]	; (8002e14 <EXTI15_10_IRQHandler+0x148>)
	case  3:
		if (EXTI_GetITStatus(EXTI_Line15) == SET)
		{
			if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_15) == 1)
			{
				timStage += 1;
 8002db2:	3301      	adds	r3, #1
				TIM_SetCounter(TIM4, 0);
 8002db4:	2100      	movs	r1, #0
	case  3:
		if (EXTI_GetITStatus(EXTI_Line15) == SET)
		{
			if(GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_15) == 1)
			{
				timStage += 1;
 8002db6:	71e3      	strb	r3, [r4, #7]
				TIM_SetCounter(TIM4, 0);
 8002db8:	f001 ff26 	bl	8004c08 <TIM_SetCounter>
 8002dbc:	e018      	b.n	8002df0 <EXTI15_10_IRQHandler+0x124>
			}
			else if (timStage == (timNr+1))
 8002dbe:	79a2      	ldrb	r2, [r4, #6]
 8002dc0:	79e3      	ldrb	r3, [r4, #7]
 8002dc2:	3201      	adds	r2, #1
 8002dc4:	4293      	cmp	r3, r2
 8002dc6:	d113      	bne.n	8002df0 <EXTI15_10_IRQHandler+0x124>
			{
				timNr += 1;
				rxBuffer[5] = TIM_GetCounter(TIM4);
 8002dc8:	4812      	ldr	r0, [pc, #72]	; (8002e14 <EXTI15_10_IRQHandler+0x148>)
				timStage += 1;
				TIM_SetCounter(TIM4, 0);
			}
			else if (timStage == (timNr+1))
			{
				timNr += 1;
 8002dca:	71a3      	strb	r3, [r4, #6]
				rxBuffer[5] = TIM_GetCounter(TIM4);
 8002dcc:	f001 ff20 	bl	8004c10 <TIM_GetCounter>
 8002dd0:	7360      	strb	r0, [r4, #13]
				disableEXTI(EXTI_Line15);
 8002dd2:	200f      	movs	r0, #15
 8002dd4:	f7ff ff5c 	bl	8002c90 <disableEXTI>
				enableEXTI(EXTI_Line12);
 8002dd8:	200c      	movs	r0, #12
 8002dda:	e7bb      	b.n	8002d54 <EXTI15_10_IRQHandler+0x88>
			}
		}
		break;
	default:
		timNr = 0;
 8002ddc:	2100      	movs	r1, #0
		timStage = 0;
		TIM_SetCounter(TIM4, 0);
 8002dde:	480d      	ldr	r0, [pc, #52]	; (8002e14 <EXTI15_10_IRQHandler+0x148>)
				enableEXTI(EXTI_Line12);
			}
		}
		break;
	default:
		timNr = 0;
 8002de0:	7199      	strb	r1, [r3, #6]
		timStage = 0;
 8002de2:	71d9      	strb	r1, [r3, #7]
		TIM_SetCounter(TIM4, 0);
 8002de4:	f001 ff10 	bl	8004c08 <TIM_SetCounter>
		CalcRXValues(&rxBuffer[0], 75);
 8002de8:	480b      	ldr	r0, [pc, #44]	; (8002e18 <EXTI15_10_IRQHandler+0x14c>)
 8002dea:	214b      	movs	r1, #75	; 0x4b
 8002dec:	f7ff fa4c 	bl	8002288 <CalcRXValues>
		break;
	}
	EXTI_ClearITPendingBit(EXTI_Line12);
 8002df0:	200c      	movs	r0, #12
 8002df2:	f000 fd85 	bl	8003900 <EXTI_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line13);
 8002df6:	200d      	movs	r0, #13
 8002df8:	f000 fd82 	bl	8003900 <EXTI_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line14);
 8002dfc:	200e      	movs	r0, #14
 8002dfe:	f000 fd7f 	bl	8003900 <EXTI_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line15);
 8002e02:	200f      	movs	r0, #15
}
 8002e04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		break;
	}
	EXTI_ClearITPendingBit(EXTI_Line12);
	EXTI_ClearITPendingBit(EXTI_Line13);
	EXTI_ClearITPendingBit(EXTI_Line14);
	EXTI_ClearITPendingBit(EXTI_Line15);
 8002e08:	f000 bd7a 	b.w	8003900 <EXTI_ClearITPendingBit>
 8002e0c:	200001ac 	.word	0x200001ac
 8002e10:	48000c00 	.word	0x48000c00
 8002e14:	40000800 	.word	0x40000800
 8002e18:	200001b4 	.word	0x200001b4

08002e1c <Usart2Put>:
#include <stm32f30x.h>
#include <stm32f30x_conf.h>

void Usart2Put(uint8_t ch)
{
 8002e1c:	4601      	mov	r1, r0
 8002e1e:	b508      	push	{r3, lr}
      USART_SendData(USART2, (uint8_t) ch);
 8002e20:	4804      	ldr	r0, [pc, #16]	; (8002e34 <Usart2Put+0x18>)
 8002e22:	f002 fcf8 	bl	8005816 <USART_SendData>
      //Loop until the end of transmission
      while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
 8002e26:	4803      	ldr	r0, [pc, #12]	; (8002e34 <Usart2Put+0x18>)
 8002e28:	2140      	movs	r1, #64	; 0x40
 8002e2a:	f002 fdd0 	bl	80059ce <USART_GetFlagStatus>
 8002e2e:	2800      	cmp	r0, #0
 8002e30:	d0f9      	beq.n	8002e26 <Usart2Put+0xa>
      {
      }
}
 8002e32:	bd08      	pop	{r3, pc}
 8002e34:	40004400 	.word	0x40004400

08002e38 <Usart3Put>:
/*
 * USART3 wurde auf Interrupt modus umprogrammiert
 * */

void Usart3Put(uint8_t ch)
{
 8002e38:	4601      	mov	r1, r0
 8002e3a:	b508      	push	{r3, lr}
      USART_SendData(USART3, (uint8_t) ch);
 8002e3c:	4804      	ldr	r0, [pc, #16]	; (8002e50 <Usart3Put+0x18>)
 8002e3e:	f002 fcea 	bl	8005816 <USART_SendData>
      //Loop until the end of transmission
      while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET)
 8002e42:	4803      	ldr	r0, [pc, #12]	; (8002e50 <Usart3Put+0x18>)
 8002e44:	2140      	movs	r1, #64	; 0x40
 8002e46:	f002 fdc2 	bl	80059ce <USART_GetFlagStatus>
 8002e4a:	2800      	cmp	r0, #0
 8002e4c:	d0f9      	beq.n	8002e42 <Usart3Put+0xa>
      {
      }
}
 8002e4e:	bd08      	pop	{r3, pc}
 8002e50:	40004800 	.word	0x40004800

08002e54 <Usart3Get>:

uint8_t Usart3Get(){
 8002e54:	b508      	push	{r3, lr}
	uint8_t ch;
	while(USART_GetFlagStatus(USART3, USART_FLAG_RXNE) == RESET)
 8002e56:	4805      	ldr	r0, [pc, #20]	; (8002e6c <Usart3Get+0x18>)
 8002e58:	2120      	movs	r1, #32
 8002e5a:	f002 fdb8 	bl	80059ce <USART_GetFlagStatus>
 8002e5e:	2800      	cmp	r0, #0
 8002e60:	d0f9      	beq.n	8002e56 <Usart3Get+0x2>
	{
	}
	ch = USART_ReceiveData(USART3);
 8002e62:	4802      	ldr	r0, [pc, #8]	; (8002e6c <Usart3Get+0x18>)
 8002e64:	f002 fcdb 	bl	800581e <USART_ReceiveData>
	return ch;
}
 8002e68:	b2c0      	uxtb	r0, r0
 8002e6a:	bd08      	pop	{r3, pc}
 8002e6c:	40004800 	.word	0x40004800

08002e70 <InttoBuffer>:

/* TODO
 * Evtl. Typecast auf Bytestream
 */
void InttoBuffer(unsigned char *ptr, uint32_t Value){
	*ptr= (char) (Value >> 24);
 8002e70:	0e0b      	lsrs	r3, r1, #24
 8002e72:	7003      	strb	r3, [r0, #0]
	ptr++;
	*ptr= (char) (Value >> 16);
 8002e74:	0c0b      	lsrs	r3, r1, #16
 8002e76:	7043      	strb	r3, [r0, #1]
	ptr++;
	*ptr= (char) (Value >> 8);
 8002e78:	0a0b      	lsrs	r3, r1, #8
 8002e7a:	7083      	strb	r3, [r0, #2]
	ptr++;
	*ptr= (char) Value;
 8002e7c:	70c1      	strb	r1, [r0, #3]
 8002e7e:	4770      	bx	lr

08002e80 <setup_xBeeS6>:




	return 0;
}
 8002e80:	2000      	movs	r0, #0
 8002e82:	4770      	bx	lr

08002e84 <ADC_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));


  if((ADCx == ADC1) || (ADCx == ADC2))
 8002e84:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
  * @param  ADCx: where x can be 1, 2,3 or 4 to select the ADC peripheral.
  * @retval None
  */
void ADC_DeInit(ADC_TypeDef* ADCx)
{
 8002e88:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));


  if((ADCx == ADC1) || (ADCx == ADC2))
 8002e8a:	d002      	beq.n	8002e92 <ADC_DeInit+0xe>
 8002e8c:	4b0f      	ldr	r3, [pc, #60]	; (8002ecc <ADC_DeInit+0x48>)
 8002e8e:	4298      	cmp	r0, r3
 8002e90:	d107      	bne.n	8002ea2 <ADC_DeInit+0x1e>
  {
    /* Enable ADC1/ADC2 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC12, ENABLE);
 8002e92:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8002e96:	2101      	movs	r1, #1
 8002e98:	f001 faba 	bl	8004410 <RCC_AHBPeriphResetCmd>
    /* Release ADC1/ADC2 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC12, DISABLE);
 8002e9c:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8002ea0:	e00d      	b.n	8002ebe <ADC_DeInit+0x3a>
  }
  else if((ADCx == ADC3) || (ADCx == ADC4))
 8002ea2:	4b0b      	ldr	r3, [pc, #44]	; (8002ed0 <ADC_DeInit+0x4c>)
 8002ea4:	4298      	cmp	r0, r3
 8002ea6:	d003      	beq.n	8002eb0 <ADC_DeInit+0x2c>
 8002ea8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8002eac:	4298      	cmp	r0, r3
 8002eae:	d10b      	bne.n	8002ec8 <ADC_DeInit+0x44>
  {
    /* Enable ADC3/ADC4 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, ENABLE);
 8002eb0:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8002eb4:	2101      	movs	r1, #1
 8002eb6:	f001 faab 	bl	8004410 <RCC_AHBPeriphResetCmd>
    /* Release ADC3/ADC4 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, DISABLE);
 8002eba:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8002ebe:	2100      	movs	r1, #0
  }
}
 8002ec0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else if((ADCx == ADC3) || (ADCx == ADC4))
  {
    /* Enable ADC3/ADC4 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, ENABLE);
    /* Release ADC3/ADC4 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, DISABLE);
 8002ec4:	f001 baa4 	b.w	8004410 <RCC_AHBPeriphResetCmd>
 8002ec8:	bd08      	pop	{r3, pc}
 8002eca:	bf00      	nop
 8002ecc:	50000100 	.word	0x50000100
 8002ed0:	50000400 	.word	0x50000400

08002ed4 <ADC_Init>:
  assert_param(IS_ADC_AUTOINJECMODE(ADC_InitStruct->ADC_AutoInjMode));
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfRegChannel));

  /*---------------------------- ADCx CFGR Configuration -----------------*/
  /* Get the ADCx CFGR value */
  tmpreg1 = ADCx->CFGR;
 8002ed4:	68c2      	ldr	r2, [r0, #12]
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
 8002ed6:	4b0d      	ldr	r3, [pc, #52]	; (8002f0c <ADC_Init+0x38>)
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8002ed8:	b510      	push	{r4, lr}

  /*---------------------------- ADCx CFGR Configuration -----------------*/
  /* Get the ADCx CFGR value */
  tmpreg1 = ADCx->CFGR;
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
 8002eda:	4013      	ands	r3, r2
  /* Configure ADCx: scan conversion mode */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)ADC_InitStruct->ADC_ContinuousConvMode | 
 8002edc:	e891 0014 	ldmia.w	r1, {r2, r4}
 8002ee0:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_Resolution|                 
 8002ee2:	688a      	ldr	r2, [r1, #8]
 8002ee4:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_ExternalTrigConvEvent|         
 8002ee6:	68ca      	ldr	r2, [r1, #12]
 8002ee8:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_ExternalTrigEventEdge|     
 8002eea:	690a      	ldr	r2, [r1, #16]
 8002eec:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_DataAlign|                 
 8002eee:	694a      	ldr	r2, [r1, #20]
 8002ef0:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_OverrunMode|        
 8002ef2:	698a      	ldr	r2, [r1, #24]
 8002ef4:	4322      	orrs	r2, r4
  tmpreg1 = ADCx->CFGR;
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
  /* Configure ADCx: scan conversion mode */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)ADC_InitStruct->ADC_ContinuousConvMode | 
 8002ef6:	4313      	orrs	r3, r2
  ADC_InitStruct->ADC_DataAlign|                 
  ADC_InitStruct->ADC_OverrunMode|        
  ADC_InitStruct->ADC_AutoInjMode;
  
  /* Write to ADCx CFGR */
  ADCx->CFGR = tmpreg1;
 8002ef8:	60c3      	str	r3, [r0, #12]
  
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8002efa:	6b02      	ldr	r2, [r0, #48]	; 0x30
  /* Clear L bits */
  tmpreg1 &= ~(uint32_t)(ADC_SQR1_L);
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfRegChannel value */
  tmpreg1 |= (uint32_t) (ADC_InitStruct->ADC_NbrOfRegChannel - 1);
 8002efc:	7f0b      	ldrb	r3, [r1, #28]
  
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= ~(uint32_t)(ADC_SQR1_L);
 8002efe:	f022 020f 	bic.w	r2, r2, #15
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfRegChannel value */
  tmpreg1 |= (uint32_t) (ADC_InitStruct->ADC_NbrOfRegChannel - 1);
 8002f02:	3b01      	subs	r3, #1
 8002f04:	4313      	orrs	r3, r2
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1; 
 8002f06:	6303      	str	r3, [r0, #48]	; 0x30
 8002f08:	bd10      	pop	{r4, pc}
 8002f0a:	bf00      	nop
 8002f0c:	fdffc007 	.word	0xfdffc007

08002f10 <ADC_StructInit>:
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8002f10:	2300      	movs	r3, #0
 8002f12:	6003      	str	r3, [r0, #0]
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;                 
 8002f14:	6043      	str	r3, [r0, #4]
  ADC_InitStruct->ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;         
 8002f16:	6083      	str	r3, [r0, #8]
  ADC_InitStruct->ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
 8002f18:	60c3      	str	r3, [r0, #12]
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;                 
 8002f1a:	6103      	str	r3, [r0, #16]
  ADC_InitStruct->ADC_OverrunMode = DISABLE;   
 8002f1c:	6143      	str	r3, [r0, #20]
  ADC_InitStruct->ADC_AutoInjMode = DISABLE;  
 8002f1e:	6183      	str	r3, [r0, #24]
  ADC_InitStruct->ADC_NbrOfRegChannel = 1; 
 8002f20:	2301      	movs	r3, #1
 8002f22:	7703      	strb	r3, [r0, #28]
 8002f24:	4770      	bx	lr

08002f26 <ADC_InjectedInit>:
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence3));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence4));
  
  /*---------------------------- ADCx JSQR Configuration -----------------*/
  /* Get the ADCx JSQR value */
  tmpreg1 = ADCx->JSQR;
 8002f26:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  /* Clear L bits */
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
 8002f28:	684a      	ldr	r2, [r1, #4]
 8002f2a:	680b      	ldr	r3, [r1, #0]
 8002f2c:	431a      	orrs	r2, r3
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
 8002f2e:	68cb      	ldr	r3, [r1, #12]
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
 8002f30:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
 8002f34:	690b      	ldr	r3, [r1, #16]
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
 8002f36:	ea42 3283 	orr.w	r2, r2, r3, lsl #14
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
 8002f3a:	694b      	ldr	r3, [r1, #20]
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
 8002f3c:	ea42 5203 	orr.w	r2, r2, r3, lsl #20
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence4) << 26));
 8002f40:	698b      	ldr	r3, [r1, #24]
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
 8002f42:	ea42 6383 	orr.w	r3, r2, r3, lsl #26
  /* Clear L bits */
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
 8002f46:	7a0a      	ldrb	r2, [r1, #8]
 8002f48:	3a01      	subs	r2, #1
 8002f4a:	4313      	orrs	r3, r2
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence4) << 26));
  /* Write to ADCx SQR1 */
  ADCx->JSQR = tmpreg1;  
 8002f4c:	64c3      	str	r3, [r0, #76]	; 0x4c
 8002f4e:	4770      	bx	lr

08002f50 <ADC_InjectedStructInit>:
  * @param  ADC_InjectedInitStruct : pointer to an ADC_InjectedInitTypeDef structure which will be initialized.
  * @retval None
  */
void ADC_InjectedStructInit(ADC_InjectedInitTypeDef* ADC_InjectedInitStruct)
{
  ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;    
 8002f50:	2300      	movs	r3, #0
 8002f52:	6003      	str	r3, [r0, #0]
  ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;     
 8002f54:	6043      	str	r3, [r0, #4]
  ADC_InjectedInitStruct->ADC_NbrOfInjecChannel = 1;                                                             
 8002f56:	2301      	movs	r3, #1
 8002f58:	7203      	strb	r3, [r0, #8]
  ADC_InjectedInitStruct->ADC_InjecSequence1 = ADC_InjectedChannel_1; 
 8002f5a:	60c3      	str	r3, [r0, #12]
  ADC_InjectedInitStruct->ADC_InjecSequence2 = ADC_InjectedChannel_1;
 8002f5c:	6103      	str	r3, [r0, #16]
  ADC_InjectedInitStruct->ADC_InjecSequence3 = ADC_InjectedChannel_1;
 8002f5e:	6143      	str	r3, [r0, #20]
  ADC_InjectedInitStruct->ADC_InjecSequence4 = ADC_InjectedChannel_1; 
 8002f60:	6183      	str	r3, [r0, #24]
 8002f62:	4770      	bx	lr

08002f64 <ADC_CommonInit>:
  assert_param(IS_ADC_CLOCKMODE(ADC_CommonInitStruct->ADC_Clock));
  assert_param(IS_ADC_DMA_MODE(ADC_CommonInitStruct->ADC_DMAMode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_TWOSAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002f64:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_TypeDef* ADCx, ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8002f68:	b510      	push	{r4, lr}
  assert_param(IS_ADC_CLOCKMODE(ADC_CommonInitStruct->ADC_Clock));
  assert_param(IS_ADC_DMA_MODE(ADC_CommonInitStruct->ADC_DMAMode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_TWOSAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002f6a:	d002      	beq.n	8002f72 <ADC_CommonInit+0xe>
 8002f6c:	4b11      	ldr	r3, [pc, #68]	; (8002fb4 <ADC_CommonInit+0x50>)
 8002f6e:	4298      	cmp	r0, r3
 8002f70:	d101      	bne.n	8002f76 <ADC_CommonInit+0x12>
  {
    /* Get the ADC CCR value */
    tmpreg1 = ADC1_2->CCR;
 8002f72:	4b11      	ldr	r3, [pc, #68]	; (8002fb8 <ADC_CommonInit+0x54>)
 8002f74:	e000      	b.n	8002f78 <ADC_CommonInit+0x14>
    tmpreg1 &= CCR_CLEAR_MASK;
  }
  else
  {
    /* Get the ADC CCR value */
    tmpreg1 = ADC3_4->CCR;
 8002f76:	4b11      	ldr	r3, [pc, #68]	; (8002fbc <ADC_CommonInit+0x58>)
 8002f78:	689a      	ldr	r2, [r3, #8]
  
    /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    tmpreg1 &= CCR_CLEAR_MASK;
 8002f7a:	4b11      	ldr	r3, [pc, #68]	; (8002fc0 <ADC_CommonInit+0x5c>)
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002f7c:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  {
    /* Get the ADC CCR value */
    tmpreg1 = ADC3_4->CCR;
  
    /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    tmpreg1 &= CCR_CLEAR_MASK;
 8002f80:	ea02 0303 	and.w	r3, r2, r3
  /* Set MULTI bits according to ADC_Mode value */
  /* Set CKMODE bits according to ADC_Clock value */
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8002f84:	e891 0014 	ldmia.w	r1, {r2, r4}
 8002f88:	ea44 0402 	orr.w	r4, r4, r2
                        ADC_CommonInitStruct->ADC_Clock | 
 8002f8c:	688a      	ldr	r2, [r1, #8]
 8002f8e:	ea44 0402 	orr.w	r4, r4, r2
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
 8002f92:	68ca      	ldr	r2, [r1, #12]
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));
 8002f94:	7c09      	ldrb	r1, [r1, #16]
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 8002f96:	ea44 3202 	orr.w	r2, r4, r2, lsl #12
  /* Set MULTI bits according to ADC_Mode value */
  /* Set CKMODE bits according to ADC_Clock value */
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8002f9a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8002f9e:	ea42 0303 	orr.w	r3, r2, r3
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002fa2:	d002      	beq.n	8002faa <ADC_CommonInit+0x46>
 8002fa4:	4a03      	ldr	r2, [pc, #12]	; (8002fb4 <ADC_CommonInit+0x50>)
 8002fa6:	4290      	cmp	r0, r2
 8002fa8:	d101      	bne.n	8002fae <ADC_CommonInit+0x4a>
  {                        
    /* Write to ADC CCR */
    ADC1_2->CCR = tmpreg1;
 8002faa:	4a03      	ldr	r2, [pc, #12]	; (8002fb8 <ADC_CommonInit+0x54>)
 8002fac:	e000      	b.n	8002fb0 <ADC_CommonInit+0x4c>
  }
  else
  {
    /* Write to ADC CCR */
    ADC3_4->CCR = tmpreg1;
 8002fae:	4a03      	ldr	r2, [pc, #12]	; (8002fbc <ADC_CommonInit+0x58>)
 8002fb0:	6093      	str	r3, [r2, #8]
 8002fb2:	bd10      	pop	{r4, pc}
 8002fb4:	50000100 	.word	0x50000100
 8002fb8:	50000300 	.word	0x50000300
 8002fbc:	50000700 	.word	0x50000700
 8002fc0:	fffc10e0 	.word	0xfffc10e0

08002fc4 <ADC_CommonStructInit>:
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 8002fc4:	2300      	movs	r3, #0
 8002fc6:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_Clock member */
  ADC_CommonInitStruct->ADC_Clock = ADC_Clock_AsynClkMode;
 8002fc8:	6043      	str	r3, [r0, #4]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8002fca:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_DMAMode member */
  ADC_CommonInitStruct->ADC_DMAMode = ADC_DMAMode_OneShot;
 8002fcc:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = 0;
 8002fce:	7403      	strb	r3, [r0, #16]
 8002fd0:	4770      	bx	lr

08002fd2 <ADC_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ADEN bit */
    ADCx->CR |= ADC_CR_ADEN;
 8002fd2:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002fd4:	b111      	cbz	r1, 8002fdc <ADC_Cmd+0xa>
  {
    /* Set the ADEN bit */
    ADCx->CR |= ADC_CR_ADEN;
 8002fd6:	f043 0301 	orr.w	r3, r3, #1
 8002fda:	e001      	b.n	8002fe0 <ADC_Cmd+0xe>
  }
  else
  {
    /* Disable the selected ADC peripheral: Set the ADDIS bit */
    ADCx->CR |= ADC_CR_ADDIS;
 8002fdc:	f043 0302 	orr.w	r3, r3, #2
 8002fe0:	6083      	str	r3, [r0, #8]
 8002fe2:	4770      	bx	lr

08002fe4 <ADC_StartCalibration>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADCAL bit */
  ADCx->CR |= ADC_CR_ADCAL;
 8002fe4:	6883      	ldr	r3, [r0, #8]
 8002fe6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002fea:	6083      	str	r3, [r0, #8]
 8002fec:	4770      	bx	lr

08002fee <ADC_GetCalibrationValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Return the selected ADC calibration value */
  return (uint32_t)ADCx->CALFACT;
 8002fee:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
}
 8002ff2:	4770      	bx	lr

08002ff4 <ADC_SetCalibrationValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADC calibration register value */
  ADCx->CALFACT = ADC_Calibration;
 8002ff4:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
 8002ff8:	4770      	bx	lr

08002ffa <ADC_SelectCalibrationMode>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CALIBRATION_MODE(ADC_CalibrationMode));
  /* Set or Reset the ADCALDIF bit */
  ADCx->CR &= (~ADC_CR_ADCALDIF);
 8002ffa:	6883      	ldr	r3, [r0, #8]
 8002ffc:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8003000:	6083      	str	r3, [r0, #8]
  ADCx->CR |= ADC_CalibrationMode;
 8003002:	6883      	ldr	r3, [r0, #8]
 8003004:	4319      	orrs	r1, r3
 8003006:	6081      	str	r1, [r0, #8]
 8003008:	4770      	bx	lr

0800300a <ADC_GetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR & ADC_CR_ADCAL) != (uint32_t)RESET)
 800300a:	6880      	ldr	r0, [r0, #8]
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
  }
  /* Return the CAL bit status */
  return  bitstatus;
}
 800300c:	0fc0      	lsrs	r0, r0, #31
 800300e:	4770      	bx	lr

08003010 <ADC_DisableCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADDIS bit */
  ADCx->CR |= ADC_CR_ADDIS;
 8003010:	6883      	ldr	r3, [r0, #8]
 8003012:	f043 0302 	orr.w	r3, r3, #2
 8003016:	6083      	str	r3, [r0, #8]
 8003018:	4770      	bx	lr

0800301a <ADC_GetDisableCmdStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of ADDIS bit */
  if ((ADCx->CR & ADC_CR_ADDIS) != (uint32_t)RESET)
 800301a:	6880      	ldr	r0, [r0, #8]
    /* ADDIS bit is reset */
    bitstatus = RESET;
  }
  /* Return the ADDIS bit status */
  return  bitstatus;
}
 800301c:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8003020:	4770      	bx	lr

08003022 <ADC_VoltageRegulatorCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* set the intermediate state before moving the ADC voltage regulator 
  from enable state to disable state or from disable state to enable state */
  ADCx->CR &= ~(ADC_CR_ADVREGEN);
 8003022:	6883      	ldr	r3, [r0, #8]
 8003024:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8003028:	6083      	str	r3, [r0, #8]
  
  if (NewState != DISABLE)
  {
    /* Set the ADVREGEN bit 0 */
    ADCx->CR |= ADC_CR_ADVREGEN_0;
 800302a:	6883      	ldr	r3, [r0, #8]

  /* set the intermediate state before moving the ADC voltage regulator 
  from enable state to disable state or from disable state to enable state */
  ADCx->CR &= ~(ADC_CR_ADVREGEN);
  
  if (NewState != DISABLE)
 800302c:	b111      	cbz	r1, 8003034 <ADC_VoltageRegulatorCmd+0x12>
  {
    /* Set the ADVREGEN bit 0 */
    ADCx->CR |= ADC_CR_ADVREGEN_0;
 800302e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003032:	e001      	b.n	8003038 <ADC_VoltageRegulatorCmd+0x16>
  }
  else
  {
    /* Set the ADVREGEN bit 1 */
    ADCx->CR |=ADC_CR_ADVREGEN_1;
 8003034:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8003038:	6083      	str	r3, [r0, #8]
 800303a:	4770      	bx	lr

0800303c <ADC_SelectDifferentialMode>:
  *     @arg ADC_Channel_14: ADC Channel14 selected
  * @note : Channel 15, 16 and 17 are fixed to single-ended inputs mode.
  * @retval None
  */
void ADC_SelectDifferentialMode(ADC_TypeDef* ADCx, uint8_t ADC_Channel, FunctionalState NewState)
{
 800303c:	2301      	movs	r3, #1
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_ADC_DIFFCHANNEL(ADC_Channel)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800303e:	b12a      	cbz	r2, 800304c <ADC_SelectDifferentialMode+0x10>
  {
    /* Set the DIFSEL bit */
   ADCx->DIFSEL |= (uint32_t)(1 << ADC_Channel );
 8003040:	fa03 f301 	lsl.w	r3, r3, r1
 8003044:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
 8003048:	4313      	orrs	r3, r2
 800304a:	e005      	b.n	8003058 <ADC_SelectDifferentialMode+0x1c>
  }
  else
  {
    /* Reset the DIFSEL bit */
   ADCx->DIFSEL &= ~(uint32_t)(1 << ADC_Channel);
 800304c:	fa03 f301 	lsl.w	r3, r3, r1
 8003050:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
 8003054:	ea22 0303 	bic.w	r3, r2, r3
 8003058:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 800305c:	4770      	bx	lr

0800305e <ADC_SelectQueueOfContextMode>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the JQM bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_JQM );
 800305e:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003060:	b111      	cbz	r1, 8003068 <ADC_SelectQueueOfContextMode+0xa>
  {
    /* Set the JQM bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_JQM );
 8003062:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8003066:	e001      	b.n	800306c <ADC_SelectQueueOfContextMode+0xe>
  }
  else
  {
    /* Reset the JQM bit */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_JQM);
 8003068:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800306c:	60c3      	str	r3, [r0, #12]
 800306e:	4770      	bx	lr

08003070 <ADC_AutoDelayCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the AUTDLY bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_AUTDLY );
 8003070:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003072:	b111      	cbz	r1, 800307a <ADC_AutoDelayCmd+0xa>
  {
    /* Set the AUTDLY bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_AUTDLY );
 8003074:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003078:	e001      	b.n	800307e <ADC_AutoDelayCmd+0xe>
  }
  else
  {
    /* Reset the AUTDLY bit */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_AUTDLY);
 800307a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800307e:	60c3      	str	r3, [r0, #12]
 8003080:	4770      	bx	lr

08003082 <ADC_AnalogWatchdogCmd>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  /* Get the old register value */
  tmpreg = ADCx->CFGR;
 8003082:	68c3      	ldr	r3, [r0, #12]
  /* Clear AWDEN, AWDENJ and AWDSGL bits */
  tmpreg &= ~(uint32_t)(ADC_CFGR_AWD1SGL|ADC_CFGR_AWD1EN|ADC_CFGR_JAWD1EN);
 8003084:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 8003088:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CFGR = tmpreg;
 800308a:	60c1      	str	r1, [r0, #12]
 800308c:	4770      	bx	lr

0800308e <ADC_AnalogWatchdog1ThresholdsConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  /* Set the ADCx high threshold */
  ADCx->TR1 &= ~(uint32_t)ADC_TR1_HT1;
 800308e:	6a03      	ldr	r3, [r0, #32]
 8003090:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 8003094:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8003098:	6203      	str	r3, [r0, #32]
  ADCx->TR1 |= (uint32_t)((uint32_t)HighThreshold << 16);
 800309a:	6a03      	ldr	r3, [r0, #32]
 800309c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80030a0:	6201      	str	r1, [r0, #32]

  /* Set the ADCx low threshold */
  ADCx->TR1 &= ~(uint32_t)ADC_TR1_LT1;
 80030a2:	6a03      	ldr	r3, [r0, #32]
 80030a4:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80030a8:	f023 030f 	bic.w	r3, r3, #15
 80030ac:	6203      	str	r3, [r0, #32]
  ADCx->TR1 |= LowThreshold;
 80030ae:	6a03      	ldr	r3, [r0, #32]
 80030b0:	431a      	orrs	r2, r3
 80030b2:	6202      	str	r2, [r0, #32]
 80030b4:	4770      	bx	lr

080030b6 <ADC_AnalogWatchdog2ThresholdsConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Set the ADCx high threshold */
  ADCx->TR2 &= ~(uint32_t)ADC_TR2_HT2;
 80030b6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80030b8:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 80030bc:	6243      	str	r3, [r0, #36]	; 0x24
  ADCx->TR2 |= (uint32_t)((uint32_t)HighThreshold << 16);
 80030be:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80030c0:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80030c4:	6241      	str	r1, [r0, #36]	; 0x24

  /* Set the ADCx low threshold */
  ADCx->TR2 &= ~(uint32_t)ADC_TR2_LT2;
 80030c6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80030c8:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80030cc:	6243      	str	r3, [r0, #36]	; 0x24
  ADCx->TR2 |= LowThreshold;
 80030ce:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80030d0:	431a      	orrs	r2, r3
 80030d2:	6242      	str	r2, [r0, #36]	; 0x24
 80030d4:	4770      	bx	lr

080030d6 <ADC_AnalogWatchdog3ThresholdsConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADCx high threshold */
  ADCx->TR3 &= ~(uint32_t)ADC_TR3_HT3;
 80030d6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80030d8:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 80030dc:	6283      	str	r3, [r0, #40]	; 0x28
  ADCx->TR3 |= (uint32_t)((uint32_t)HighThreshold << 16);
 80030de:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80030e0:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80030e4:	6281      	str	r1, [r0, #40]	; 0x28

  /* Set the ADCx low threshold */
  ADCx->TR3 &= ~(uint32_t)ADC_TR3_LT3;
 80030e6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80030e8:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80030ec:	6283      	str	r3, [r0, #40]	; 0x28
  ADCx->TR3 |= LowThreshold;
 80030ee:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80030f0:	431a      	orrs	r2, r3
 80030f2:	6282      	str	r2, [r0, #40]	; 0x28
 80030f4:	4770      	bx	lr

080030f6 <ADC_AnalogWatchdog1SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->CFGR;
 80030f6:	68c3      	ldr	r3, [r0, #12]
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_CFGR_AWD1CH;
 80030f8:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)((uint32_t)ADC_Channel << 26);
 80030fc:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
  /* Store the new register value */
  ADCx->CFGR = tmpreg;
 8003100:	60c1      	str	r1, [r0, #12]
 8003102:	4770      	bx	lr

08003104 <ADC_AnalogWatchdog2SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->AWD2CR;
 8003104:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD2CR_AWD2CH;
 8003108:	4b05      	ldr	r3, [pc, #20]	; (8003120 <ADC_AnalogWatchdog2SingleChannelConfig+0x1c>)
 800310a:	4013      	ands	r3, r2
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
  /* Store the new register value */
  ADCx->AWD2CR |= tmpreg;
 800310c:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
  /* Get the old register value */
  tmpreg = ADCx->AWD2CR;
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD2CR_AWD2CH;
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
 8003110:	4313      	orrs	r3, r2
 8003112:	2201      	movs	r2, #1
 8003114:	fa02 f101 	lsl.w	r1, r2, r1
  /* Store the new register value */
  ADCx->AWD2CR |= tmpreg;
 8003118:	430b      	orrs	r3, r1
 800311a:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
 800311e:	4770      	bx	lr
 8003120:	fff80001 	.word	0xfff80001

08003124 <ADC_AnalogWatchdog3SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->AWD3CR;
 8003124:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD3CR_AWD3CH;
 8003128:	4b05      	ldr	r3, [pc, #20]	; (8003140 <ADC_AnalogWatchdog3SingleChannelConfig+0x1c>)
 800312a:	4013      	ands	r3, r2
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
  /* Store the new register value */
  ADCx->AWD3CR |= tmpreg;
 800312c:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
  /* Get the old register value */
  tmpreg = ADCx->AWD3CR;
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD3CR_AWD3CH;
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
 8003130:	4313      	orrs	r3, r2
 8003132:	2201      	movs	r2, #1
 8003134:	fa02 f101 	lsl.w	r1, r2, r1
  /* Store the new register value */
  ADCx->AWD3CR |= tmpreg;
 8003138:	430b      	orrs	r3, r1
 800313a:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
 800313e:	4770      	bx	lr
 8003140:	fff80001 	.word	0xfff80001

08003144 <ADC_TempSensorCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8003144:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8003148:	d002      	beq.n	8003150 <ADC_TempSensorCmd+0xc>
 800314a:	4b07      	ldr	r3, [pc, #28]	; (8003168 <ADC_TempSensorCmd+0x24>)
 800314c:	4298      	cmp	r0, r3
 800314e:	d101      	bne.n	8003154 <ADC_TempSensorCmd+0x10>
 8003150:	4b06      	ldr	r3, [pc, #24]	; (800316c <ADC_TempSensorCmd+0x28>)
 8003152:	e000      	b.n	8003156 <ADC_TempSensorCmd+0x12>
 8003154:	4b06      	ldr	r3, [pc, #24]	; (8003170 <ADC_TempSensorCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the temperature sensor channel*/
      ADC3_4->CCR |= ADC34_CCR_TSEN;
 8003156:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_TSEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 8003158:	b111      	cbz	r1, 8003160 <ADC_TempSensorCmd+0x1c>
    {
      /* Enable the temperature sensor channel*/
      ADC3_4->CCR |= ADC34_CCR_TSEN;
 800315a:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 800315e:	e001      	b.n	8003164 <ADC_TempSensorCmd+0x20>
    }
    else
    {
      /* Disable the temperature sensor channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_TSEN;
 8003160:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8003164:	609a      	str	r2, [r3, #8]
 8003166:	4770      	bx	lr
 8003168:	50000100 	.word	0x50000100
 800316c:	50000300 	.word	0x50000300
 8003170:	50000700 	.word	0x50000700

08003174 <ADC_VrefintCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8003174:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8003178:	d002      	beq.n	8003180 <ADC_VrefintCmd+0xc>
 800317a:	4b07      	ldr	r3, [pc, #28]	; (8003198 <ADC_VrefintCmd+0x24>)
 800317c:	4298      	cmp	r0, r3
 800317e:	d101      	bne.n	8003184 <ADC_VrefintCmd+0x10>
 8003180:	4b06      	ldr	r3, [pc, #24]	; (800319c <ADC_VrefintCmd+0x28>)
 8003182:	e000      	b.n	8003186 <ADC_VrefintCmd+0x12>
 8003184:	4b06      	ldr	r3, [pc, #24]	; (80031a0 <ADC_VrefintCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the Vrefint channel*/
      ADC3_4->CCR |= ADC34_CCR_VREFEN;
 8003186:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_VREFEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 8003188:	b111      	cbz	r1, 8003190 <ADC_VrefintCmd+0x1c>
    {
      /* Enable the Vrefint channel*/
      ADC3_4->CCR |= ADC34_CCR_VREFEN;
 800318a:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800318e:	e001      	b.n	8003194 <ADC_VrefintCmd+0x20>
    }
    else
    {
      /* Disable the Vrefint channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_VREFEN;
 8003190:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 8003194:	609a      	str	r2, [r3, #8]
 8003196:	4770      	bx	lr
 8003198:	50000100 	.word	0x50000100
 800319c:	50000300 	.word	0x50000300
 80031a0:	50000700 	.word	0x50000700

080031a4 <ADC_VbatCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 80031a4:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 80031a8:	d002      	beq.n	80031b0 <ADC_VbatCmd+0xc>
 80031aa:	4b07      	ldr	r3, [pc, #28]	; (80031c8 <ADC_VbatCmd+0x24>)
 80031ac:	4298      	cmp	r0, r3
 80031ae:	d101      	bne.n	80031b4 <ADC_VbatCmd+0x10>
 80031b0:	4b06      	ldr	r3, [pc, #24]	; (80031cc <ADC_VbatCmd+0x28>)
 80031b2:	e000      	b.n	80031b6 <ADC_VbatCmd+0x12>
 80031b4:	4b06      	ldr	r3, [pc, #24]	; (80031d0 <ADC_VbatCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the Vbat channel*/
      ADC3_4->CCR |= ADC34_CCR_VBATEN;
 80031b6:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_VBATEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 80031b8:	b111      	cbz	r1, 80031c0 <ADC_VbatCmd+0x1c>
    {
      /* Enable the Vbat channel*/
      ADC3_4->CCR |= ADC34_CCR_VBATEN;
 80031ba:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80031be:	e001      	b.n	80031c4 <ADC_VbatCmd+0x20>
    }
    else
    {
      /* Disable the Vbat channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_VBATEN;
 80031c0:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80031c4:	609a      	str	r2, [r3, #8]
 80031c6:	4770      	bx	lr
 80031c8:	50000100 	.word	0x50000100
 80031cc:	50000300 	.word	0x50000300
 80031d0:	50000700 	.word	0x50000700

080031d4 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
 80031d4:	2a04      	cmp	r2, #4
  *     @arg ADC_SampleTime_181Cycles5: Sample time equal to 181.5 cycles	
  *     @arg ADC_SampleTime_601Cycles5: Sample time equal to 601.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80031d6:	b570      	push	{r4, r5, r6, lr}
 80031d8:	f04f 0406 	mov.w	r4, #6
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
 80031dc:	d80b      	bhi.n	80031f6 <ADC_RegularChannelConfig+0x22>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = 0x1F << (6 * (Rank ));
 80031de:	4362      	muls	r2, r4
 80031e0:	241f      	movs	r4, #31
 80031e2:	fa04 f402 	lsl.w	r4, r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank));
 80031e6:	fa01 f202 	lsl.w	r2, r1, r2
  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 80031ea:	6b05      	ldr	r5, [r0, #48]	; 0x30
    /* Calculate the mask to clear */
    tmpreg2 = 0x1F << (6 * (Rank ));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80031ec:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80031f0:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 80031f2:	6302      	str	r2, [r0, #48]	; 0x30
 80031f4:	e029      	b.n	800324a <ADC_RegularChannelConfig+0x76>
  }
  /* For Rank 5 to 9 */
  else if (Rank < 10)
 80031f6:	2a09      	cmp	r2, #9
 80031f8:	d80c      	bhi.n	8003214 <ADC_RegularChannelConfig+0x40>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR2_SQ5 << (6 * (Rank - 5));
 80031fa:	4362      	muls	r2, r4
 80031fc:	241f      	movs	r4, #31
 80031fe:	3a1e      	subs	r2, #30
 8003200:	fa04 f402 	lsl.w	r4, r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 5));
 8003204:	fa01 f202 	lsl.w	r2, r1, r2
  }
  /* For Rank 5 to 9 */
  else if (Rank < 10)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8003208:	6b45      	ldr	r5, [r0, #52]	; 0x34
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR2_SQ5 << (6 * (Rank - 5));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 800320a:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 5));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800320e:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8003210:	6342      	str	r2, [r0, #52]	; 0x34
 8003212:	e01a      	b.n	800324a <ADC_RegularChannelConfig+0x76>
  }
  /* For Rank 10 to 14 */
  else if (Rank < 15)
 8003214:	2a0e      	cmp	r2, #14
 8003216:	d80c      	bhi.n	8003232 <ADC_RegularChannelConfig+0x5e>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ10 << (6 * (Rank - 10));
 8003218:	4362      	muls	r2, r4
 800321a:	241f      	movs	r4, #31
 800321c:	3a3c      	subs	r2, #60	; 0x3c
 800321e:	fa04 f402 	lsl.w	r4, r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 10));
 8003222:	fa01 f202 	lsl.w	r2, r1, r2
  }
  /* For Rank 10 to 14 */
  else if (Rank < 15)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8003226:	6b85      	ldr	r5, [r0, #56]	; 0x38
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ10 << (6 * (Rank - 10));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8003228:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 10));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800322c:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 800322e:	6382      	str	r2, [r0, #56]	; 0x38
 8003230:	e00b      	b.n	800324a <ADC_RegularChannelConfig+0x76>
  else 
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR4;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ15 << (6 * (Rank - 15));
 8003232:	4362      	muls	r2, r4
 8003234:	241f      	movs	r4, #31
 8003236:	3a5a      	subs	r2, #90	; 0x5a
 8003238:	fa04 f402 	lsl.w	r4, r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 15));
 800323c:	fa01 f202 	lsl.w	r2, r1, r2
    ADCx->SQR3 = tmpreg1;
  }
  else 
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR4;
 8003240:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ15 << (6 * (Rank - 15));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8003242:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 15));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8003246:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR4 = tmpreg1;
 8003248:	63c2      	str	r2, [r0, #60]	; 0x3c
  }

  /* Channel sampling configuration */
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 800324a:	2909      	cmp	r1, #9
 800324c:	f04f 0203 	mov.w	r2, #3
 8003250:	d90f      	bls.n	8003272 <ADC_RegularChannelConfig+0x9e>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR2_SMP10 << (3 * (ADC_Channel - 10));
 8003252:	434a      	muls	r2, r1
 8003254:	2107      	movs	r1, #7
 8003256:	3a1e      	subs	r2, #30
 8003258:	fa01 f102 	lsl.w	r1, r1, r2
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg2;
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 800325c:	fa03 f202 	lsl.w	r2, r3, r2
  /* Channel sampling configuration */
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8003260:	6984      	ldr	r4, [r0, #24]
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR2_SMP10 << (3 * (ADC_Channel - 10));
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg2;
 8003262:	6984      	ldr	r4, [r0, #24]
 8003264:	ea24 0101 	bic.w	r1, r4, r1
 8003268:	6181      	str	r1, [r0, #24]
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 800326a:	6984      	ldr	r4, [r0, #24]
 800326c:	4322      	orrs	r2, r4
 800326e:	6182      	str	r2, [r0, #24]
 8003270:	bd70      	pop	{r4, r5, r6, pc}

  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8003272:	6944      	ldr	r4, [r0, #20]
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR1_SMP1 << (3 * (ADC_Channel - 1));
 8003274:	1e4c      	subs	r4, r1, #1
 8003276:	4354      	muls	r4, r2
 8003278:	2638      	movs	r6, #56	; 0x38
 800327a:	fa06 f404 	lsl.w	r4, r6, r4
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg2;
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel));
 800327e:	4351      	muls	r1, r2
 8003280:	fa03 f301 	lsl.w	r3, r3, r1
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR1_SMP1 << (3 * (ADC_Channel - 1));
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg2;
 8003284:	6945      	ldr	r5, [r0, #20]
 8003286:	ea25 0404 	bic.w	r4, r5, r4
 800328a:	6144      	str	r4, [r0, #20]
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel));
 800328c:	6944      	ldr	r4, [r0, #20]
 800328e:	4323      	orrs	r3, r4
 8003290:	6143      	str	r3, [r0, #20]
 8003292:	bd70      	pop	{r4, r5, r6, pc}

08003294 <ADC_RegularChannelSequencerLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Configure the ADC sequence lenght */  
  ADCx->SQR1 &= ~(uint32_t)ADC_SQR1_L;
 8003294:	6b03      	ldr	r3, [r0, #48]	; 0x30
  ADCx->SQR1 |= (uint32_t)(SequencerLength - 1);   
 8003296:	3901      	subs	r1, #1
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Configure the ADC sequence lenght */  
  ADCx->SQR1 &= ~(uint32_t)ADC_SQR1_L;
 8003298:	f023 030f 	bic.w	r3, r3, #15
 800329c:	6303      	str	r3, [r0, #48]	; 0x30
  ADCx->SQR1 |= (uint32_t)(SequencerLength - 1);   
 800329e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80032a0:	430b      	orrs	r3, r1
 80032a2:	6303      	str	r3, [r0, #48]	; 0x30
 80032a4:	4770      	bx	lr

080032a6 <ADC_ExternalTriggerConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_TRIG(ADC_ExternalTrigConvEvent));
  assert_param(IS_EXTERNALTRIG_EDGE(ADC_ExternalTrigEventEdge));

  /* Disable the selected ADC conversion on external event */
  ADCx->CFGR &= ~(ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL);
 80032a6:	68c3      	ldr	r3, [r0, #12]
  ADCx->CFGR |= (uint32_t)(ADC_ExternalTrigEventEdge | ADC_ExternalTrigConvEvent);
 80032a8:	430a      	orrs	r2, r1
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_TRIG(ADC_ExternalTrigConvEvent));
  assert_param(IS_EXTERNALTRIG_EDGE(ADC_ExternalTrigEventEdge));

  /* Disable the selected ADC conversion on external event */
  ADCx->CFGR &= ~(ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL);
 80032aa:	f423 637c 	bic.w	r3, r3, #4032	; 0xfc0
 80032ae:	60c3      	str	r3, [r0, #12]
  ADCx->CFGR |= (uint32_t)(ADC_ExternalTrigEventEdge | ADC_ExternalTrigConvEvent);
 80032b0:	68c3      	ldr	r3, [r0, #12]
 80032b2:	4313      	orrs	r3, r2
 80032b4:	60c3      	str	r3, [r0, #12]
 80032b6:	4770      	bx	lr

080032b8 <ADC_StartConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADSTART bit */
  ADCx->CR |= ADC_CR_ADSTART;
 80032b8:	6883      	ldr	r3, [r0, #8]
 80032ba:	f043 0304 	orr.w	r3, r3, #4
 80032be:	6083      	str	r3, [r0, #8]
 80032c0:	4770      	bx	lr

080032c2 <ADC_GetStartConversionStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of ADSTART bit */
  if ((ADCx->CR & ADC_CR_ADSTART) != (uint32_t)RESET)
 80032c2:	6880      	ldr	r0, [r0, #8]
    /* ADSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the ADSTART bit status */
  return  bitstatus;
}
 80032c4:	f3c0 0080 	ubfx	r0, r0, #2, #1
 80032c8:	4770      	bx	lr

080032ca <ADC_StopConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADSTP bit */
   ADCx->CR |= ADC_CR_ADSTP;
 80032ca:	6883      	ldr	r3, [r0, #8]
 80032cc:	f043 0310 	orr.w	r3, r3, #16
 80032d0:	6083      	str	r3, [r0, #8]
 80032d2:	4770      	bx	lr

080032d4 <ADC_DiscModeChannelCountConfig>:
  uint32_t tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CFGR;
 80032d4:	68c3      	ldr	r3, [r0, #12]
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= ~(uint32_t)(ADC_CFGR_DISCNUM);
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
 80032d6:	3901      	subs	r1, #1
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CFGR;
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= ~(uint32_t)(ADC_CFGR_DISCNUM);
 80032d8:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 17;
 80032dc:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
  /* Store the new register value */
  ADCx->CFGR = tmpreg1;
 80032e0:	60c3      	str	r3, [r0, #12]
 80032e2:	4770      	bx	lr

080032e4 <ADC_DiscModeCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_DISCEN;
 80032e4:	68c3      	ldr	r3, [r0, #12]
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80032e6:	b111      	cbz	r1, 80032ee <ADC_DiscModeCmd+0xa>
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_DISCEN;
 80032e8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80032ec:	e001      	b.n	80032f2 <ADC_DiscModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_DISCEN);
 80032ee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80032f2:	60c3      	str	r3, [r0, #12]
 80032f4:	4770      	bx	lr

080032f6 <ADC_GetConversionValue>:
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 80032f6:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 80032f8:	b280      	uxth	r0, r0
 80032fa:	4770      	bx	lr

080032fc <ADC_GetDualModeConversionValue>:
  uint32_t tmpreg1 = 0;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  if((ADCx == ADC1) || (ADCx== ADC2))
 80032fc:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8003300:	d002      	beq.n	8003308 <ADC_GetDualModeConversionValue+0xc>
 8003302:	4b04      	ldr	r3, [pc, #16]	; (8003314 <ADC_GetDualModeConversionValue+0x18>)
 8003304:	4298      	cmp	r0, r3
 8003306:	d101      	bne.n	800330c <ADC_GetDualModeConversionValue+0x10>
  {
    /* Get the dual mode conversion value */
    tmpreg1 = ADC1_2->CDR;
 8003308:	4b03      	ldr	r3, [pc, #12]	; (8003318 <ADC_GetDualModeConversionValue+0x1c>)
 800330a:	e000      	b.n	800330e <ADC_GetDualModeConversionValue+0x12>
  }
  else
  {	
    /* Get the dual mode conversion value */
    tmpreg1 = ADC3_4->CDR;
 800330c:	4b03      	ldr	r3, [pc, #12]	; (800331c <ADC_GetDualModeConversionValue+0x20>)
 800330e:	68d8      	ldr	r0, [r3, #12]
  }
  /* Return the dual mode conversion value */
  return (uint32_t) tmpreg1;
}
 8003310:	4770      	bx	lr
 8003312:	bf00      	nop
 8003314:	50000100 	.word	0x50000100
 8003318:	50000300 	.word	0x50000300
 800331c:	50000700 	.word	0x50000700

08003320 <ADC_SetChannelOffset1>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR1 &= ~ (uint32_t) ADC_OFR1_OFFSET1_CH;
 8003320:	6e03      	ldr	r3, [r0, #96]	; 0x60
 8003322:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 8003326:	6603      	str	r3, [r0, #96]	; 0x60
  ADCx->OFR1 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 8003328:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800332a:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 800332e:	6601      	str	r1, [r0, #96]	; 0x60

  /* Set the data offset */
  ADCx->OFR1 &= ~ (uint32_t) ADC_OFR1_OFFSET1;
 8003330:	6e03      	ldr	r3, [r0, #96]	; 0x60
 8003332:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8003336:	f023 030f 	bic.w	r3, r3, #15
 800333a:	6603      	str	r3, [r0, #96]	; 0x60
  ADCx->OFR1 |= (uint32_t)Offset;
 800333c:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800333e:	431a      	orrs	r2, r3
 8003340:	6602      	str	r2, [r0, #96]	; 0x60
 8003342:	4770      	bx	lr

08003344 <ADC_SetChannelOffset2>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR2 &= ~ (uint32_t) ADC_OFR2_OFFSET2_CH;
 8003344:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8003346:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 800334a:	6643      	str	r3, [r0, #100]	; 0x64
  ADCx->OFR2 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 800334c:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800334e:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 8003352:	6641      	str	r1, [r0, #100]	; 0x64

  /* Set the data offset */
  ADCx->OFR2 &= ~ (uint32_t) ADC_OFR2_OFFSET2;
 8003354:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8003356:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800335a:	f023 030f 	bic.w	r3, r3, #15
 800335e:	6643      	str	r3, [r0, #100]	; 0x64
  ADCx->OFR2 |= (uint32_t)Offset;
 8003360:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8003362:	431a      	orrs	r2, r3
 8003364:	6642      	str	r2, [r0, #100]	; 0x64
 8003366:	4770      	bx	lr

08003368 <ADC_SetChannelOffset3>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR3 &= ~ (uint32_t) ADC_OFR3_OFFSET3_CH;
 8003368:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800336a:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 800336e:	6683      	str	r3, [r0, #104]	; 0x68
  ADCx->OFR3 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 8003370:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8003372:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 8003376:	6681      	str	r1, [r0, #104]	; 0x68

  /* Set the data offset */
  ADCx->OFR3 &= ~ (uint32_t) ADC_OFR3_OFFSET3;
 8003378:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800337a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800337e:	f023 030f 	bic.w	r3, r3, #15
 8003382:	6683      	str	r3, [r0, #104]	; 0x68
  ADCx->OFR3 |= (uint32_t)Offset;
 8003384:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8003386:	431a      	orrs	r2, r3
 8003388:	6682      	str	r2, [r0, #104]	; 0x68
 800338a:	4770      	bx	lr

0800338c <ADC_SetChannelOffset4>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR4 &= ~ (uint32_t) ADC_OFR4_OFFSET4_CH;
 800338c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800338e:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 8003392:	66c3      	str	r3, [r0, #108]	; 0x6c
  ADCx->OFR4 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 8003394:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8003396:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 800339a:	66c1      	str	r1, [r0, #108]	; 0x6c

  /* Set the data offset */
  ADCx->OFR4 &= ~ (uint32_t) ADC_OFR4_OFFSET4;
 800339c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800339e:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80033a2:	f023 030f 	bic.w	r3, r3, #15
 80033a6:	66c3      	str	r3, [r0, #108]	; 0x6c
  ADCx->OFR4 |= (uint32_t)Offset;
 80033a8:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80033aa:	431a      	orrs	r2, r3
 80033ac:	66c2      	str	r2, [r0, #108]	; 0x6c
 80033ae:	4770      	bx	lr

080033b0 <ADC_ChannelOffset1Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR1 |= ADC_OFR1_OFFSET1_EN;
 80033b0:	6e03      	ldr	r3, [r0, #96]	; 0x60
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80033b2:	b111      	cbz	r1, 80033ba <ADC_ChannelOffset1Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR1 |= ADC_OFR1_OFFSET1_EN;
 80033b4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80033b8:	e001      	b.n	80033be <ADC_ChannelOffset1Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR1 &= ~(ADC_OFR1_OFFSET1_EN);
 80033ba:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80033be:	6603      	str	r3, [r0, #96]	; 0x60
 80033c0:	4770      	bx	lr

080033c2 <ADC_ChannelOffset2Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR2 |= ADC_OFR2_OFFSET2_EN;
 80033c2:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80033c4:	b111      	cbz	r1, 80033cc <ADC_ChannelOffset2Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR2 |= ADC_OFR2_OFFSET2_EN;
 80033c6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80033ca:	e001      	b.n	80033d0 <ADC_ChannelOffset2Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR2 &= ~(ADC_OFR2_OFFSET2_EN);
 80033cc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80033d0:	6643      	str	r3, [r0, #100]	; 0x64
 80033d2:	4770      	bx	lr

080033d4 <ADC_ChannelOffset3Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR3 |= ADC_OFR3_OFFSET3_EN;
 80033d4:	6e83      	ldr	r3, [r0, #104]	; 0x68
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80033d6:	b111      	cbz	r1, 80033de <ADC_ChannelOffset3Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR3 |= ADC_OFR3_OFFSET3_EN;
 80033d8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80033dc:	e001      	b.n	80033e2 <ADC_ChannelOffset3Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR3 &= ~(ADC_OFR3_OFFSET3_EN);
 80033de:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80033e2:	6683      	str	r3, [r0, #104]	; 0x68
 80033e4:	4770      	bx	lr

080033e6 <ADC_ChannelOffset4Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR4 |= ADC_OFR4_OFFSET4_EN;
 80033e6:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80033e8:	b111      	cbz	r1, 80033f0 <ADC_ChannelOffset4Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR4 |= ADC_OFR4_OFFSET4_EN;
 80033ea:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80033ee:	e001      	b.n	80033f4 <ADC_ChannelOffset4Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR4 &= ~(ADC_OFR4_OFFSET4_EN);
 80033f0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80033f4:	66c3      	str	r3, [r0, #108]	; 0x6c
 80033f6:	4770      	bx	lr

080033f8 <ADC_DMACmd>:
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CFGR |= ADC_CFGR_DMAEN;
 80033f8:	68c3      	ldr	r3, [r0, #12]
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80033fa:	b111      	cbz	r1, 8003402 <ADC_DMACmd+0xa>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CFGR |= ADC_CFGR_DMAEN;
 80033fc:	f043 0301 	orr.w	r3, r3, #1
 8003400:	e001      	b.n	8003406 <ADC_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CFGR &= ~(uint32_t)ADC_CFGR_DMAEN;
 8003402:	f023 0301 	bic.w	r3, r3, #1
 8003406:	60c3      	str	r3, [r0, #12]
 8003408:	4770      	bx	lr

0800340a <ADC_DMAConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_ADC_DMA_MODE(ADC_DMAMode));

  /* Set or reset the DMACFG bit */
   ADCx->CFGR &= ~(uint32_t)ADC_CFGR_DMACFG;
 800340a:	68c3      	ldr	r3, [r0, #12]
 800340c:	f023 0302 	bic.w	r3, r3, #2
 8003410:	60c3      	str	r3, [r0, #12]
   ADCx->CFGR |= ADC_DMAMode;
 8003412:	68c3      	ldr	r3, [r0, #12]
 8003414:	4319      	orrs	r1, r3
 8003416:	60c1      	str	r1, [r0, #12]
 8003418:	4770      	bx	lr

0800341a <ADC_InjectedChannelSampleTimeConfig>:
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Channel sampling configuration */
  /* if ADC_InjectedChannel_10 ... ADC_InjectedChannel_18 is selected */
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
 800341a:	2909      	cmp	r1, #9
  *     @arg ADC_SampleTime_181Cycles5: Sample time equal to 181.5 cycles	
  *     @arg ADC_SampleTime_601Cycles5: Sample time equal to 601.5 cycles	
  * @retval None
  */
void ADC_InjectedChannelSampleTimeConfig(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint8_t ADC_SampleTime)
{
 800341c:	b570      	push	{r4, r5, r6, lr}
 800341e:	f04f 0303 	mov.w	r3, #3
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Channel sampling configuration */
  /* if ADC_InjectedChannel_10 ... ADC_InjectedChannel_18 is selected */
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
 8003422:	d90e      	bls.n	8003442 <ADC_InjectedChannelSampleTimeConfig+0x28>
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR2_SMP10 << (3 * (ADC_InjectedChannel - 10));
 8003424:	434b      	muls	r3, r1
 8003426:	2107      	movs	r1, #7
 8003428:	3b1e      	subs	r3, #30
 800342a:	fa01 f103 	lsl.w	r1, r1, r3
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg1;
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel - 10));
 800342e:	fa02 f303 	lsl.w	r3, r2, r3
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR2_SMP10 << (3 * (ADC_InjectedChannel - 10));
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg1;
 8003432:	6984      	ldr	r4, [r0, #24]
 8003434:	ea24 0101 	bic.w	r1, r4, r1
 8003438:	6181      	str	r1, [r0, #24]
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel - 10));
 800343a:	6984      	ldr	r4, [r0, #24]
 800343c:	4323      	orrs	r3, r4
 800343e:	6183      	str	r3, [r0, #24]
 8003440:	bd70      	pop	{r4, r5, r6, pc}

  }
  else /* ADC_InjectedChannel include in ADC_InjectedChannel_[0..9] */
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR1_SMP1 << (3 * (ADC_InjectedChannel - 1));
 8003442:	1e4c      	subs	r4, r1, #1
 8003444:	435c      	muls	r4, r3
 8003446:	2638      	movs	r6, #56	; 0x38
 8003448:	fa06 f404 	lsl.w	r4, r6, r4
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg1;
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel));
 800344c:	4359      	muls	r1, r3
 800344e:	fa02 f201 	lsl.w	r2, r2, r1
  else /* ADC_InjectedChannel include in ADC_InjectedChannel_[0..9] */
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR1_SMP1 << (3 * (ADC_InjectedChannel - 1));
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg1;
 8003452:	6945      	ldr	r5, [r0, #20]
 8003454:	ea25 0404 	bic.w	r4, r5, r4
 8003458:	6144      	str	r4, [r0, #20]
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel));
 800345a:	6944      	ldr	r4, [r0, #20]
 800345c:	4322      	orrs	r2, r4
 800345e:	6142      	str	r2, [r0, #20]
 8003460:	bd70      	pop	{r4, r5, r6, pc}

08003462 <ADC_StartInjectedConversion>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Enable the selected ADC conversion for injected group on external event and start the selected
     ADC injected conversion */
  ADCx->CR |= ADC_CR_JADSTART;
 8003462:	6883      	ldr	r3, [r0, #8]
 8003464:	f043 0308 	orr.w	r3, r3, #8
 8003468:	6083      	str	r3, [r0, #8]
 800346a:	4770      	bx	lr

0800346c <ADC_StopInjectedConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the JADSTP bit */
   ADCx->CR |= ADC_CR_JADSTP;
 800346c:	6883      	ldr	r3, [r0, #8]
 800346e:	f043 0320 	orr.w	r3, r3, #32
 8003472:	6083      	str	r3, [r0, #8]
 8003474:	4770      	bx	lr

08003476 <ADC_GetStartInjectedConversionStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of JADSTART bit */
  if ((ADCx->CR & ADC_CR_JADSTART) != (uint32_t)RESET)
 8003476:	6880      	ldr	r0, [r0, #8]
    /* JADSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the JADSTART bit status */
  return  bitstatus;
}
 8003478:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 800347c:	4770      	bx	lr

0800347e <ADC_AutoInjectedConvCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CFGR |= ADC_CFGR_JAUTO;
 800347e:	68c3      	ldr	r3, [r0, #12]
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003480:	b111      	cbz	r1, 8003488 <ADC_AutoInjectedConvCmd+0xa>
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CFGR |= ADC_CFGR_JAUTO;
 8003482:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003486:	e001      	b.n	800348c <ADC_AutoInjectedConvCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CFGR &= ~ADC_CFGR_JAUTO;
 8003488:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 800348c:	60c3      	str	r3, [r0, #12]
 800348e:	4770      	bx	lr

08003490 <ADC_InjectedDiscModeCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_JDISCEN;
 8003490:	68c3      	ldr	r3, [r0, #12]
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003492:	b111      	cbz	r1, 800349a <ADC_InjectedDiscModeCmd+0xa>
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_JDISCEN;
 8003494:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8003498:	e001      	b.n	800349e <ADC_InjectedDiscModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CFGR &= ~ADC_CFGR_JDISCEN;
 800349a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 800349e:	60c3      	str	r3, [r0, #12]
 80034a0:	4770      	bx	lr

080034a2 <ADC_GetInjectedConversionValue>:
  *     @arg ADC_InjectedSequence_3: Injected Sequence3 selected
  *     @arg ADC_InjectedSequence_4: Injected Sequence4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedSequence)
{
 80034a2:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80034a4:	2300      	movs	r3, #0
 80034a6:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_SEQUENCE(ADC_InjectedSequence));

  tmp = (uint32_t)ADCx;
 80034a8:	9001      	str	r0, [sp, #4]
  tmp += ((ADC_InjectedSequence - 1 )<< 2) + JDR_Offset;
 80034aa:	9b01      	ldr	r3, [sp, #4]
 80034ac:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80034b0:	f101 037c 	add.w	r3, r1, #124	; 0x7c
 80034b4:	9301      	str	r3, [sp, #4]
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp);   
 80034b6:	9b01      	ldr	r3, [sp, #4]
 80034b8:	6818      	ldr	r0, [r3, #0]
}
 80034ba:	b280      	uxth	r0, r0
 80034bc:	b002      	add	sp, #8
 80034be:	4770      	bx	lr

080034c0 <ADC_ITConfig>:
  assert_param(IS_ADC_IT(ADC_IT));

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC interrupts */
    ADCx->IER |= ADC_IT;
 80034c0:	6843      	ldr	r3, [r0, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT));

  if (NewState != DISABLE)
 80034c2:	b10a      	cbz	r2, 80034c8 <ADC_ITConfig+0x8>
  {
    /* Enable the selected ADC interrupts */
    ADCx->IER |= ADC_IT;
 80034c4:	4319      	orrs	r1, r3
 80034c6:	e001      	b.n	80034cc <ADC_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->IER &= (~(uint32_t)ADC_IT);
 80034c8:	ea23 0101 	bic.w	r1, r3, r1
 80034cc:	6041      	str	r1, [r0, #4]
 80034ce:	4770      	bx	lr

080034d0 <ADC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->ISR & ADC_FLAG) != (uint32_t)RESET)
 80034d0:	6803      	ldr	r3, [r0, #0]
 80034d2:	4219      	tst	r1, r3
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 80034d4:	bf0c      	ite	eq
 80034d6:	2000      	moveq	r0, #0
 80034d8:	2001      	movne	r0, #1
 80034da:	4770      	bx	lr

080034dc <ADC_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
  /* Clear the selected ADC flags */
  ADCx->ISR = (uint32_t)ADC_FLAG;
 80034dc:	6001      	str	r1, [r0, #0]
 80034de:	4770      	bx	lr

080034e0 <ADC_GetCommonFlagStatus>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_COMMONFLAG(ADC_FLAG));

  if((ADCx == ADC1) || (ADCx == ADC2))
 80034e0:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 80034e4:	d002      	beq.n	80034ec <ADC_GetCommonFlagStatus+0xc>
 80034e6:	4b06      	ldr	r3, [pc, #24]	; (8003500 <ADC_GetCommonFlagStatus+0x20>)
 80034e8:	4298      	cmp	r0, r3
 80034ea:	d101      	bne.n	80034f0 <ADC_GetCommonFlagStatus+0x10>
  {
    tmpreg1 = ADC1_2->CSR;
 80034ec:	4b05      	ldr	r3, [pc, #20]	; (8003504 <ADC_GetCommonFlagStatus+0x24>)
 80034ee:	e000      	b.n	80034f2 <ADC_GetCommonFlagStatus+0x12>
  }
  else
  {
    tmpreg1 = ADC3_4->CSR;
 80034f0:	4b05      	ldr	r3, [pc, #20]	; (8003508 <ADC_GetCommonFlagStatus+0x28>)
 80034f2:	681b      	ldr	r3, [r3, #0]
  }  
  /* Check the status of the specified ADC flag */
  if ((tmpreg1 & ADC_FLAG) != (uint32_t)RESET)
 80034f4:	420b      	tst	r3, r1
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 80034f6:	bf0c      	ite	eq
 80034f8:	2000      	moveq	r0, #0
 80034fa:	2001      	movne	r0, #1
 80034fc:	4770      	bx	lr
 80034fe:	bf00      	nop
 8003500:	50000100 	.word	0x50000100
 8003504:	50000300 	.word	0x50000300
 8003508:	50000700 	.word	0x50000700

0800350c <ADC_ClearCommonFlag>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_COMMONFLAG(ADC_FLAG));

  if((ADCx == ADC1) || (ADCx == ADC2))
 800350c:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8003510:	d002      	beq.n	8003518 <ADC_ClearCommonFlag+0xc>
 8003512:	4b05      	ldr	r3, [pc, #20]	; (8003528 <ADC_ClearCommonFlag+0x1c>)
 8003514:	4298      	cmp	r0, r3
 8003516:	d101      	bne.n	800351c <ADC_ClearCommonFlag+0x10>
  {
    /* Clear the selected ADC flags */
    ADC1_2->CSR |= (uint32_t)ADC_FLAG;
 8003518:	4b04      	ldr	r3, [pc, #16]	; (800352c <ADC_ClearCommonFlag+0x20>)
 800351a:	e000      	b.n	800351e <ADC_ClearCommonFlag+0x12>
  }
  else
  {
    /* Clear the selected ADC flags */
    ADC3_4->CSR |= (uint32_t)ADC_FLAG;
 800351c:	4b04      	ldr	r3, [pc, #16]	; (8003530 <ADC_ClearCommonFlag+0x24>)
 800351e:	681a      	ldr	r2, [r3, #0]
 8003520:	4311      	orrs	r1, r2
 8003522:	6019      	str	r1, [r3, #0]
 8003524:	4770      	bx	lr
 8003526:	bf00      	nop
 8003528:	50000100 	.word	0x50000100
 800352c:	50000300 	.word	0x50000300
 8003530:	50000700 	.word	0x50000700

08003534 <ADC_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_IT(ADC_IT));
   
  itstatus = ADCx->ISR & ADC_IT;
 8003534:	6803      	ldr	r3, [r0, #0]
 8003536:	b289      	uxth	r1, r1
  
  itenable = ADCx->IER & ADC_IT;
 8003538:	6842      	ldr	r2, [r0, #4]
  if ((itstatus != (uint32_t)RESET) && (itenable != (uint32_t)RESET))
 800353a:	ea11 0003 	ands.w	r0, r1, r3
 800353e:	d003      	beq.n	8003548 <ADC_GetITStatus+0x14>
 8003540:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 8003542:	bf0c      	ite	eq
 8003544:	2000      	moveq	r0, #0
 8003546:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8003548:	4770      	bx	lr

0800354a <ADC_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT));
  /* Clear the selected ADC interrupt pending bit */
  ADCx->ISR |= (uint32_t)ADC_IT;
 800354a:	6803      	ldr	r3, [r0, #0]
 800354c:	4319      	orrs	r1, r3
 800354e:	6001      	str	r1, [r0, #0]
 8003550:	4770      	bx	lr
 8003552:	bf00      	nop

08003554 <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));

  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR_EN);
 8003554:	6802      	ldr	r2, [r0, #0]
 8003556:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800355a:	4013      	ands	r3, r2
 800355c:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 800355e:	2300      	movs	r3, #0
 8003560:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8003562:	6043      	str	r3, [r0, #4]

  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8003564:	6083      	str	r3, [r0, #8]

  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 8003566:	60c3      	str	r3, [r0, #12]

  if (DMAy_Channelx == DMA1_Channel1)
 8003568:	4b2c      	ldr	r3, [pc, #176]	; (800361c <DMA_DeInit+0xc8>)
 800356a:	4298      	cmp	r0, r3
 800356c:	d100      	bne.n	8003570 <DMA_DeInit+0x1c>
 800356e:	e026      	b.n	80035be <DMA_DeInit+0x6a>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_CHANNEL1_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8003570:	4b2b      	ldr	r3, [pc, #172]	; (8003620 <DMA_DeInit+0xcc>)
 8003572:	4298      	cmp	r0, r3
 8003574:	d100      	bne.n	8003578 <DMA_DeInit+0x24>
 8003576:	e02c      	b.n	80035d2 <DMA_DeInit+0x7e>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_CHANNEL2_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8003578:	4b2a      	ldr	r3, [pc, #168]	; (8003624 <DMA_DeInit+0xd0>)
 800357a:	4298      	cmp	r0, r3
 800357c:	d100      	bne.n	8003580 <DMA_DeInit+0x2c>
 800357e:	e032      	b.n	80035e6 <DMA_DeInit+0x92>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_CHANNEL3_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8003580:	4b29      	ldr	r3, [pc, #164]	; (8003628 <DMA_DeInit+0xd4>)
 8003582:	4298      	cmp	r0, r3
 8003584:	d100      	bne.n	8003588 <DMA_DeInit+0x34>
 8003586:	e038      	b.n	80035fa <DMA_DeInit+0xa6>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_CHANNEL4_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8003588:	4b28      	ldr	r3, [pc, #160]	; (800362c <DMA_DeInit+0xd8>)
 800358a:	4298      	cmp	r0, r3
 800358c:	d100      	bne.n	8003590 <DMA_DeInit+0x3c>
 800358e:	e03e      	b.n	800360e <DMA_DeInit+0xba>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_CHANNEL5_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 8003590:	4b27      	ldr	r3, [pc, #156]	; (8003630 <DMA_DeInit+0xdc>)
 8003592:	4298      	cmp	r0, r3
 8003594:	d106      	bne.n	80035a4 <DMA_DeInit+0x50>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_CHANNEL6_IT_MASK;
 8003596:	f853 2c68 	ldr.w	r2, [r3, #-104]
 800359a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800359e:	f843 2c68 	str.w	r2, [r3, #-104]
 80035a2:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 80035a4:	4b23      	ldr	r3, [pc, #140]	; (8003634 <DMA_DeInit+0xe0>)
 80035a6:	4298      	cmp	r0, r3
 80035a8:	d106      	bne.n	80035b8 <DMA_DeInit+0x64>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_CHANNEL7_IT_MASK;
 80035aa:	f853 2c7c 	ldr.w	r2, [r3, #-124]
 80035ae:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 80035b2:	f843 2c7c 	str.w	r2, [r3, #-124]
 80035b6:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 80035b8:	4b1f      	ldr	r3, [pc, #124]	; (8003638 <DMA_DeInit+0xe4>)
 80035ba:	4298      	cmp	r0, r3
 80035bc:	d106      	bne.n	80035cc <DMA_DeInit+0x78>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_CHANNEL1_IT_MASK;
 80035be:	f853 2c04 	ldr.w	r2, [r3, #-4]
 80035c2:	f042 020f 	orr.w	r2, r2, #15
 80035c6:	f843 2c04 	str.w	r2, [r3, #-4]
 80035ca:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 80035cc:	4b1b      	ldr	r3, [pc, #108]	; (800363c <DMA_DeInit+0xe8>)
 80035ce:	4298      	cmp	r0, r3
 80035d0:	d106      	bne.n	80035e0 <DMA_DeInit+0x8c>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_CHANNEL2_IT_MASK;
 80035d2:	f853 2c18 	ldr.w	r2, [r3, #-24]
 80035d6:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 80035da:	f843 2c18 	str.w	r2, [r3, #-24]
 80035de:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 80035e0:	4b17      	ldr	r3, [pc, #92]	; (8003640 <DMA_DeInit+0xec>)
 80035e2:	4298      	cmp	r0, r3
 80035e4:	d106      	bne.n	80035f4 <DMA_DeInit+0xa0>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_CHANNEL3_IT_MASK;
 80035e6:	f853 2c2c 	ldr.w	r2, [r3, #-44]
 80035ea:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 80035ee:	f843 2c2c 	str.w	r2, [r3, #-44]
 80035f2:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 80035f4:	4b13      	ldr	r3, [pc, #76]	; (8003644 <DMA_DeInit+0xf0>)
 80035f6:	4298      	cmp	r0, r3
 80035f8:	d106      	bne.n	8003608 <DMA_DeInit+0xb4>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_CHANNEL4_IT_MASK;
 80035fa:	f853 2c40 	ldr.w	r2, [r3, #-64]
 80035fe:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 8003602:	f843 2c40 	str.w	r2, [r3, #-64]
 8003606:	4770      	bx	lr
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8003608:	4b0f      	ldr	r3, [pc, #60]	; (8003648 <DMA_DeInit+0xf4>)
 800360a:	4298      	cmp	r0, r3
 800360c:	d105      	bne.n	800361a <DMA_DeInit+0xc6>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_CHANNEL5_IT_MASK;
 800360e:	f853 2c54 	ldr.w	r2, [r3, #-84]
 8003612:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 8003616:	f843 2c54 	str.w	r2, [r3, #-84]
 800361a:	4770      	bx	lr
 800361c:	40020008 	.word	0x40020008
 8003620:	4002001c 	.word	0x4002001c
 8003624:	40020030 	.word	0x40020030
 8003628:	40020044 	.word	0x40020044
 800362c:	40020058 	.word	0x40020058
 8003630:	4002006c 	.word	0x4002006c
 8003634:	40020080 	.word	0x40020080
 8003638:	40020408 	.word	0x40020408
 800363c:	4002041c 	.word	0x4002041c
 8003640:	40020430 	.word	0x40020430
 8003644:	40020444 	.word	0x40020444
 8003648:	40020458 	.word	0x40020458

0800364c <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 800364c:	b570      	push	{r4, r5, r6, lr}
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800364e:	688c      	ldr	r4, [r1, #8]
 8003650:	6a0d      	ldr	r5, [r1, #32]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 8003652:	6806      	ldr	r6, [r0, #0]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003654:	ea45 0204 	orr.w	r2, r5, r4
 8003658:	690c      	ldr	r4, [r1, #16]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 800365a:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800365c:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800365e:	694c      	ldr	r4, [r1, #20]
/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;

  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_MASK;
 8003660:	f426 46ff 	bic.w	r6, r6, #32640	; 0x7f80
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003664:	4322      	orrs	r2, r4
 8003666:	698c      	ldr	r4, [r1, #24]
/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;

  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_MASK;
 8003668:	f026 0670 	bic.w	r6, r6, #112	; 0x70
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800366c:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800366e:	69cc      	ldr	r4, [r1, #28]
 8003670:	4314      	orrs	r4, r2
 8003672:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8003674:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003676:	4313      	orrs	r3, r2
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003678:	4333      	orrs	r3, r6
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 800367a:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration --------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 800367c:	898b      	ldrh	r3, [r1, #12]
 800367e:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ---------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8003680:	680b      	ldr	r3, [r1, #0]
 8003682:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ---------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8003684:	684b      	ldr	r3, [r1, #4]
 8003686:	60c3      	str	r3, [r0, #12]
 8003688:	bd70      	pop	{r4, r5, r6, pc}

0800368a <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 800368a:	2300      	movs	r3, #0
 800368c:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 800368e:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 8003690:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8003692:	8183      	strh	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8003694:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8003696:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8003698:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800369a:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 800369c:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 800369e:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 80036a0:	6283      	str	r3, [r0, #40]	; 0x28
 80036a2:	4770      	bx	lr

080036a4 <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80036a4:	b119      	cbz	r1, 80036ae <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR_EN;
 80036a6:	6803      	ldr	r3, [r0, #0]
 80036a8:	f043 0301 	orr.w	r3, r3, #1
 80036ac:	e003      	b.n	80036b6 <DMA_Cmd+0x12>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR_EN);
 80036ae:	6802      	ldr	r2, [r0, #0]
 80036b0:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80036b4:	4013      	ands	r3, r2
 80036b6:	6003      	str	r3, [r0, #0]
 80036b8:	4770      	bx	lr

080036ba <DMA_SetCurrDataCounter>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));

/*--------------------------- DMAy Channelx CNDTR Configuration --------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DataNumber;
 80036ba:	6041      	str	r1, [r0, #4]
 80036bc:	4770      	bx	lr

080036be <DMA_GetCurrDataCounter>:
uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Return the number of remaining data units for DMAy Channelx */
  return ((uint16_t)(DMAy_Channelx->CNDTR));
 80036be:	6840      	ldr	r0, [r0, #4]
}
 80036c0:	b280      	uxth	r0, r0
 80036c2:	4770      	bx	lr

080036c4 <DMA_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 80036c4:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80036c6:	b10a      	cbz	r2, 80036cc <DMA_ITConfig+0x8>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 80036c8:	4319      	orrs	r1, r3
 80036ca:	e001      	b.n	80036d0 <DMA_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 80036cc:	ea23 0101 	bic.w	r1, r3, r1
 80036d0:	6001      	str	r1, [r0, #0]
 80036d2:	4770      	bx	lr

080036d4 <DMA_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 80036d4:	00c3      	lsls	r3, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR ;
 80036d6:	bf4c      	ite	mi
 80036d8:	4b03      	ldrmi	r3, [pc, #12]	; (80036e8 <DMA_GetFlagStatus+0x14>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
 80036da:	4b04      	ldrpl	r3, [pc, #16]	; (80036ec <DMA_GetFlagStatus+0x18>)
 80036dc:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy flag */
  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
 80036de:	4203      	tst	r3, r0
    bitstatus = RESET;
  }
  
  /* Return the DMAy_FLAG status */
  return  bitstatus;
}
 80036e0:	bf0c      	ite	eq
 80036e2:	2000      	moveq	r0, #0
 80036e4:	2001      	movne	r0, #1
 80036e6:	4770      	bx	lr
 80036e8:	40020400 	.word	0x40020400
 80036ec:	40020000 	.word	0x40020000

080036f0 <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));

/* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 80036f0:	00c2      	lsls	r2, r0, #3
  {
    /* Clear the selected DMAy flags */
    DMA2->IFCR = DMAy_FLAG;
 80036f2:	bf4c      	ite	mi
 80036f4:	4b01      	ldrmi	r3, [pc, #4]	; (80036fc <DMA_ClearFlag+0xc>)
  }
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
 80036f6:	4b02      	ldrpl	r3, [pc, #8]	; (8003700 <DMA_ClearFlag+0x10>)
 80036f8:	6058      	str	r0, [r3, #4]
 80036fa:	4770      	bx	lr
 80036fc:	40020400 	.word	0x40020400
 8003700:	40020000 	.word	0x40020000

08003704 <DMA_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_DMA_GET_IT(DMAy_IT));

  /* Calculate the used DMA */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 8003704:	00c1      	lsls	r1, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR;
 8003706:	bf4c      	ite	mi
 8003708:	4b03      	ldrmi	r3, [pc, #12]	; (8003718 <DMA_GetITStatus+0x14>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR;
 800370a:	4b04      	ldrpl	r3, [pc, #16]	; (800371c <DMA_GetITStatus+0x18>)
 800370c:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy interrupt */
  if ((tmpreg & DMAy_IT) != (uint32_t)RESET)
 800370e:	4203      	tst	r3, r0
    /* DMAy_IT is reset */
    bitstatus = RESET;
  }
  /* Return the DMAy_IT status */
  return  bitstatus;
}
 8003710:	bf0c      	ite	eq
 8003712:	2000      	moveq	r0, #0
 8003714:	2001      	movne	r0, #1
 8003716:	4770      	bx	lr
 8003718:	40020400 	.word	0x40020400
 800371c:	40020000 	.word	0x40020000

08003720 <DMA_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_IT(DMAy_IT));
  
  /* Calculate the used DMAy */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 8003720:	00c3      	lsls	r3, r0, #3
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA2->IFCR = DMAy_IT;
 8003722:	bf4c      	ite	mi
 8003724:	4b01      	ldrmi	r3, [pc, #4]	; (800372c <DMA_ClearITPendingBit+0xc>)
  }
  else
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA1->IFCR = DMAy_IT;
 8003726:	4b02      	ldrpl	r3, [pc, #8]	; (8003730 <DMA_ClearITPendingBit+0x10>)
 8003728:	6058      	str	r0, [r3, #4]
 800372a:	4770      	bx	lr
 800372c:	40020400 	.word	0x40020400
 8003730:	40020000 	.word	0x40020000

08003734 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR    = 0x1F800000;
 8003734:	4b0a      	ldr	r3, [pc, #40]	; (8003760 <EXTI_DeInit+0x2c>)
 8003736:	f04f 52fc 	mov.w	r2, #528482304	; 0x1f800000
 800373a:	601a      	str	r2, [r3, #0]
  EXTI->EMR    = 0x00000000;
  EXTI->RTSR   = 0x00000000;
  EXTI->FTSR   = 0x00000000;
  EXTI->SWIER  = 0x00000000;
  EXTI->PR     = 0xE07FFFFF;
 800373c:	f06f 51fc 	mvn.w	r1, #528482304	; 0x1f800000
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR    = 0x1F800000;
  EXTI->EMR    = 0x00000000;
 8003740:	2200      	movs	r2, #0
 8003742:	605a      	str	r2, [r3, #4]
  EXTI->RTSR   = 0x00000000;
 8003744:	609a      	str	r2, [r3, #8]
  EXTI->FTSR   = 0x00000000;
 8003746:	60da      	str	r2, [r3, #12]
  EXTI->SWIER  = 0x00000000;
 8003748:	611a      	str	r2, [r3, #16]
  EXTI->PR     = 0xE07FFFFF;
 800374a:	6159      	str	r1, [r3, #20]
  EXTI->IMR2   = 0x0000000C;
 800374c:	210c      	movs	r1, #12
 800374e:	6219      	str	r1, [r3, #32]
  EXTI->EMR2   = 0x00000000;
 8003750:	625a      	str	r2, [r3, #36]	; 0x24
  EXTI->RTSR2  = 0x00000000;
 8003752:	629a      	str	r2, [r3, #40]	; 0x28
  EXTI->FTSR2  = 0x00000000;
 8003754:	62da      	str	r2, [r3, #44]	; 0x2c
  EXTI->SWIER2 = 0x00000000;
 8003756:	631a      	str	r2, [r3, #48]	; 0x30
  EXTI->PR2    = 0x00000003;
 8003758:	2203      	movs	r2, #3
 800375a:	635a      	str	r2, [r3, #52]	; 0x34
 800375c:	4770      	bx	lr
 800375e:	bf00      	nop
 8003760:	40010400 	.word	0x40010400

08003764 <EXTI_Init>:
  assert_param(IS_EXTI_LINE_ALL(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
      
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8003764:	7982      	ldrb	r2, [r0, #6]
  * @retval None
  */
  

void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8003766:	b570      	push	{r4, r5, r6, lr}
 8003768:	6803      	ldr	r3, [r0, #0]
  assert_param(IS_EXTI_LINE_ALL(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
      
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 800376a:	2a00      	cmp	r2, #0
 800376c:	d066      	beq.n	800383c <EXTI_Init+0xd8>
  {
    /* Clear EXTI line configuration */   
    *(__IO uint32_t *) (((uint32_t) &(EXTI->IMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));   
 800376e:	f023 021f 	bic.w	r2, r3, #31
 8003772:	f003 011f 	and.w	r1, r3, #31
 8003776:	2301      	movs	r3, #1
 8003778:	fa03 f101 	lsl.w	r1, r3, r1
 800377c:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8003780:	f502 3282 	add.w	r2, r2, #66560	; 0x10400
 8003784:	6814      	ldr	r4, [r2, #0]
 8003786:	ea24 0101 	bic.w	r1, r4, r1
 800378a:	6011      	str	r1, [r2, #0]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->EMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 800378c:	6804      	ldr	r4, [r0, #0]
 800378e:	4a34      	ldr	r2, [pc, #208]	; (8003860 <EXTI_Init+0xfc>)
 8003790:	f024 011f 	bic.w	r1, r4, #31
 8003794:	f004 041f 	and.w	r4, r4, #31
 8003798:	fa03 f404 	lsl.w	r4, r3, r4
 800379c:	588d      	ldr	r5, [r1, r2]
 800379e:	ea25 0404 	bic.w	r4, r5, r4
 80037a2:	508c      	str	r4, [r1, r2]
     
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 80037a4:	6804      	ldr	r4, [r0, #0]
 80037a6:	7901      	ldrb	r1, [r0, #4]
 80037a8:	f024 021f 	bic.w	r2, r4, #31

    *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80037ac:	f004 041f 	and.w	r4, r4, #31
 80037b0:	fa03 f404 	lsl.w	r4, r3, r4
  {
    /* Clear EXTI line configuration */   
    *(__IO uint32_t *) (((uint32_t) &(EXTI->IMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));   
    *(__IO uint32_t *) (((uint32_t) &(EXTI->EMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
     
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 80037b4:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80037b8:	f501 3182 	add.w	r1, r1, #66560	; 0x10400

    *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80037bc:	588d      	ldr	r5, [r1, r2]
 80037be:	432c      	orrs	r4, r5
 80037c0:	508c      	str	r4, [r1, r2]
    
    tmp = (uint32_t)EXTI_BASE;

    /* Clear Rising Falling edge configuration */
    *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80037c2:	6801      	ldr	r1, [r0, #0]
 80037c4:	4c27      	ldr	r4, [pc, #156]	; (8003864 <EXTI_Init+0x100>)
 80037c6:	f021 021f 	bic.w	r2, r1, #31
 80037ca:	f001 011f 	and.w	r1, r1, #31
 80037ce:	fa03 f101 	lsl.w	r1, r3, r1
 80037d2:	5915      	ldr	r5, [r2, r4]
 80037d4:	ea25 0101 	bic.w	r1, r5, r1
 80037d8:	5111      	str	r1, [r2, r4]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80037da:	6805      	ldr	r5, [r0, #0]
 80037dc:	4922      	ldr	r1, [pc, #136]	; (8003868 <EXTI_Init+0x104>)
 80037de:	f025 021f 	bic.w	r2, r5, #31
 80037e2:	f005 051f 	and.w	r5, r5, #31
 80037e6:	fa03 f505 	lsl.w	r5, r3, r5
 80037ea:	5856      	ldr	r6, [r2, r1]
 80037ec:	ea26 0505 	bic.w	r5, r6, r5
 80037f0:	5055      	str	r5, [r2, r1]
    
      /* Select the trigger for the selected interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80037f2:	7945      	ldrb	r5, [r0, #5]
 80037f4:	6802      	ldr	r2, [r0, #0]
 80037f6:	2d10      	cmp	r5, #16
 80037f8:	d112      	bne.n	8003820 <EXTI_Init+0xbc>
    {
      /* Rising Falling edge */
    *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80037fa:	f022 051f 	bic.w	r5, r2, #31
 80037fe:	f002 021f 	and.w	r2, r2, #31
 8003802:	fa03 f202 	lsl.w	r2, r3, r2
 8003806:	592e      	ldr	r6, [r5, r4]
 8003808:	4332      	orrs	r2, r6
 800380a:	512a      	str	r2, [r5, r4]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));      
 800380c:	6800      	ldr	r0, [r0, #0]
 800380e:	f020 021f 	bic.w	r2, r0, #31
 8003812:	f000 001f 	and.w	r0, r0, #31
 8003816:	fa03 f300 	lsl.w	r3, r3, r0
 800381a:	5854      	ldr	r4, [r2, r1]
 800381c:	4323      	orrs	r3, r4
 800381e:	e01c      	b.n	800385a <EXTI_Init+0xf6>
    }
    else
    {
      tmp += EXTI_InitStruct->EXTI_Trigger + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 8003820:	f022 011f 	bic.w	r1, r2, #31

      *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003824:	f002 021f 	and.w	r2, r2, #31
 8003828:	fa03 f302 	lsl.w	r3, r3, r2
    *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
    *(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));      
    }
    else
    {
      tmp += EXTI_InitStruct->EXTI_Trigger + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 800382c:	f105 4080 	add.w	r0, r5, #1073741824	; 0x40000000
 8003830:	f500 3082 	add.w	r0, r0, #66560	; 0x10400

      *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003834:	5844      	ldr	r4, [r0, r1]
 8003836:	4323      	orrs	r3, r4
 8003838:	5043      	str	r3, [r0, r1]
 800383a:	bd70      	pop	{r4, r5, r6, pc}
    }
  }
      
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 800383c:	f023 021f 	bic.w	r2, r3, #31

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003840:	2401      	movs	r4, #1
 8003842:	f003 031f 	and.w	r3, r3, #31
 8003846:	fa04 f303 	lsl.w	r3, r4, r3
    }
  }
      
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 800384a:	7901      	ldrb	r1, [r0, #4]
 800384c:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003850:	f501 3182 	add.w	r1, r1, #66560	; 0x10400

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003854:	5888      	ldr	r0, [r1, r2]
 8003856:	ea20 0303 	bic.w	r3, r0, r3
 800385a:	508b      	str	r3, [r1, r2]
 800385c:	bd70      	pop	{r4, r5, r6, pc}
 800385e:	bf00      	nop
 8003860:	40010404 	.word	0x40010404
 8003864:	40010408 	.word	0x40010408
 8003868:	4001040c 	.word	0x4001040c

0800386c <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 800386c:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 800386e:	2210      	movs	r2, #16
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8003870:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 8003872:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8003874:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8003876:	7183      	strb	r3, [r0, #6]
 8003878:	4770      	bx	lr

0800387a <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER)) + ((EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_Line & 0x1F));
 800387a:	f020 021f 	bic.w	r2, r0, #31
  *         will be generated.
  *   This parameter can be any combination of EXTI_Linex where x can be (0..20).
  * @retval None
  */
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
 800387e:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER)) + ((EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_Line & 0x1F));
 8003880:	f000 001f 	and.w	r0, r0, #31
 8003884:	2401      	movs	r4, #1
 8003886:	fa04 f000 	lsl.w	r0, r4, r0
 800388a:	4b02      	ldr	r3, [pc, #8]	; (8003894 <EXTI_GenerateSWInterrupt+0x1a>)
 800388c:	58d1      	ldr	r1, [r2, r3]
 800388e:	4308      	orrs	r0, r1
 8003890:	50d0      	str	r0, [r2, r3]
 8003892:	bd10      	pop	{r4, pc}
 8003894:	40010410 	.word	0x40010410

08003898 <EXTI_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
   
  if ((*(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20)& (uint32_t)(1 << (EXTI_Line & 0x1F))) != (uint32_t)RESET)
 8003898:	4b06      	ldr	r3, [pc, #24]	; (80038b4 <EXTI_GetFlagStatus+0x1c>)
 800389a:	f020 021f 	bic.w	r2, r0, #31
 800389e:	58d3      	ldr	r3, [r2, r3]
 80038a0:	f000 001f 	and.w	r0, r0, #31
 80038a4:	2201      	movs	r2, #1
 80038a6:	fa02 f000 	lsl.w	r0, r2, r0
 80038aa:	4203      	tst	r3, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80038ac:	bf0c      	ite	eq
 80038ae:	2000      	moveq	r0, #0
 80038b0:	2001      	movne	r0, #1
 80038b2:	4770      	bx	lr
 80038b4:	40010414 	.word	0x40010414

080038b8 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20) = (1 << (EXTI_Line & 0x1F));  
 80038b8:	f020 021f 	bic.w	r2, r0, #31
 80038bc:	2301      	movs	r3, #1
 80038be:	f000 001f 	and.w	r0, r0, #31
 80038c2:	fa03 f000 	lsl.w	r0, r3, r0
 80038c6:	4b01      	ldr	r3, [pc, #4]	; (80038cc <EXTI_ClearFlag+0x14>)
 80038c8:	50d0      	str	r0, [r2, r3]
 80038ca:	4770      	bx	lr
 80038cc:	40010414 	.word	0x40010414

080038d0 <EXTI_GetITStatus>:
  uint32_t enablestatus = 0;
  
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  *(__IO uint32_t *) (((uint32_t) &(EXTI->IMR)) + ((EXTI_Line) >> 5 ) * 0x20) & (uint32_t)(1 << (EXTI_Line & 0x1F));
 80038d0:	0942      	lsrs	r2, r0, #5
 80038d2:	f102 7300 	add.w	r3, r2, #33554432	; 0x2000000
 80038d6:	f503 6302 	add.w	r3, r3, #2080	; 0x820
 80038da:	015b      	lsls	r3, r3, #5
 80038dc:	6819      	ldr	r1, [r3, #0]
 80038de:	f000 001f 	and.w	r0, r0, #31
 80038e2:	2301      	movs	r3, #1
 80038e4:	fa03 f300 	lsl.w	r3, r3, r0
 
  if ( (((*(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + (((EXTI_Line) >> 5 ) * 0x20) )) & (uint32_t)(1 << (EXTI_Line & 0x1F))) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 80038e8:	4804      	ldr	r0, [pc, #16]	; (80038fc <EXTI_GetITStatus+0x2c>)
 80038ea:	0152      	lsls	r2, r2, #5
 80038ec:	5810      	ldr	r0, [r2, r0]
 80038ee:	4018      	ands	r0, r3
 80038f0:	d003      	beq.n	80038fa <EXTI_GetITStatus+0x2a>
 80038f2:	4219      	tst	r1, r3
  {
    bitstatus = SET;
 80038f4:	bf0c      	ite	eq
 80038f6:	2000      	moveq	r0, #0
 80038f8:	2001      	movne	r0, #1
  {
    bitstatus = RESET;
  }
  return bitstatus;
  
}
 80038fa:	4770      	bx	lr
 80038fc:	40010414 	.word	0x40010414

08003900 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));
  
  *(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20) = (1 << (EXTI_Line & 0x1F));
 8003900:	f020 021f 	bic.w	r2, r0, #31
 8003904:	2301      	movs	r3, #1
 8003906:	f000 001f 	and.w	r0, r0, #31
 800390a:	fa03 f000 	lsl.w	r0, r3, r0
 800390e:	4b01      	ldr	r3, [pc, #4]	; (8003914 <EXTI_ClearITPendingBit+0x14>)
 8003910:	50d0      	str	r0, [r2, r3]
 8003912:	4770      	bx	lr
 8003914:	40010414 	.word	0x40010414

08003918 <GPIO_DeInit>:
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if(GPIOx == GPIOA)
 8003918:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
  *         values.
  * @param  GPIOx: where x can be (A, B, C, D, E or F) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 800391c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if(GPIOx == GPIOA)
 800391e:	d107      	bne.n	8003930 <GPIO_DeInit+0x18>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8003920:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8003924:	2101      	movs	r1, #1
 8003926:	f000 fd73 	bl	8004410 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, DISABLE);
 800392a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800392e:	e035      	b.n	800399c <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOB)
 8003930:	4b1d      	ldr	r3, [pc, #116]	; (80039a8 <GPIO_DeInit+0x90>)
 8003932:	4298      	cmp	r0, r3
 8003934:	d107      	bne.n	8003946 <GPIO_DeInit+0x2e>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8003936:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800393a:	2101      	movs	r1, #1
 800393c:	f000 fd68 	bl	8004410 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, DISABLE);
 8003940:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8003944:	e02a      	b.n	800399c <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOC)
 8003946:	4b19      	ldr	r3, [pc, #100]	; (80039ac <GPIO_DeInit+0x94>)
 8003948:	4298      	cmp	r0, r3
 800394a:	d107      	bne.n	800395c <GPIO_DeInit+0x44>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, ENABLE);
 800394c:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8003950:	2101      	movs	r1, #1
 8003952:	f000 fd5d 	bl	8004410 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, DISABLE);
 8003956:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800395a:	e01f      	b.n	800399c <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOD)
 800395c:	4b14      	ldr	r3, [pc, #80]	; (80039b0 <GPIO_DeInit+0x98>)
 800395e:	4298      	cmp	r0, r3
 8003960:	d107      	bne.n	8003972 <GPIO_DeInit+0x5a>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, ENABLE);
 8003962:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8003966:	2101      	movs	r1, #1
 8003968:	f000 fd52 	bl	8004410 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, DISABLE);
 800396c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8003970:	e014      	b.n	800399c <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOE)
 8003972:	4b10      	ldr	r3, [pc, #64]	; (80039b4 <GPIO_DeInit+0x9c>)
 8003974:	4298      	cmp	r0, r3
 8003976:	d107      	bne.n	8003988 <GPIO_DeInit+0x70>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, ENABLE);
 8003978:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800397c:	2101      	movs	r1, #1
 800397e:	f000 fd47 	bl	8004410 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, DISABLE);
 8003982:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003986:	e009      	b.n	800399c <GPIO_DeInit+0x84>
  }
  else
  {
    if(GPIOx == GPIOF)
 8003988:	4b0b      	ldr	r3, [pc, #44]	; (80039b8 <GPIO_DeInit+0xa0>)
 800398a:	4298      	cmp	r0, r3
 800398c:	d10b      	bne.n	80039a6 <GPIO_DeInit+0x8e>
    {
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 800398e:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8003992:	2101      	movs	r1, #1
 8003994:	f000 fd3c 	bl	8004410 <RCC_AHBPeriphResetCmd>
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
 8003998:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800399c:	2100      	movs	r1, #0
    }
  }
}
 800399e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if(GPIOx == GPIOF)
    {
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
 80039a2:	f000 bd35 	b.w	8004410 <RCC_AHBPeriphResetCmd>
 80039a6:	bd08      	pop	{r3, pc}
 80039a8:	48000400 	.word	0x48000400
 80039ac:	48000800 	.word	0x48000800
 80039b0:	48000c00 	.word	0x48000c00
 80039b4:	48001000 	.word	0x48001000
 80039b8:	48001400 	.word	0x48001400

080039bc <GPIO_Init>:
  *         GPIO_Pin_0->GPIO_Pin_2, GPIO_Pin_4, GPIO_Pin_6, GPIO_Pin_9 
  *                       and GPIO_Pin_10 for GPIOF.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{ 
 80039bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80039c0:	2300      	movs	r3, #0
 80039c2:	680f      	ldr	r7, [r1, #0]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80039c4:	461a      	mov	r2, r3
  {
    pos = ((uint32_t)0x01) << pinpos;
 80039c6:	f04f 0c01 	mov.w	ip, #1
        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }
      
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80039ca:	2403      	movs	r4, #3

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 80039cc:	fa0c f602 	lsl.w	r6, ip, r2

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80039d0:	ea06 0507 	and.w	r5, r6, r7

    if (currentpin == pos)
 80039d4:	42b5      	cmp	r5, r6
 80039d6:	d13f      	bne.n	8003a58 <GPIO_Init+0x9c>
    {
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80039d8:	790e      	ldrb	r6, [r1, #4]
 80039da:	f106 38ff 	add.w	r8, r6, #4294967295
 80039de:	f1b8 0f01 	cmp.w	r8, #1
 80039e2:	d820      	bhi.n	8003a26 <GPIO_Init+0x6a>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80039e4:	fa04 f903 	lsl.w	r9, r4, r3
 80039e8:	f8d0 8008 	ldr.w	r8, [r0, #8]
 80039ec:	ea28 0809 	bic.w	r8, r8, r9
 80039f0:	f8c0 8008 	str.w	r8, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80039f4:	f891 8005 	ldrb.w	r8, [r1, #5]
 80039f8:	f8d0 9008 	ldr.w	r9, [r0, #8]
 80039fc:	fa08 f803 	lsl.w	r8, r8, r3
 8003a00:	ea48 0809 	orr.w	r8, r8, r9
 8003a04:	f8c0 8008 	str.w	r8, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
 8003a08:	f8b0 8004 	ldrh.w	r8, [r0, #4]
 8003a0c:	fa1f f888 	uxth.w	r8, r8
 8003a10:	ea28 0505 	bic.w	r5, r8, r5
 8003a14:	8085      	strh	r5, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8003a16:	798d      	ldrb	r5, [r1, #6]
 8003a18:	f8b0 8004 	ldrh.w	r8, [r0, #4]
 8003a1c:	fa05 f502 	lsl.w	r5, r5, r2
 8003a20:	ea45 0508 	orr.w	r5, r5, r8
 8003a24:	8085      	strh	r5, [r0, #4]
      }
      
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8003a26:	fa04 f503 	lsl.w	r5, r4, r3

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8003a2a:	fa06 f603 	lsl.w	r6, r6, r3
        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }
      
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8003a2e:	f8d0 8000 	ldr.w	r8, [r0]
 8003a32:	43ed      	mvns	r5, r5
 8003a34:	ea05 0808 	and.w	r8, r5, r8
 8003a38:	f8c0 8000 	str.w	r8, [r0]

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8003a3c:	f8d0 8000 	ldr.w	r8, [r0]
 8003a40:	ea46 0608 	orr.w	r6, r6, r8
 8003a44:	6006      	str	r6, [r0, #0]

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8003a46:	68c6      	ldr	r6, [r0, #12]
 8003a48:	4035      	ands	r5, r6
 8003a4a:	60c5      	str	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8003a4c:	79cd      	ldrb	r5, [r1, #7]
 8003a4e:	68c6      	ldr	r6, [r0, #12]
 8003a50:	fa05 f503 	lsl.w	r5, r5, r3
 8003a54:	4335      	orrs	r5, r6
 8003a56:	60c5      	str	r5, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8003a58:	3201      	adds	r2, #1
 8003a5a:	3302      	adds	r3, #2
 8003a5c:	2a10      	cmp	r2, #16
 8003a5e:	d1b5      	bne.n	80039cc <GPIO_Init+0x10>
      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8003a60:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08003a64 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8003a64:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003a68:	6003      	str	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8003a6a:	2202      	movs	r2, #2
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8003a6c:	2300      	movs	r3, #0
 8003a6e:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8003a70:	7142      	strb	r2, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 8003a72:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003a74:	71c3      	strb	r3, [r0, #7]
 8003a76:	4770      	bx	lr

08003a78 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_LIST_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 8003a78:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8003a7c:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8003a7e:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8003a80:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit */
  tmp = GPIOx->LCKR;
 8003a82:	69c3      	ldr	r3, [r0, #28]
  /* Read LCKK bit */
  tmp = GPIOx->LCKR;
 8003a84:	69c3      	ldr	r3, [r0, #28]
 8003a86:	4770      	bx	lr

08003a88 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003a88:	8a03      	ldrh	r3, [r0, #16]
 8003a8a:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8003a8c:	bf0c      	ite	eq
 8003a8e:	2000      	moveq	r0, #0
 8003a90:	2001      	movne	r0, #1
 8003a92:	4770      	bx	lr

08003a94 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8003a94:	8a00      	ldrh	r0, [r0, #16]
}
 8003a96:	b280      	uxth	r0, r0
 8003a98:	4770      	bx	lr

08003a9a <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003a9a:	8a83      	ldrh	r3, [r0, #20]
 8003a9c:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8003a9e:	bf0c      	ite	eq
 8003aa0:	2000      	moveq	r0, #0
 8003aa2:	2001      	movne	r0, #1
 8003aa4:	4770      	bx	lr

08003aa6 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->ODR);
 8003aa6:	8a80      	ldrh	r0, [r0, #20]
}
 8003aa8:	b280      	uxth	r0, r0
 8003aaa:	4770      	bx	lr

08003aac <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 8003aac:	6181      	str	r1, [r0, #24]
 8003aae:	4770      	bx	lr

08003ab0 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 8003ab0:	8501      	strh	r1, [r0, #40]	; 0x28
 8003ab2:	4770      	bx	lr

08003ab4 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));
  
  if (BitVal != Bit_RESET)
 8003ab4:	b10a      	cbz	r2, 8003aba <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 8003ab6:	6181      	str	r1, [r0, #24]
 8003ab8:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
 8003aba:	8501      	strh	r1, [r0, #40]	; 0x28
 8003abc:	4770      	bx	lr

08003abe <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 8003abe:	8281      	strh	r1, [r0, #20]
 8003ac0:	4770      	bx	lr

08003ac2 <GPIO_PinAFConfig>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8003ac2:	f001 0307 	and.w	r3, r1, #7
  *        for the detailed mapping of the system and peripherals alternate 
  *        function I/O pins.
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8003ac6:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8003ac8:	009b      	lsls	r3, r3, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8003aca:	240f      	movs	r4, #15
 8003acc:	fa04 f403 	lsl.w	r4, r4, r3
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8003ad0:	fa02 f203 	lsl.w	r2, r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8003ad4:	08c9      	lsrs	r1, r1, #3
 8003ad6:	3108      	adds	r1, #8
 8003ad8:	f850 5021 	ldr.w	r5, [r0, r1, lsl #2]
 8003adc:	ea25 0404 	bic.w	r4, r5, r4
 8003ae0:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8003ae4:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
 8003ae8:	4314      	orrs	r4, r2
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8003aea:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
 8003aee:	bd30      	pop	{r4, r5, pc}

08003af0 <I2C_DeInit>:
  * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 8003af0:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 8003af2:	4b0b      	ldr	r3, [pc, #44]	; (8003b20 <I2C_DeInit+0x30>)
 8003af4:	4298      	cmp	r0, r3
 8003af6:	d107      	bne.n	8003b08 <I2C_DeInit+0x18>
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 8003af8:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003afc:	2101      	movs	r1, #1
 8003afe:	f000 fc9f 	bl	8004440 <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
 8003b02:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003b06:	e006      	b.n	8003b16 <I2C_DeInit+0x26>
  }
  else
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 8003b08:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8003b0c:	2101      	movs	r1, #1
 8003b0e:	f000 fc97 	bl	8004440 <RCC_APB1PeriphResetCmd>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
 8003b12:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8003b16:	2100      	movs	r1, #0
  }
}
 8003b18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
 8003b1c:	f000 bc90 	b.w	8004440 <RCC_APB1PeriphResetCmd>
 8003b20:	40005400 	.word	0x40005400

08003b24 <I2C_Init>:
  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
  assert_param(IS_I2C_ACK(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

  /* Disable I2Cx Peripheral */
  I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 8003b24:	6803      	ldr	r3, [r0, #0]
 8003b26:	f023 0301 	bic.w	r3, r3, #1
 8003b2a:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx FILTERS Configuration ------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 8003b2c:	6802      	ldr	r2, [r0, #0]
  /* Clear I2Cx CR1 register */
  tmpreg &= CR1_CLEAR_MASK;
 8003b2e:	4b14      	ldr	r3, [pc, #80]	; (8003b80 <I2C_Init+0x5c>)
 8003b30:	4013      	ands	r3, r2
  /* Configure I2Cx: analog and digital filter */
  /* Set ANFOFF bit according to I2C_AnalogFilter value */
  /* Set DFN bits according to I2C_DigitalFilter value */
  tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
 8003b32:	688a      	ldr	r2, [r1, #8]
 8003b34:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003b38:	684a      	ldr	r2, [r1, #4]
 8003b3a:	431a      	orrs	r2, r3

  /*---------------------------- I2Cx TIMING Configuration -------------------*/
  /* Configure I2Cx: Timing */
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
 8003b3c:	680b      	ldr	r3, [r1, #0]
  /* Set ANFOFF bit according to I2C_AnalogFilter value */
  /* Set DFN bits according to I2C_DigitalFilter value */
  tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
  
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 8003b3e:	6002      	str	r2, [r0, #0]

  /*---------------------------- I2Cx TIMING Configuration -------------------*/
  /* Configure I2Cx: Timing */
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
 8003b40:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8003b44:	6103      	str	r3, [r0, #16]

  /* Enable I2Cx Peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003b46:	6803      	ldr	r3, [r0, #0]
  /* Clear OAR2 register */
  I2Cx->OAR2 = (uint32_t)tmpreg;
  /* Configure I2Cx: Own Address1 and acknowledged address */
  /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
  /* Set OA1 bits according to I2C_OwnAddress1 value */
  tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
 8003b48:	690a      	ldr	r2, [r1, #16]
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;

  /* Enable I2Cx Peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003b4a:	f043 0301 	orr.w	r3, r3, #1
 8003b4e:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Clear tmpreg local variable */
  tmpreg = 0;
  /* Clear OAR1 register */
  I2Cx->OAR1 = (uint32_t)tmpreg;
 8003b50:	2300      	movs	r3, #0
 8003b52:	6083      	str	r3, [r0, #8]
  /* Clear OAR2 register */
  I2Cx->OAR2 = (uint32_t)tmpreg;
 8003b54:	60c3      	str	r3, [r0, #12]
  /* Configure I2Cx: Own Address1 and acknowledged address */
  /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
  /* Set OA1 bits according to I2C_OwnAddress1 value */
  tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
 8003b56:	698b      	ldr	r3, [r1, #24]
 8003b58:	4313      	orrs	r3, r2
                      (uint32_t)I2C_InitStruct->I2C_OwnAddress1);
  /* Write to I2Cx OAR1 */
  I2Cx->OAR1 = tmpreg;
 8003b5a:	6083      	str	r3, [r0, #8]
  /* Enable Own Address1 acknowledgement */
  I2Cx->OAR1 |= I2C_OAR1_OA1EN;
 8003b5c:	6883      	ldr	r3, [r0, #8]
 8003b5e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003b62:	6083      	str	r3, [r0, #8]
  /*---------------------------- I2Cx MODE Configuration ---------------------*/
  /* Configure I2Cx: mode */
  /* Set SMBDEN and SMBHEN bits according to I2C_Mode value */
  tmpreg = I2C_InitStruct->I2C_Mode;
  /* Write to I2Cx CR1 */
  I2Cx->CR1 |= tmpreg;
 8003b64:	6802      	ldr	r2, [r0, #0]
 8003b66:	68cb      	ldr	r3, [r1, #12]
 8003b68:	4313      	orrs	r3, r2
 8003b6a:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx ACK Configuration ----------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 8003b6c:	6843      	ldr	r3, [r0, #4]
  /* Clear I2Cx CR2 register */
  tmpreg &= CR2_CLEAR_MASK;
  /* Configure I2Cx: acknowledgement */
  /* Set NACK bit according to I2C_Ack value */
  tmpreg |= I2C_InitStruct->I2C_Ack;
 8003b6e:	694a      	ldr	r2, [r1, #20]

  /*---------------------------- I2Cx ACK Configuration ----------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear I2Cx CR2 register */
  tmpreg &= CR2_CLEAR_MASK;
 8003b70:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8003b74:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  /* Configure I2Cx: acknowledgement */
  /* Set NACK bit according to I2C_Ack value */
  tmpreg |= I2C_InitStruct->I2C_Ack;
 8003b78:	4313      	orrs	r3, r2
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 8003b7a:	6043      	str	r3, [r0, #4]
 8003b7c:	4770      	bx	lr
 8003b7e:	bf00      	nop
 8003b80:	00cfe0ff 	.word	0x00cfe0ff

08003b84 <I2C_StructInit>:
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
  /*---------------- Reset I2C init structure parameters values --------------*/
  /* Initialize the I2C_Timing member */
  I2C_InitStruct->I2C_Timing = 0;
 8003b84:	2300      	movs	r3, #0
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8003b86:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
  /*---------------- Reset I2C init structure parameters values --------------*/
  /* Initialize the I2C_Timing member */
  I2C_InitStruct->I2C_Timing = 0;
 8003b8a:	6003      	str	r3, [r0, #0]
  /* Initialize the I2C_AnalogFilter member */
  I2C_InitStruct->I2C_AnalogFilter = I2C_AnalogFilter_Enable;
 8003b8c:	6043      	str	r3, [r0, #4]
  /* Initialize the I2C_DigitalFilter member */
  I2C_InitStruct->I2C_DigitalFilter = 0;
 8003b8e:	6083      	str	r3, [r0, #8]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 8003b90:	60c3      	str	r3, [r0, #12]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 8003b92:	6103      	str	r3, [r0, #16]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8003b94:	6142      	str	r2, [r0, #20]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8003b96:	6183      	str	r3, [r0, #24]
 8003b98:	4770      	bx	lr

08003b9a <I2C_Cmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8003b9a:	6803      	ldr	r3, [r0, #0]
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003b9c:	b111      	cbz	r1, 8003ba4 <I2C_Cmd+0xa>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8003b9e:	f043 0301 	orr.w	r3, r3, #1
 8003ba2:	e001      	b.n	8003ba8 <I2C_Cmd+0xe>
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 8003ba4:	f023 0301 	bic.w	r3, r3, #1
 8003ba8:	6003      	str	r3, [r0, #0]
 8003baa:	4770      	bx	lr

08003bac <I2C_SoftwareResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Disable peripheral */
  I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 8003bac:	6803      	ldr	r3, [r0, #0]
 8003bae:	f023 0301 	bic.w	r3, r3, #1
 8003bb2:	6003      	str	r3, [r0, #0]

  /* Perform a dummy read to delay the disable of peripheral for minimum
     3 APB clock cycles to perform the software reset functionality */
  *(__IO uint32_t *)(uint32_t)I2Cx; 
 8003bb4:	6803      	ldr	r3, [r0, #0]

  /* Enable peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003bb6:	6803      	ldr	r3, [r0, #0]
 8003bb8:	f043 0301 	orr.w	r3, r3, #1
 8003bbc:	6003      	str	r3, [r0, #0]
 8003bbe:	4770      	bx	lr

08003bc0 <I2C_ITConfig>:
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR1 |= I2C_IT;
 8003bc0:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8003bc2:	b10a      	cbz	r2, 8003bc8 <I2C_ITConfig+0x8>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR1 |= I2C_IT;
 8003bc4:	4319      	orrs	r1, r3
 8003bc6:	e001      	b.n	8003bcc <I2C_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_IT);
 8003bc8:	ea23 0101 	bic.w	r1, r3, r1
 8003bcc:	6001      	str	r1, [r0, #0]
 8003bce:	4770      	bx	lr

08003bd0 <I2C_StretchClockCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable clock stretching */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
 8003bd0:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003bd2:	b111      	cbz	r1, 8003bda <I2C_StretchClockCmd+0xa>
  {
    /* Enable clock stretching */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
 8003bd4:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8003bd8:	e001      	b.n	8003bde <I2C_StretchClockCmd+0xe>
  }
  else
  {
    /* Disable clock stretching  */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 8003bda:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003bde:	6003      	str	r3, [r0, #0]
 8003be0:	4770      	bx	lr

08003be2 <I2C_StopModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable wakeup from stop mode */
    I2Cx->CR1 |= I2C_CR1_WUPEN;   
 8003be2:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003be4:	b111      	cbz	r1, 8003bec <I2C_StopModeCmd+0xa>
  {
    /* Enable wakeup from stop mode */
    I2Cx->CR1 |= I2C_CR1_WUPEN;   
 8003be6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8003bea:	e001      	b.n	8003bf0 <I2C_StopModeCmd+0xe>
  }
  else
  {
    /* Disable wakeup from stop mode */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_WUPEN); 
 8003bec:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003bf0:	6003      	str	r3, [r0, #0]
 8003bf2:	4770      	bx	lr

08003bf4 <I2C_DualAddressCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable own address 2 */
    I2Cx->OAR2 |= I2C_OAR2_OA2EN;
 8003bf4:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003bf6:	b111      	cbz	r1, 8003bfe <I2C_DualAddressCmd+0xa>
  {
    /* Enable own address 2 */
    I2Cx->OAR2 |= I2C_OAR2_OA2EN;
 8003bf8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003bfc:	e001      	b.n	8003c02 <I2C_DualAddressCmd+0xe>
  }
  else
  {
    /* Disable own address 2 */
    I2Cx->OAR2 &= (uint32_t)~((uint32_t)I2C_OAR2_OA2EN);
 8003bfe:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003c02:	60c3      	str	r3, [r0, #12]
 8003c04:	4770      	bx	lr

08003c06 <I2C_OwnAddress2Config>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_OWN_ADDRESS2(Address));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(Mask));
  
  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 8003c06:	68c3      	ldr	r3, [r0, #12]

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 8003c08:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  
  /* Get the old register value */
  tmpreg = I2Cx->OAR2;

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));
 8003c0c:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8003c10:	f023 0306 	bic.w	r3, r3, #6

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
 8003c14:	0212      	lsls	r2, r2, #8

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 8003c16:	430b      	orrs	r3, r1
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
 8003c18:	f402 62e0 	and.w	r2, r2, #1792	; 0x700

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 8003c1c:	4313      	orrs	r3, r2
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 8003c1e:	60c3      	str	r3, [r0, #12]
 8003c20:	4770      	bx	lr

08003c22 <I2C_GeneralCallCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable general call mode */
    I2Cx->CR1 |= I2C_CR1_GCEN;
 8003c22:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c24:	b111      	cbz	r1, 8003c2c <I2C_GeneralCallCmd+0xa>
  {
    /* Enable general call mode */
    I2Cx->CR1 |= I2C_CR1_GCEN;
 8003c26:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003c2a:	e001      	b.n	8003c30 <I2C_GeneralCallCmd+0xe>
  }
  else
  {
    /* Disable general call mode */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_GCEN);
 8003c2c:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003c30:	6003      	str	r3, [r0, #0]
 8003c32:	4770      	bx	lr

08003c34 <I2C_SlaveByteControlCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable slave byte control */
    I2Cx->CR1 |= I2C_CR1_SBC;
 8003c34:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c36:	b111      	cbz	r1, 8003c3e <I2C_SlaveByteControlCmd+0xa>
  {
    /* Enable slave byte control */
    I2Cx->CR1 |= I2C_CR1_SBC;
 8003c38:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003c3c:	e001      	b.n	8003c42 <I2C_SlaveByteControlCmd+0xe>
  }
  else
  {
    /* Disable slave byte control */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_SBC);
 8003c3e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003c42:	6003      	str	r3, [r0, #0]
 8003c44:	4770      	bx	lr

08003c46 <I2C_SlaveAddressConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SLAVE_ADDRESS(Address));
               
  /* Get the old register value */
  tmpreg = I2Cx->CR2;
 8003c46:	6843      	ldr	r3, [r0, #4]

  /* Reset I2Cx SADD bit [9:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
 8003c48:	0589      	lsls	r1, r1, #22
               
  /* Get the old register value */
  tmpreg = I2Cx->CR2;

  /* Reset I2Cx SADD bit [9:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);
 8003c4a:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8003c4e:	f023 0303 	bic.w	r3, r3, #3

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
 8003c52:	ea43 5391 	orr.w	r3, r3, r1, lsr #22

  /* Store the new register value */
  I2Cx->CR2 = tmpreg;
 8003c56:	6043      	str	r3, [r0, #4]
 8003c58:	4770      	bx	lr

08003c5a <I2C_10BitAddressingModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable 10-bit addressing mode */
    I2Cx->CR2 |= I2C_CR2_ADD10;
 8003c5a:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c5c:	b111      	cbz	r1, 8003c64 <I2C_10BitAddressingModeCmd+0xa>
  {
    /* Enable 10-bit addressing mode */
    I2Cx->CR2 |= I2C_CR2_ADD10;
 8003c5e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8003c62:	e001      	b.n	8003c68 <I2C_10BitAddressingModeCmd+0xe>
  }
  else
  {
    /* Disable 10-bit addressing mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_ADD10);
 8003c64:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003c68:	6043      	str	r3, [r0, #4]
 8003c6a:	4770      	bx	lr

08003c6c <I2C_AutoEndCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Auto end mode */
    I2Cx->CR2 |= I2C_CR2_AUTOEND;
 8003c6c:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c6e:	b111      	cbz	r1, 8003c76 <I2C_AutoEndCmd+0xa>
  {
    /* Enable Auto end mode */
    I2Cx->CR2 |= I2C_CR2_AUTOEND;
 8003c70:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003c74:	e001      	b.n	8003c7a <I2C_AutoEndCmd+0xe>
  }
  else
  {
    /* Disable Auto end mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_AUTOEND);
 8003c76:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8003c7a:	6043      	str	r3, [r0, #4]
 8003c7c:	4770      	bx	lr

08003c7e <I2C_ReloadCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Auto Reload mode */
    I2Cx->CR2 |= I2C_CR2_RELOAD;
 8003c7e:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c80:	b111      	cbz	r1, 8003c88 <I2C_ReloadCmd+0xa>
  {
    /* Enable Auto Reload mode */
    I2Cx->CR2 |= I2C_CR2_RELOAD;
 8003c82:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003c86:	e001      	b.n	8003c8c <I2C_ReloadCmd+0xe>
  }
  else
  {
    /* Disable Auto Reload mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RELOAD);
 8003c88:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8003c8c:	6043      	str	r3, [r0, #4]
 8003c8e:	4770      	bx	lr

08003c90 <I2C_NumberOfBytesConfig>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->CR2;
 8003c90:	6843      	ldr	r3, [r0, #4]

  /* Reset I2Cx Nbytes bit [7:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_NBYTES);
 8003c92:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000

  /* Set I2Cx Nbytes */
  tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES);
 8003c96:	ea43 4101 	orr.w	r1, r3, r1, lsl #16

  /* Store the new register value */
  I2Cx->CR2 = tmpreg;
 8003c9a:	6041      	str	r1, [r0, #4]
 8003c9c:	4770      	bx	lr

08003c9e <I2C_MasterRequestConfig>:
  
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction == I2C_Direction_Transmitter)
  {
    /* Request a write Transfer */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
 8003c9e:	6843      	ldr	r3, [r0, #4]
/* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction == I2C_Direction_Transmitter)
 8003ca0:	b911      	cbnz	r1, 8003ca8 <I2C_MasterRequestConfig+0xa>
  {
    /* Request a write Transfer */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
 8003ca2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003ca6:	e001      	b.n	8003cac <I2C_MasterRequestConfig+0xe>
  }
  else
  {
    /* Request a read Transfer */
    I2Cx->CR2 |= I2C_CR2_RD_WRN;
 8003ca8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8003cac:	6043      	str	r3, [r0, #4]
 8003cae:	4770      	bx	lr

08003cb0 <I2C_GenerateSTART>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR2 |= I2C_CR2_START;
 8003cb0:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003cb2:	b111      	cbz	r1, 8003cba <I2C_GenerateSTART+0xa>
  {
    /* Generate a START condition */
    I2Cx->CR2 |= I2C_CR2_START;
 8003cb4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8003cb8:	e001      	b.n	8003cbe <I2C_GenerateSTART+0xe>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_START);
 8003cba:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003cbe:	6043      	str	r3, [r0, #4]
 8003cc0:	4770      	bx	lr

08003cc2 <I2C_GenerateSTOP>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR2 |= I2C_CR2_STOP;
 8003cc2:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003cc4:	b111      	cbz	r1, 8003ccc <I2C_GenerateSTOP+0xa>
  {
    /* Generate a STOP condition */
    I2Cx->CR2 |= I2C_CR2_STOP;
 8003cc6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003cca:	e001      	b.n	8003cd0 <I2C_GenerateSTOP+0xe>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_STOP);
 8003ccc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003cd0:	6043      	str	r3, [r0, #4]
 8003cd2:	4770      	bx	lr

08003cd4 <I2C_10BitAddressHeaderCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable 10-bit header only mode */
    I2Cx->CR2 |= I2C_CR2_HEAD10R;
 8003cd4:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003cd6:	b111      	cbz	r1, 8003cde <I2C_10BitAddressHeaderCmd+0xa>
  {
    /* Enable 10-bit header only mode */
    I2Cx->CR2 |= I2C_CR2_HEAD10R;
 8003cd8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003cdc:	e001      	b.n	8003ce2 <I2C_10BitAddressHeaderCmd+0xe>
  }
  else
  {
    /* Disable 10-bit header only mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_HEAD10R);
 8003cde:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003ce2:	6043      	str	r3, [r0, #4]
 8003ce4:	4770      	bx	lr

08003ce6 <I2C_AcknowledgeConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable ACK generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
 8003ce6:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003ce8:	b111      	cbz	r1, 8003cf0 <I2C_AcknowledgeConfig+0xa>
  {
    /* Enable ACK generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
 8003cea:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003cee:	e001      	b.n	8003cf4 <I2C_AcknowledgeConfig+0xe>
  }
  else
  {
    /* Enable NACK generation */
    I2Cx->CR2 |= I2C_CR2_NACK;
 8003cf0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003cf4:	6043      	str	r3, [r0, #4]
 8003cf6:	4770      	bx	lr

08003cf8 <I2C_GetAddressMatched>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  return (uint8_t)(((uint32_t)I2Cx->ISR & I2C_ISR_ADDCODE) >> 16) ;
 8003cf8:	6980      	ldr	r0, [r0, #24]
 8003cfa:	f400 007e 	and.w	r0, r0, #16646144	; 0xfe0000
}
 8003cfe:	0c00      	lsrs	r0, r0, #16
 8003d00:	4770      	bx	lr

08003d02 <I2C_GetTransferDirection>:
  
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  tmpreg = (uint32_t)(I2Cx->ISR & I2C_ISR_DIR);
 8003d02:	6983      	ldr	r3, [r0, #24]
  
  /* If write transfer is requested */
  if (tmpreg == 0)
 8003d04:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  {
    /* Read transfer is requested */
    direction = I2C_Direction_Receiver;
  }  
  return direction;
}
 8003d08:	bf14      	ite	ne
 8003d0a:	f44f 6080 	movne.w	r0, #1024	; 0x400
 8003d0e:	2000      	moveq	r0, #0
 8003d10:	4770      	bx	lr

08003d12 <I2C_TransferHandling>:
  *     @arg I2C_Generate_Start_Read: Generate Restart for read request.
  *     @arg I2C_Generate_Start_Write: Generate Restart for write request.
  * @retval None
  */
void I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode)
{
 8003d12:	b530      	push	{r4, r5, lr}
  assert_param(IS_I2C_SLAVE_ADDRESS(Address));  
  assert_param(IS_RELOAD_END_MODE(ReloadEndMode));
  assert_param(IS_START_STOP_MODE(StartStopMode));
    
  /* Get the CR2 register value */
  tmpreg = I2Cx->CR2;
 8003d14:	6845      	ldr	r5, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003d16:	4c06      	ldr	r4, [pc, #24]	; (8003d30 <I2C_TransferHandling+0x1e>)
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
 8003d18:	0589      	lsls	r1, r1, #22
 8003d1a:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
    
  /* Get the CR2 register value */
  tmpreg = I2Cx->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003d1e:	402c      	ands	r4, r5
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
 8003d20:	9903      	ldr	r1, [sp, #12]
 8003d22:	431c      	orrs	r4, r3
 8003d24:	4321      	orrs	r1, r4
 8003d26:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
            (uint32_t)ReloadEndMode | (uint32_t)StartStopMode);
  
  /* update CR2 register */
  I2Cx->CR2 = tmpreg;  
 8003d2a:	6042      	str	r2, [r0, #4]
 8003d2c:	bd30      	pop	{r4, r5, pc}
 8003d2e:	bf00      	nop
 8003d30:	fc009800 	.word	0xfc009800

08003d34 <I2C_SMBusAlertCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable SMBus alert */
    I2Cx->CR1 |= I2C_CR1_ALERTEN;   
 8003d34:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003d36:	b111      	cbz	r1, 8003d3e <I2C_SMBusAlertCmd+0xa>
  {
    /* Enable SMBus alert */
    I2Cx->CR1 |= I2C_CR1_ALERTEN;   
 8003d38:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8003d3c:	e001      	b.n	8003d42 <I2C_SMBusAlertCmd+0xe>
  }
  else
  {
    /* Disable SMBus alert */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_ALERTEN); 
 8003d3e:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8003d42:	6003      	str	r3, [r0, #0]
 8003d44:	4770      	bx	lr

08003d46 <I2C_ClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
 8003d46:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003d48:	b111      	cbz	r1, 8003d50 <I2C_ClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
 8003d4a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003d4e:	e001      	b.n	8003d54 <I2C_ClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMOUTEN); 
 8003d50:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003d54:	6143      	str	r3, [r0, #20]
 8003d56:	4770      	bx	lr

08003d58 <I2C_ExtendedClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
 8003d58:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003d5a:	b111      	cbz	r1, 8003d62 <I2C_ExtendedClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
 8003d5c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003d60:	e001      	b.n	8003d66 <I2C_ExtendedClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TEXTEN); 
 8003d62:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8003d66:	6143      	str	r3, [r0, #20]
 8003d68:	4770      	bx	lr

08003d6a <I2C_IdleClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
 8003d6a:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003d6c:	b111      	cbz	r1, 8003d74 <I2C_IdleClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
 8003d6e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003d72:	e001      	b.n	8003d78 <I2C_IdleClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIDLE); 
 8003d74:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003d78:	6143      	str	r3, [r0, #20]
 8003d7a:	4770      	bx	lr

08003d7c <I2C_TimeoutAConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_TIMEOUT(Timeout));
    
  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;
 8003d7c:	6943      	ldr	r3, [r0, #20]

  /* Reset I2Cx TIMEOUTA bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);

  /* Set I2Cx TIMEOUTA */
  tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
 8003d7e:	0509      	lsls	r1, r1, #20
    
  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;

  /* Reset I2Cx TIMEOUTA bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);
 8003d80:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8003d84:	f023 030f 	bic.w	r3, r3, #15

  /* Set I2Cx TIMEOUTA */
  tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
 8003d88:	ea43 5311 	orr.w	r3, r3, r1, lsr #20

  /* Store the new register value */
  I2Cx->TIMEOUTR = tmpreg;
 8003d8c:	6143      	str	r3, [r0, #20]
 8003d8e:	4770      	bx	lr

08003d90 <I2C_TimeoutBConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_TIMEOUT(Timeout));

  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;
 8003d90:	6943      	ldr	r3, [r0, #20]

  /* Reset I2Cx TIMEOUTB bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);

  /* Set I2Cx TIMEOUTB */
  tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
 8003d92:	4a05      	ldr	r2, [pc, #20]	; (8003da8 <I2C_TimeoutBConfig+0x18>)

  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;

  /* Reset I2Cx TIMEOUTB bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);
 8003d94:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 8003d98:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000

  /* Set I2Cx TIMEOUTB */
  tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
 8003d9c:	ea02 4101 	and.w	r1, r2, r1, lsl #16
 8003da0:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->TIMEOUTR = tmpreg;
 8003da2:	6143      	str	r3, [r0, #20]
 8003da4:	4770      	bx	lr
 8003da6:	bf00      	nop
 8003da8:	0fff0000 	.word	0x0fff0000

08003dac <I2C_CalculatePEC>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable PEC calculation */
    I2Cx->CR1 |= I2C_CR1_PECEN;   
 8003dac:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003dae:	b111      	cbz	r1, 8003db6 <I2C_CalculatePEC+0xa>
  {
    /* Enable PEC calculation */
    I2Cx->CR1 |= I2C_CR1_PECEN;   
 8003db0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8003db4:	e001      	b.n	8003dba <I2C_CalculatePEC+0xe>
  }
  else
  {
    /* Disable PEC calculation */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PECEN); 
 8003db6:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8003dba:	6003      	str	r3, [r0, #0]
 8003dbc:	4770      	bx	lr

08003dbe <I2C_PECRequestCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable PEC transmission/reception request */
    I2Cx->CR1 |= I2C_CR2_PECBYTE;   
 8003dbe:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003dc0:	b111      	cbz	r1, 8003dc8 <I2C_PECRequestCmd+0xa>
  {
    /* Enable PEC transmission/reception request */
    I2Cx->CR1 |= I2C_CR2_PECBYTE;   
 8003dc2:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8003dc6:	e001      	b.n	8003dcc <I2C_PECRequestCmd+0xe>
  }
  else
  {
    /* Disable PEC transmission/reception request */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR2_PECBYTE); 
 8003dc8:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8003dcc:	6003      	str	r3, [r0, #0]
 8003dce:	4770      	bx	lr

08003dd0 <I2C_GetPEC>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  return (uint8_t)((uint32_t)I2Cx->PECR & I2C_PECR_PEC);
 8003dd0:	6a00      	ldr	r0, [r0, #32]
}
 8003dd2:	b2c0      	uxtb	r0, r0
 8003dd4:	4770      	bx	lr

08003dd6 <I2C_ReadRegister>:
  *     @arg I2C_Register_RXDR: RXDR register.
  *     @arg I2C_Register_TXDR: TXDR register.
  * @retval The value of the read register.
  */
uint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 8003dd6:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8003dd8:	2300      	movs	r3, #0
 8003dda:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t)I2Cx;
 8003ddc:	9001      	str	r0, [sp, #4]
  tmp += I2C_Register;
 8003dde:	9b01      	ldr	r3, [sp, #4]
 8003de0:	18c9      	adds	r1, r1, r3
 8003de2:	9101      	str	r1, [sp, #4]

  /* Return the selected register value */
  return (*(__IO uint32_t *) tmp);
 8003de4:	9b01      	ldr	r3, [sp, #4]
 8003de6:	6818      	ldr	r0, [r3, #0]
}
 8003de8:	b002      	add	sp, #8
 8003dea:	4770      	bx	lr

08003dec <I2C_SendData>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Write in the DR register the data to be sent */
  I2Cx->TXDR = (uint8_t)Data;
 8003dec:	6281      	str	r1, [r0, #40]	; 0x28
 8003dee:	4770      	bx	lr

08003df0 <I2C_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->RXDR;
 8003df0:	6a40      	ldr	r0, [r0, #36]	; 0x24
}  
 8003df2:	b2c0      	uxtb	r0, r0
 8003df4:	4770      	bx	lr

08003df6 <I2C_DMACmd>:
  assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR1 |= I2C_DMAReq;
 8003df6:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));

  if (NewState != DISABLE)
 8003df8:	b10a      	cbz	r2, 8003dfe <I2C_DMACmd+0x8>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR1 |= I2C_DMAReq;
 8003dfa:	4319      	orrs	r1, r3
 8003dfc:	e001      	b.n	8003e02 <I2C_DMACmd+0xc>
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR1 &= (uint32_t)~I2C_DMAReq;
 8003dfe:	ea23 0101 	bic.w	r1, r3, r1
 8003e02:	6001      	str	r1, [r0, #0]
 8003e04:	4770      	bx	lr

08003e06 <I2C_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
  
  /* Get the ISR register value */
  tmpreg = I2Cx->ISR;
 8003e06:	6983      	ldr	r3, [r0, #24]
  
  /* Get flag status */
  tmpreg &= I2C_FLAG;
  
  if(tmpreg != 0)
 8003e08:	4219      	tst	r1, r3
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
  }
  return bitstatus;
}  
 8003e0a:	bf0c      	ite	eq
 8003e0c:	2000      	moveq	r0, #0
 8003e0e:	2001      	movne	r0, #1
 8003e10:	4770      	bx	lr

08003e12 <I2C_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));

  /* Clear the selected flag */
  I2Cx->ICR = I2C_FLAG;
 8003e12:	61c1      	str	r1, [r0, #28]
 8003e14:	4770      	bx	lr

08003e16 <I2C_GetITStatus>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  /* If Error interrupt */
  if((uint32_t)(I2C_IT & ERROR_IT_MASK))
 8003e16:	f411 5f7c 	tst.w	r1, #16128	; 0x3f00
  {
    enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
 8003e1a:	6803      	ldr	r3, [r0, #0]
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  /* If Error interrupt */
  if((uint32_t)(I2C_IT & ERROR_IT_MASK))
 8003e1c:	d002      	beq.n	8003e24 <I2C_GetITStatus+0xe>
  {
    enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
 8003e1e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003e22:	e005      	b.n	8003e30 <I2C_GetITStatus+0x1a>
  }
  /* If TC interrupt */
  else if((uint32_t)(I2C_IT & TC_IT_MASK))
 8003e24:	f011 0fc0 	tst.w	r1, #192	; 0xc0
  {
    enablestatus = (uint32_t)((I2C_CR1_TCIE) & (I2Cx->CR1));
 8003e28:	bf14      	ite	ne
 8003e2a:	f003 0340 	andne.w	r3, r3, #64	; 0x40
  }
  else
  {
    enablestatus = (uint32_t)((I2C_IT) & (I2Cx->CR1));
 8003e2e:	400b      	andeq	r3, r1
  }
  
  /* Get the ISR register value */
  tmpreg = I2Cx->ISR;
 8003e30:	6980      	ldr	r0, [r0, #24]

  /* Get flag status */
  tmpreg &= I2C_IT;

  /* Check the status of the specified I2C flag */
  if((tmpreg != RESET) && enablestatus)
 8003e32:	4008      	ands	r0, r1
 8003e34:	d002      	beq.n	8003e3c <I2C_GetITStatus+0x26>
  {
    /* I2C_IT is set */
    bitstatus = SET;
 8003e36:	1c18      	adds	r0, r3, #0
 8003e38:	bf18      	it	ne
 8003e3a:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the I2C_IT status */
  return bitstatus;
}
 8003e3c:	4770      	bx	lr

08003e3e <I2C_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));

  /* Clear the selected flag */
  I2Cx->ICR = I2C_IT;
 8003e3e:	61c1      	str	r1, [r0, #28]
 8003e40:	4770      	bx	lr
 8003e42:	bf00      	nop

08003e44 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8003e44:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8003e48:	4b02      	ldr	r3, [pc, #8]	; (8003e54 <NVIC_PriorityGroupConfig+0x10>)
 8003e4a:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 8003e4e:	60d8      	str	r0, [r3, #12]
 8003e50:	4770      	bx	lr
 8003e52:	bf00      	nop
 8003e54:	e000ed00 	.word	0xe000ed00

08003e58 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003e58:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8003e5a:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003e5c:	b1fb      	cbz	r3, 8003e9e <NVIC_Init+0x46>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003e5e:	4b16      	ldr	r3, [pc, #88]	; (8003eb8 <NVIC_Init+0x60>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003e60:	7841      	ldrb	r1, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003e62:	68db      	ldr	r3, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8003e64:	7884      	ldrb	r4, [r0, #2]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003e66:	43db      	mvns	r3, r3
 8003e68:	f3c3 2302 	ubfx	r3, r3, #8, #3
    tmppre = (0x4 - tmppriority);
 8003e6c:	f1c3 0204 	rsb	r2, r3, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003e70:	fa01 f102 	lsl.w	r1, r1, r2
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 8003e74:	220f      	movs	r2, #15
 8003e76:	fa22 f203 	lsr.w	r2, r2, r3

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003e7a:	7803      	ldrb	r3, [r0, #0]
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8003e7c:	4022      	ands	r2, r4
 8003e7e:	430a      	orrs	r2, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003e80:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    tmppriority = tmppriority << 0x04;
 8003e84:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003e86:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8003e8a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003e8e:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003e90:	2201      	movs	r2, #1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003e92:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003e94:	f003 031f 	and.w	r3, r3, #31
 8003e98:	fa02 f303 	lsl.w	r3, r2, r3
 8003e9c:	e007      	b.n	8003eae <NVIC_Init+0x56>
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003e9e:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003ea0:	2201      	movs	r2, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003ea2:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003ea4:	f003 031f 	and.w	r3, r3, #31
 8003ea8:	fa02 f303 	lsl.w	r3, r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003eac:	3120      	adds	r1, #32
 8003eae:	4a03      	ldr	r2, [pc, #12]	; (8003ebc <NVIC_Init+0x64>)
 8003eb0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8003eb4:	bd10      	pop	{r4, pc}
 8003eb6:	bf00      	nop
 8003eb8:	e000ed00 	.word	0xe000ed00
 8003ebc:	e000e100 	.word	0xe000e100

08003ec0 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8003ec0:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8003ec4:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8003ec8:	4b01      	ldr	r3, [pc, #4]	; (8003ed0 <NVIC_SetVectorTable+0x10>)
 8003eca:	4308      	orrs	r0, r1
 8003ecc:	6098      	str	r0, [r3, #8]
 8003ece:	4770      	bx	lr
 8003ed0:	e000ed00 	.word	0xe000ed00

08003ed4 <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 8003ed4:	4b04      	ldr	r3, [pc, #16]	; (8003ee8 <NVIC_SystemLPConfig+0x14>)
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8003ed6:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8003ed8:	b109      	cbz	r1, 8003ede <NVIC_SystemLPConfig+0xa>
  {
    SCB->SCR |= LowPowerMode;
 8003eda:	4310      	orrs	r0, r2
 8003edc:	e001      	b.n	8003ee2 <NVIC_SystemLPConfig+0xe>
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8003ede:	ea22 0000 	bic.w	r0, r2, r0
 8003ee2:	6118      	str	r0, [r3, #16]
 8003ee4:	4770      	bx	lr
 8003ee6:	bf00      	nop
 8003ee8:	e000ed00 	.word	0xe000ed00

08003eec <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 8003eec:	4b04      	ldr	r3, [pc, #16]	; (8003f00 <SysTick_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8003eee:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003ef0:	681a      	ldr	r2, [r3, #0]
 8003ef2:	bf0c      	ite	eq
 8003ef4:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8003ef8:	f022 0204 	bicne.w	r2, r2, #4
 8003efc:	601a      	str	r2, [r3, #0]
 8003efe:	4770      	bx	lr
 8003f00:	e000e010 	.word	0xe000e010

08003f04 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003f04:	4b11      	ldr	r3, [pc, #68]	; (8003f4c <RCC_DeInit+0x48>)
 8003f06:	681a      	ldr	r2, [r3, #0]
 8003f08:	f042 0201 	orr.w	r2, r2, #1
 8003f0c:	601a      	str	r2, [r3, #0]

  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFC000;
 8003f0e:	6859      	ldr	r1, [r3, #4]
 8003f10:	4a0f      	ldr	r2, [pc, #60]	; (8003f50 <RCC_DeInit+0x4c>)
 8003f12:	400a      	ands	r2, r1
 8003f14:	605a      	str	r2, [r3, #4]
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003f16:	681a      	ldr	r2, [r3, #0]
 8003f18:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8003f1c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003f20:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003f22:	681a      	ldr	r2, [r3, #0]
 8003f24:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003f28:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8003f2a:	685a      	ldr	r2, [r3, #4]
 8003f2c:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8003f30:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] and ADCPRE[13:4] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFC000;
 8003f32:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003f34:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 8003f38:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8003f3c:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW and TIMSW bits */
  RCC->CFGR3 &= (uint32_t)0xF00FCCC;
 8003f3e:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8003f40:	4a04      	ldr	r2, [pc, #16]	; (8003f54 <RCC_DeInit+0x50>)
 8003f42:	400a      	ands	r2, r1
 8003f44:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8003f46:	2200      	movs	r2, #0
 8003f48:	609a      	str	r2, [r3, #8]
 8003f4a:	4770      	bx	lr
 8003f4c:	40021000 	.word	0x40021000
 8003f50:	f8ffc000 	.word	0xf8ffc000
 8003f54:	0f00fccc 	.word	0x0f00fccc

08003f58 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
 8003f58:	4b02      	ldr	r3, [pc, #8]	; (8003f64 <RCC_HSEConfig+0xc>)
 8003f5a:	2200      	movs	r2, #0
 8003f5c:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
 8003f5e:	7018      	strb	r0, [r3, #0]
 8003f60:	4770      	bx	lr
 8003f62:	bf00      	nop
 8003f64:	40021002 	.word	0x40021002

08003f68 <RCC_AdjustHSICalibrationValue>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
  
  tmpreg = RCC->CR;
 8003f68:	4b03      	ldr	r3, [pc, #12]	; (8003f78 <RCC_AdjustHSICalibrationValue+0x10>)
 8003f6a:	681a      	ldr	r2, [r3, #0]
  
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 8003f6c:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
  
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8003f70:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  
  /* Store the new value */
  RCC->CR = tmpreg;
 8003f74:	6018      	str	r0, [r3, #0]
 8003f76:	4770      	bx	lr
 8003f78:	40021000 	.word	0x40021000

08003f7c <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8003f7c:	4b01      	ldr	r3, [pc, #4]	; (8003f84 <RCC_HSICmd+0x8>)
 8003f7e:	6018      	str	r0, [r3, #0]
 8003f80:	4770      	bx	lr
 8003f82:	bf00      	nop
 8003f84:	42420000 	.word	0x42420000

08003f88 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  RCC->BDCR &= ~(RCC_BDCR_LSEON);
 8003f88:	4b06      	ldr	r3, [pc, #24]	; (8003fa4 <RCC_LSEConfig+0x1c>)
 8003f8a:	6a1a      	ldr	r2, [r3, #32]
 8003f8c:	f022 0201 	bic.w	r2, r2, #1
 8003f90:	621a      	str	r2, [r3, #32]

  /* Reset LSEBYP bit */
  RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
 8003f92:	6a1a      	ldr	r2, [r3, #32]
 8003f94:	f022 0204 	bic.w	r2, r2, #4
 8003f98:	621a      	str	r2, [r3, #32]

  /* Configure LSE */
  RCC->BDCR |= RCC_LSE;
 8003f9a:	6a1a      	ldr	r2, [r3, #32]
 8003f9c:	4310      	orrs	r0, r2
 8003f9e:	6218      	str	r0, [r3, #32]
 8003fa0:	4770      	bx	lr
 8003fa2:	bf00      	nop
 8003fa4:	40021000 	.word	0x40021000

08003fa8 <RCC_LSEDriveConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
  
  /* Clear LSEDRV[1:0] bits */
  RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
 8003fa8:	4b04      	ldr	r3, [pc, #16]	; (8003fbc <RCC_LSEDriveConfig+0x14>)
 8003faa:	6a1a      	ldr	r2, [r3, #32]
 8003fac:	f022 0218 	bic.w	r2, r2, #24
 8003fb0:	621a      	str	r2, [r3, #32]

  /* Set the LSE Drive */
  RCC->BDCR |= RCC_LSEDrive;
 8003fb2:	6a1a      	ldr	r2, [r3, #32]
 8003fb4:	4310      	orrs	r0, r2
 8003fb6:	6218      	str	r0, [r3, #32]
 8003fb8:	4770      	bx	lr
 8003fba:	bf00      	nop
 8003fbc:	40021000 	.word	0x40021000

08003fc0 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8003fc0:	4b01      	ldr	r3, [pc, #4]	; (8003fc8 <RCC_LSICmd+0x8>)
 8003fc2:	6018      	str	r0, [r3, #0]
 8003fc4:	4770      	bx	lr
 8003fc6:	bf00      	nop
 8003fc8:	42420480 	.word	0x42420480

08003fcc <RCC_PLLConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
  
  /* Clear PLL Source [16] and Multiplier [21:18] bits */
  RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 8003fcc:	4b04      	ldr	r3, [pc, #16]	; (8003fe0 <RCC_PLLConfig+0x14>)
 8003fce:	685a      	ldr	r2, [r3, #4]
 8003fd0:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
 8003fd4:	605a      	str	r2, [r3, #4]

  /* Set the PLL Source and Multiplier */
  RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
 8003fd6:	685a      	ldr	r2, [r3, #4]
 8003fd8:	4310      	orrs	r0, r2
 8003fda:	4301      	orrs	r1, r0
 8003fdc:	6059      	str	r1, [r3, #4]
 8003fde:	4770      	bx	lr
 8003fe0:	40021000 	.word	0x40021000

08003fe4 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8003fe4:	4b01      	ldr	r3, [pc, #4]	; (8003fec <RCC_PLLCmd+0x8>)
 8003fe6:	6018      	str	r0, [r3, #0]
 8003fe8:	4770      	bx	lr
 8003fea:	bf00      	nop
 8003fec:	42420060 	.word	0x42420060

08003ff0 <RCC_PREDIV1Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));

  tmpreg = RCC->CFGR2;
 8003ff0:	4b03      	ldr	r3, [pc, #12]	; (8004000 <RCC_PREDIV1Config+0x10>)
 8003ff2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  /* Clear PREDIV1[3:0] bits */
  tmpreg &= ~(RCC_CFGR2_PREDIV1);
 8003ff4:	f022 020f 	bic.w	r2, r2, #15

  /* Set the PREDIV1 division factor */
  tmpreg |= RCC_PREDIV1_Div;
 8003ff8:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 8003ffa:	62d8      	str	r0, [r3, #44]	; 0x2c
 8003ffc:	4770      	bx	lr
 8003ffe:	bf00      	nop
 8004000:	40021000 	.word	0x40021000

08004004 <RCC_ClockSecuritySystemCmd>:
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8004004:	4b01      	ldr	r3, [pc, #4]	; (800400c <RCC_ClockSecuritySystemCmd+0x8>)
 8004006:	6018      	str	r0, [r3, #0]
 8004008:	4770      	bx	lr
 800400a:	bf00      	nop
 800400c:	4242004c 	.word	0x4242004c

08004010 <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
    
  /* Select MCO clock source and prescaler */
  *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource; 
 8004010:	4b01      	ldr	r3, [pc, #4]	; (8004018 <RCC_MCOConfig+0x8>)
 8004012:	7018      	strb	r0, [r3, #0]
 8004014:	4770      	bx	lr
 8004016:	bf00      	nop
 8004018:	40021007 	.word	0x40021007

0800401c <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  
  tmpreg = RCC->CFGR;
 800401c:	4b03      	ldr	r3, [pc, #12]	; (800402c <RCC_SYSCLKConfig+0x10>)
 800401e:	685a      	ldr	r2, [r3, #4]
  
  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8004020:	f022 0203 	bic.w	r2, r2, #3
  
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8004024:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8004026:	6058      	str	r0, [r3, #4]
 8004028:	4770      	bx	lr
 800402a:	bf00      	nop
 800402c:	40021000 	.word	0x40021000

08004030 <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock  
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 8004030:	4b02      	ldr	r3, [pc, #8]	; (800403c <RCC_GetSYSCLKSource+0xc>)
 8004032:	6858      	ldr	r0, [r3, #4]
}
 8004034:	f000 000c 	and.w	r0, r0, #12
 8004038:	4770      	bx	lr
 800403a:	bf00      	nop
 800403c:	40021000 	.word	0x40021000

08004040 <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  
  tmpreg = RCC->CFGR;
 8004040:	4b03      	ldr	r3, [pc, #12]	; (8004050 <RCC_HCLKConfig+0x10>)
 8004042:	685a      	ldr	r2, [r3, #4]
  
  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8004044:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8004048:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800404a:	6058      	str	r0, [r3, #4]
 800404c:	4770      	bx	lr
 800404e:	bf00      	nop
 8004050:	40021000 	.word	0x40021000

08004054 <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  
  tmpreg = RCC->CFGR;
 8004054:	4b03      	ldr	r3, [pc, #12]	; (8004064 <RCC_PCLK1Config+0x10>)
 8004056:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8004058:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 800405c:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800405e:	6058      	str	r0, [r3, #4]
 8004060:	4770      	bx	lr
 8004062:	bf00      	nop
 8004064:	40021000 	.word	0x40021000

08004068 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  
  tmpreg = RCC->CFGR;
 8004068:	4b03      	ldr	r3, [pc, #12]	; (8004078 <RCC_PCLK2Config+0x10>)
 800406a:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 800406c:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8004070:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8004074:	6058      	str	r0, [r3, #4]
 8004076:	4770      	bx	lr
 8004078:	40021000 	.word	0x40021000

0800407c <RCC_GetClocksFreq>:
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800407c:	4b94      	ldr	r3, [pc, #592]	; (80042d0 <RCC_GetClocksFreq+0x254>)
  *           configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 800407e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8004082:	685a      	ldr	r2, [r3, #4]
 8004084:	f002 020c 	and.w	r2, r2, #12
  
  switch (tmp)
 8004088:	2a04      	cmp	r2, #4
 800408a:	d005      	beq.n	8004098 <RCC_GetClocksFreq+0x1c>
 800408c:	2a08      	cmp	r2, #8
 800408e:	d006      	beq.n	800409e <RCC_GetClocksFreq+0x22>
 8004090:	4b90      	ldr	r3, [pc, #576]	; (80042d4 <RCC_GetClocksFreq+0x258>)
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8004092:	6003      	str	r3, [r0, #0]
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  
  switch (tmp)
 8004094:	b9b2      	cbnz	r2, 80040c4 <RCC_GetClocksFreq+0x48>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
 8004096:	e016      	b.n	80040c6 <RCC_GetClocksFreq+0x4a>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8004098:	4b8e      	ldr	r3, [pc, #568]	; (80042d4 <RCC_GetClocksFreq+0x258>)
 800409a:	6003      	str	r3, [r0, #0]
 800409c:	e012      	b.n	80040c4 <RCC_GetClocksFreq+0x48>
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 800409e:	6859      	ldr	r1, [r3, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 80040a0:	685c      	ldr	r4, [r3, #4]
      pllmull = ( pllmull >> 18) + 2;
 80040a2:	f3c1 4183 	ubfx	r1, r1, #18, #4
 80040a6:	3102      	adds	r1, #2
      
      if (pllsource == 0x00)
 80040a8:	03e6      	lsls	r6, r4, #15
 80040aa:	d401      	bmi.n	80040b0 <RCC_GetClocksFreq+0x34>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
 80040ac:	4a8a      	ldr	r2, [pc, #552]	; (80042d8 <RCC_GetClocksFreq+0x25c>)
 80040ae:	e006      	b.n	80040be <RCC_GetClocksFreq+0x42>
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80040b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 80040b2:	4b88      	ldr	r3, [pc, #544]	; (80042d4 <RCC_GetClocksFreq+0x258>)
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80040b4:	f002 020f 	and.w	r2, r2, #15
 80040b8:	3201      	adds	r2, #1
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 80040ba:	fbb3 f2f2 	udiv	r2, r3, r2
 80040be:	434a      	muls	r2, r1
      }
      RCC_Clocks->SYSCLK_Frequency = pllclk;      
 80040c0:	6002      	str	r2, [r0, #0]
      break;
 80040c2:	e000      	b.n	80040c6 <RCC_GetClocksFreq+0x4a>
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 80040c4:	2200      	movs	r2, #0
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
  }
    /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80040c6:	4d82      	ldr	r5, [pc, #520]	; (80042d0 <RCC_GetClocksFreq+0x254>)
  tmp = tmp >> 4;
  ahbpresc = APBAHBPrescTable[tmp]; 
 80040c8:	4c84      	ldr	r4, [pc, #528]	; (80042dc <RCC_GetClocksFreq+0x260>)
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
  }
    /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80040ca:	686b      	ldr	r3, [r5, #4]
  tmp = tmp >> 4;
 80040cc:	f3c3 1303 	ubfx	r3, r3, #4, #4
  ahbpresc = APBAHBPrescTable[tmp]; 
 80040d0:	5ce7      	ldrb	r7, [r4, r3]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> ahbpresc;
 80040d2:	6803      	ldr	r3, [r0, #0]
 80040d4:	fa23 f607 	lsr.w	r6, r3, r7
 80040d8:	6046      	str	r6, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 80040da:	6869      	ldr	r1, [r5, #4]
  tmp = tmp >> 8;
 80040dc:	f3c1 2102 	ubfx	r1, r1, #8, #3
  presc = APBAHBPrescTable[tmp];
 80040e0:	5c61      	ldrb	r1, [r4, r1]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80040e2:	fa26 f101 	lsr.w	r1, r6, r1
 80040e6:	6081      	str	r1, [r0, #8]
  
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 80040e8:	f8d5 c004 	ldr.w	ip, [r5, #4]
  tmp = tmp >> 11;
 80040ec:	f3cc 2cc2 	ubfx	ip, ip, #11, #3
  apb2presc = APBAHBPrescTable[tmp];
 80040f0:	f814 c00c 	ldrb.w	ip, [r4, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> apb2presc;
 80040f4:	fa26 f60c 	lsr.w	r6, r6, ip
 80040f8:	60c6      	str	r6, [r0, #12]
  
  /* Get ADC12CLK prescaler */
  tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE12;
 80040fa:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
  tmp = tmp >> 4;
 80040fe:	f3c8 1804 	ubfx	r8, r8, #4, #5
  presc = ADCPrescTable[tmp];
 8004102:	eb04 0848 	add.w	r8, r4, r8, lsl #1
 8004106:	f8b8 8010 	ldrh.w	r8, [r8, #16]
 800410a:	fa1f f888 	uxth.w	r8, r8
  if ((presc & 0x10) != 0)
 800410e:	f008 0910 	and.w	r9, r8, #16
 8004112:	fa1f f989 	uxth.w	r9, r9
 8004116:	f1b9 0f00 	cmp.w	r9, #0
 800411a:	d004      	beq.n	8004126 <RCC_GetClocksFreq+0xaa>
  {
     /* ADC12CLK clock frequency is derived from PLL clock */
     RCC_Clocks->ADC12CLK_Frequency = pllclk / presc;
 800411c:	fbb2 f8f8 	udiv	r8, r2, r8
 8004120:	f8c0 8010 	str.w	r8, [r0, #16]
 8004124:	e000      	b.n	8004128 <RCC_GetClocksFreq+0xac>
  }
  else
  {
   /* ADC12CLK clock frequency is AHB clock */
     RCC_Clocks->ADC12CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004126:	6103      	str	r3, [r0, #16]
  }
  
  /* Get ADC34CLK prescaler */
  tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE34;
 8004128:	6aed      	ldr	r5, [r5, #44]	; 0x2c
  tmp = tmp >> 9;
 800412a:	f3c5 2544 	ubfx	r5, r5, #9, #5
  presc = ADCPrescTable[tmp];
 800412e:	eb04 0445 	add.w	r4, r4, r5, lsl #1
 8004132:	8a24      	ldrh	r4, [r4, #16]
 8004134:	b2a4      	uxth	r4, r4
  if ((presc & 0x10) != 0)
 8004136:	f004 0510 	and.w	r5, r4, #16
 800413a:	b2ad      	uxth	r5, r5
 800413c:	b11d      	cbz	r5, 8004146 <RCC_GetClocksFreq+0xca>
  {
     /* ADC34CLK clock frequency is derived from PLL clock */
     RCC_Clocks->ADC34CLK_Frequency = pllclk / presc;
 800413e:	fbb2 f4f4 	udiv	r4, r2, r4
 8004142:	6144      	str	r4, [r0, #20]
 8004144:	e000      	b.n	8004148 <RCC_GetClocksFreq+0xcc>
  }
  else
  {
   /* ADC34CLK clock frequency is AHB clock */
     RCC_Clocks->ADC34CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004146:	6143      	str	r3, [r0, #20]
  }

  /* I2C1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 8004148:	4c61      	ldr	r4, [pc, #388]	; (80042d0 <RCC_GetClocksFreq+0x254>)
 800414a:	6b25      	ldr	r5, [r4, #48]	; 0x30
 800414c:	06ed      	lsls	r5, r5, #27
  {
    /* I2C1 Clock is HSI Osc. */
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 800414e:	bf56      	itet	pl
 8004150:	4d60      	ldrpl	r5, [pc, #384]	; (80042d4 <RCC_GetClocksFreq+0x258>)
  }
  else
  {
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004152:	6183      	strmi	r3, [r0, #24]

  /* I2C1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
  {
    /* I2C1 Clock is HSI Osc. */
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 8004154:	6185      	strpl	r5, [r0, #24]
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }

  /* I2C2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
 8004156:	6b24      	ldr	r4, [r4, #48]	; 0x30
 8004158:	06a4      	lsls	r4, r4, #26
  {
    /* I2C2 Clock is HSI Osc. */
    RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
 800415a:	bf56      	itet	pl
 800415c:	4c5d      	ldrpl	r4, [pc, #372]	; (80042d4 <RCC_GetClocksFreq+0x258>)
  }
  else
  {
    /* I2C2 Clock is System Clock */
    RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 800415e:	61c3      	strmi	r3, [r0, #28]

  /* I2C2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
  {
    /* I2C2 Clock is HSI Osc. */
    RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
 8004160:	61c4      	strpl	r4, [r0, #28]
    /* I2C2 Clock is System Clock */
    RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  
    /* TIM1CLK clock frequency */
  if(((RCC->CFGR3 & RCC_CFGR3_TIM1SW) == RCC_CFGR3_TIM1SW)&& (RCC_Clocks->SYSCLK_Frequency == pllclk) \
 8004162:	4c5b      	ldr	r4, [pc, #364]	; (80042d0 <RCC_GetClocksFreq+0x254>)
 8004164:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8004166:	f415 7f80 	tst.w	r5, #256	; 0x100
 800416a:	d006      	beq.n	800417a <RCC_GetClocksFreq+0xfe>
 800416c:	4293      	cmp	r3, r2
 800416e:	d104      	bne.n	800417a <RCC_GetClocksFreq+0xfe>
  && (apb2presc == ahbpresc)) 
 8004170:	45bc      	cmp	ip, r7
 8004172:	d102      	bne.n	800417a <RCC_GetClocksFreq+0xfe>
  {
    /* TIM1 Clock is 2 * pllclk */
    RCC_Clocks->TIM1CLK_Frequency = pllclk * 2;
 8004174:	005d      	lsls	r5, r3, #1
 8004176:	6205      	str	r5, [r0, #32]
 8004178:	e000      	b.n	800417c <RCC_GetClocksFreq+0x100>
  }
  else
  {
    /* TIM1 Clock is APB2 clock. */
    RCC_Clocks->TIM1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 800417a:	6206      	str	r6, [r0, #32]
  }

    /* TIM8CLK clock frequency */
  if(((RCC->CFGR3 & RCC_CFGR3_TIM8SW) == RCC_CFGR3_TIM8SW)&& (RCC_Clocks->SYSCLK_Frequency == pllclk) \
 800417c:	6b24      	ldr	r4, [r4, #48]	; 0x30
 800417e:	05a4      	lsls	r4, r4, #22
 8004180:	d506      	bpl.n	8004190 <RCC_GetClocksFreq+0x114>
 8004182:	4293      	cmp	r3, r2
 8004184:	d104      	bne.n	8004190 <RCC_GetClocksFreq+0x114>
  && (apb2presc == ahbpresc))
 8004186:	45bc      	cmp	ip, r7
 8004188:	d102      	bne.n	8004190 <RCC_GetClocksFreq+0x114>
  {
    /* TIM8 Clock is 2 * pllclk */
    RCC_Clocks->TIM8CLK_Frequency = pllclk * 2;
 800418a:	005a      	lsls	r2, r3, #1
 800418c:	6242      	str	r2, [r0, #36]	; 0x24
 800418e:	e000      	b.n	8004192 <RCC_GetClocksFreq+0x116>
  }
  else
  {
    /* TIM8 Clock is APB2 clock. */
    RCC_Clocks->TIM8CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 8004190:	6246      	str	r6, [r0, #36]	; 0x24
  }
  
  /* USART1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 8004192:	4a4f      	ldr	r2, [pc, #316]	; (80042d0 <RCC_GetClocksFreq+0x254>)
 8004194:	6b14      	ldr	r4, [r2, #48]	; 0x30
 8004196:	07a4      	lsls	r4, r4, #30
 8004198:	d101      	bne.n	800419e <RCC_GetClocksFreq+0x122>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 800419a:	6286      	str	r6, [r0, #40]	; 0x28
 800419c:	e015      	b.n	80041ca <RCC_GetClocksFreq+0x14e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 800419e:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80041a0:	f004 0403 	and.w	r4, r4, #3
 80041a4:	2c01      	cmp	r4, #1
 80041a6:	d101      	bne.n	80041ac <RCC_GetClocksFreq+0x130>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 80041a8:	6283      	str	r3, [r0, #40]	; 0x28
 80041aa:	e00e      	b.n	80041ca <RCC_GetClocksFreq+0x14e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 80041ac:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80041ae:	f004 0403 	and.w	r4, r4, #3
 80041b2:	2c02      	cmp	r4, #2
 80041b4:	d102      	bne.n	80041bc <RCC_GetClocksFreq+0x140>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 80041b6:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 80041ba:	e005      	b.n	80041c8 <RCC_GetClocksFreq+0x14c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 80041bc:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80041be:	f004 0403 	and.w	r4, r4, #3
 80041c2:	2c03      	cmp	r4, #3
 80041c4:	d101      	bne.n	80041ca <RCC_GetClocksFreq+0x14e>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 80041c6:	4c43      	ldr	r4, [pc, #268]	; (80042d4 <RCC_GetClocksFreq+0x258>)
 80041c8:	6284      	str	r4, [r0, #40]	; 0x28
  }

  /* USART2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 80041ca:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80041cc:	4c40      	ldr	r4, [pc, #256]	; (80042d0 <RCC_GetClocksFreq+0x254>)
 80041ce:	f412 3f40 	tst.w	r2, #196608	; 0x30000
 80041d2:	d101      	bne.n	80041d8 <RCC_GetClocksFreq+0x15c>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 80041d4:	62c1      	str	r1, [r0, #44]	; 0x2c
 80041d6:	e018      	b.n	800420a <RCC_GetClocksFreq+0x18e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 80041d8:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80041da:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 80041de:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80041e2:	d101      	bne.n	80041e8 <RCC_GetClocksFreq+0x16c>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 80041e4:	62c3      	str	r3, [r0, #44]	; 0x2c
 80041e6:	e010      	b.n	800420a <RCC_GetClocksFreq+0x18e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 80041e8:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80041ea:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 80041ee:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 80041f2:	d102      	bne.n	80041fa <RCC_GetClocksFreq+0x17e>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 80041f4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80041f8:	e006      	b.n	8004208 <RCC_GetClocksFreq+0x18c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 80041fa:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80041fc:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8004200:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
 8004204:	d101      	bne.n	800420a <RCC_GetClocksFreq+0x18e>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 8004206:	4a33      	ldr	r2, [pc, #204]	; (80042d4 <RCC_GetClocksFreq+0x258>)
 8004208:	62c2      	str	r2, [r0, #44]	; 0x2c
  }    

  /* USART3CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 800420a:	4a31      	ldr	r2, [pc, #196]	; (80042d0 <RCC_GetClocksFreq+0x254>)
 800420c:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800420e:	f414 2f40 	tst.w	r4, #786432	; 0xc0000
 8004212:	d101      	bne.n	8004218 <RCC_GetClocksFreq+0x19c>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 8004214:	6301      	str	r1, [r0, #48]	; 0x30
 8004216:	e018      	b.n	800424a <RCC_GetClocksFreq+0x1ce>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 8004218:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800421a:	f404 2440 	and.w	r4, r4, #786432	; 0xc0000
 800421e:	f5b4 2f80 	cmp.w	r4, #262144	; 0x40000
 8004222:	d101      	bne.n	8004228 <RCC_GetClocksFreq+0x1ac>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004224:	6303      	str	r3, [r0, #48]	; 0x30
 8004226:	e010      	b.n	800424a <RCC_GetClocksFreq+0x1ce>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 8004228:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800422a:	f404 2440 	and.w	r4, r4, #786432	; 0xc0000
 800422e:	f5b4 2f00 	cmp.w	r4, #524288	; 0x80000
 8004232:	d102      	bne.n	800423a <RCC_GetClocksFreq+0x1be>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 8004234:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 8004238:	e006      	b.n	8004248 <RCC_GetClocksFreq+0x1cc>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 800423a:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800423c:	f404 2440 	and.w	r4, r4, #786432	; 0xc0000
 8004240:	f5b4 2f40 	cmp.w	r4, #786432	; 0xc0000
 8004244:	d101      	bne.n	800424a <RCC_GetClocksFreq+0x1ce>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 8004246:	4c23      	ldr	r4, [pc, #140]	; (80042d4 <RCC_GetClocksFreq+0x258>)
 8004248:	6304      	str	r4, [r0, #48]	; 0x30
  }
  
    /* UART4CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == 0x0)
 800424a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800424c:	4c20      	ldr	r4, [pc, #128]	; (80042d0 <RCC_GetClocksFreq+0x254>)
 800424e:	f412 1f40 	tst.w	r2, #3145728	; 0x300000
 8004252:	d101      	bne.n	8004258 <RCC_GetClocksFreq+0x1dc>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 8004254:	6341      	str	r1, [r0, #52]	; 0x34
 8004256:	e018      	b.n	800428a <RCC_GetClocksFreq+0x20e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_0)
 8004258:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800425a:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 800425e:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 8004262:	d101      	bne.n	8004268 <RCC_GetClocksFreq+0x1ec>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004264:	6343      	str	r3, [r0, #52]	; 0x34
 8004266:	e010      	b.n	800428a <RCC_GetClocksFreq+0x20e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_1)
 8004268:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800426a:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 800426e:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 8004272:	d102      	bne.n	800427a <RCC_GetClocksFreq+0x1fe>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->UART4CLK_Frequency = LSE_VALUE;
 8004274:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8004278:	e006      	b.n	8004288 <RCC_GetClocksFreq+0x20c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW)
 800427a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800427c:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 8004280:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 8004284:	d101      	bne.n	800428a <RCC_GetClocksFreq+0x20e>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->UART4CLK_Frequency = HSI_VALUE;
 8004286:	4a13      	ldr	r2, [pc, #76]	; (80042d4 <RCC_GetClocksFreq+0x258>)
 8004288:	6342      	str	r2, [r0, #52]	; 0x34
  }   
  
  /* UART5CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == 0x0)
 800428a:	4a11      	ldr	r2, [pc, #68]	; (80042d0 <RCC_GetClocksFreq+0x254>)
 800428c:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800428e:	f414 0f40 	tst.w	r4, #12582912	; 0xc00000
 8004292:	d102      	bne.n	800429a <RCC_GetClocksFreq+0x21e>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 8004294:	6381      	str	r1, [r0, #56]	; 0x38
 8004296:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_0)
 800429a:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800429c:	f401 0140 	and.w	r1, r1, #12582912	; 0xc00000
 80042a0:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
 80042a4:	d100      	bne.n	80042a8 <RCC_GetClocksFreq+0x22c>
 80042a6:	e00f      	b.n	80042c8 <RCC_GetClocksFreq+0x24c>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_1)
 80042a8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80042aa:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 80042ae:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80042b2:	d102      	bne.n	80042ba <RCC_GetClocksFreq+0x23e>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->UART5CLK_Frequency = LSE_VALUE;
 80042b4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80042b8:	e006      	b.n	80042c8 <RCC_GetClocksFreq+0x24c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW)
 80042ba:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80042bc:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 80042c0:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 80042c4:	d101      	bne.n	80042ca <RCC_GetClocksFreq+0x24e>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->UART5CLK_Frequency = HSI_VALUE;
 80042c6:	4b03      	ldr	r3, [pc, #12]	; (80042d4 <RCC_GetClocksFreq+0x258>)
 80042c8:	6383      	str	r3, [r0, #56]	; 0x38
 80042ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80042ce:	bf00      	nop
 80042d0:	40021000 	.word	0x40021000
 80042d4:	007a1200 	.word	0x007a1200
 80042d8:	003d0900 	.word	0x003d0900
 80042dc:	20000000 	.word	0x20000000

080042e0 <RCC_ADCCLKConfig>:
  assert_param(IS_RCC_ADCCLK(RCC_PLLCLK));

  tmp = (RCC_PLLCLK >> 28);
  
  /* Clears ADCPRE34 bits */
  if (tmp != 0)
 80042e0:	0f03      	lsrs	r3, r0, #28
 80042e2:	4b06      	ldr	r3, [pc, #24]	; (80042fc <RCC_ADCCLKConfig+0x1c>)
  {
    RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE34;
 80042e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80042e6:	bf14      	ite	ne
 80042e8:	f422 5278 	bicne.w	r2, r2, #15872	; 0x3e00
  }
   /* Clears ADCPRE12 bits */
  else
  {
    RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE12;
 80042ec:	f422 72f8 	biceq.w	r2, r2, #496	; 0x1f0
 80042f0:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  /* Set ADCPRE bits according to RCC_PLLCLK value */
  RCC->CFGR2 |= RCC_PLLCLK;
 80042f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80042f4:	4310      	orrs	r0, r2
 80042f6:	62d8      	str	r0, [r3, #44]	; 0x2c
 80042f8:	4770      	bx	lr
 80042fa:	bf00      	nop
 80042fc:	40021000 	.word	0x40021000

08004300 <RCC_I2CCLKConfig>:
  assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));

  tmp = (RCC_I2CCLK >> 28);
  
  /* Clear I2CSW bit */
  if (tmp != 0)
 8004300:	0f03      	lsrs	r3, r0, #28
 8004302:	4b06      	ldr	r3, [pc, #24]	; (800431c <RCC_I2CCLKConfig+0x1c>)
  {
    RCC->CFGR3 &= ~RCC_CFGR3_I2C2SW;
 8004304:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004306:	bf14      	ite	ne
 8004308:	f022 0220 	bicne.w	r2, r2, #32
  }
  else
  {
    RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
 800430c:	f022 0210 	biceq.w	r2, r2, #16
 8004310:	631a      	str	r2, [r3, #48]	; 0x30
  }
  /* Set I2CSW bits according to RCC_I2CCLK value */
  RCC->CFGR3 |= RCC_I2CCLK;
 8004312:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004314:	4310      	orrs	r0, r2
 8004316:	6318      	str	r0, [r3, #48]	; 0x30
 8004318:	4770      	bx	lr
 800431a:	bf00      	nop
 800431c:	40021000 	.word	0x40021000

08004320 <RCC_TIMCLKConfig>:
  assert_param(IS_RCC_TIMCLK(RCC_TIMCLK));

  tmp = (RCC_TIMCLK >> 28);
  
  /* Clear I2CSW bit */
  if (tmp != 0)
 8004320:	0f03      	lsrs	r3, r0, #28
 8004322:	4b06      	ldr	r3, [pc, #24]	; (800433c <RCC_TIMCLKConfig+0x1c>)
  {
    RCC->CFGR3 &= ~RCC_CFGR3_TIM8SW;
 8004324:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004326:	bf14      	ite	ne
 8004328:	f422 7200 	bicne.w	r2, r2, #512	; 0x200
  }
  else
  {
    RCC->CFGR3 &= ~RCC_CFGR3_TIM1SW;
 800432c:	f422 7280 	biceq.w	r2, r2, #256	; 0x100
 8004330:	631a      	str	r2, [r3, #48]	; 0x30
  }
  /* Set I2CSW bits according to RCC_TIMCLK value */
  RCC->CFGR3 |= RCC_TIMCLK;
 8004332:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004334:	4310      	orrs	r0, r2
 8004336:	6318      	str	r0, [r3, #48]	; 0x30
 8004338:	4770      	bx	lr
 800433a:	bf00      	nop
 800433c:	40021000 	.word	0x40021000

08004340 <RCC_USARTCLKConfig>:
  uint32_t tmp = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));

  tmp = (RCC_USARTCLK >> 28);
 8004340:	0f02      	lsrs	r2, r0, #28

  /* Clear USARTSW[1:0] bit */
  switch (tmp)
 8004342:	3a01      	subs	r2, #1
 8004344:	4b0f      	ldr	r3, [pc, #60]	; (8004384 <RCC_USARTCLKConfig+0x44>)
 8004346:	2a04      	cmp	r2, #4
 8004348:	d818      	bhi.n	800437c <RCC_USARTCLKConfig+0x3c>
 800434a:	e8df f002 	tbb	[pc, r2]
 800434e:	0703      	.short	0x0703
 8004350:	0f0b      	.short	0x0f0b
 8004352:	13          	.byte	0x13
 8004353:	00          	.byte	0x00
  {
    case 0x01:  /* clear USART1SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 8004354:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004356:	f022 0203 	bic.w	r2, r2, #3
 800435a:	e00e      	b.n	800437a <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x02:  /* clear USART2SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 800435c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800435e:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8004362:	e00a      	b.n	800437a <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x03:  /* clear USART3SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 8004364:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004366:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 800436a:	e006      	b.n	800437a <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x04:  /* clear UART4SW */
      RCC->CFGR3 &= ~RCC_CFGR3_UART4SW;
 800436c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800436e:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8004372:	e002      	b.n	800437a <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x05:  /* clear UART5SW */
      RCC->CFGR3 &= ~RCC_CFGR3_UART5SW;
 8004374:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004376:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800437a:	631a      	str	r2, [r3, #48]	; 0x30
    default:
      break;
  }

  /* Set USARTSW bits according to RCC_USARTCLK value */
  RCC->CFGR3 |= RCC_USARTCLK;
 800437c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800437e:	4310      	orrs	r0, r2
 8004380:	6318      	str	r0, [r3, #48]	; 0x30
 8004382:	4770      	bx	lr
 8004384:	40021000 	.word	0x40021000

08004388 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 8004388:	4b01      	ldr	r3, [pc, #4]	; (8004390 <RCC_USBCLKConfig+0x8>)
 800438a:	6018      	str	r0, [r3, #0]
 800438c:	4770      	bx	lr
 800438e:	bf00      	nop
 8004390:	424200d8 	.word	0x424200d8

08004394 <RCC_RTCCLKConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8004394:	4b02      	ldr	r3, [pc, #8]	; (80043a0 <RCC_RTCCLKConfig+0xc>)
 8004396:	6a1a      	ldr	r2, [r3, #32]
 8004398:	4310      	orrs	r0, r2
 800439a:	6218      	str	r0, [r3, #32]
 800439c:	4770      	bx	lr
 800439e:	bf00      	nop
 80043a0:	40021000 	.word	0x40021000

080043a4 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 80043a4:	4b01      	ldr	r3, [pc, #4]	; (80043ac <RCC_I2SCLKConfig+0x8>)
 80043a6:	6018      	str	r0, [r3, #0]
 80043a8:	4770      	bx	lr
 80043aa:	bf00      	nop
 80043ac:	424200dc 	.word	0x424200dc

080043b0 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 80043b0:	4b01      	ldr	r3, [pc, #4]	; (80043b8 <RCC_RTCCLKCmd+0x8>)
 80043b2:	6018      	str	r0, [r3, #0]
 80043b4:	4770      	bx	lr
 80043b6:	bf00      	nop
 80043b8:	4242043c 	.word	0x4242043c

080043bc <RCC_BackupResetCmd>:
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80043bc:	4b01      	ldr	r3, [pc, #4]	; (80043c4 <RCC_BackupResetCmd+0x8>)
 80043be:	6018      	str	r0, [r3, #0]
 80043c0:	4770      	bx	lr
 80043c2:	bf00      	nop
 80043c4:	42420440 	.word	0x42420440

080043c8 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 80043c8:	4b04      	ldr	r3, [pc, #16]	; (80043dc <RCC_AHBPeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80043ca:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80043cc:	b109      	cbz	r1, 80043d2 <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80043ce:	4310      	orrs	r0, r2
 80043d0:	e001      	b.n	80043d6 <RCC_AHBPeriphClockCmd+0xe>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80043d2:	ea22 0000 	bic.w	r0, r2, r0
 80043d6:	6158      	str	r0, [r3, #20]
 80043d8:	4770      	bx	lr
 80043da:	bf00      	nop
 80043dc:	40021000 	.word	0x40021000

080043e0 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80043e0:	4b04      	ldr	r3, [pc, #16]	; (80043f4 <RCC_APB2PeriphClockCmd+0x14>)
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80043e2:	699a      	ldr	r2, [r3, #24]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80043e4:	b109      	cbz	r1, 80043ea <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80043e6:	4310      	orrs	r0, r2
 80043e8:	e001      	b.n	80043ee <RCC_APB2PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80043ea:	ea22 0000 	bic.w	r0, r2, r0
 80043ee:	6198      	str	r0, [r3, #24]
 80043f0:	4770      	bx	lr
 80043f2:	bf00      	nop
 80043f4:	40021000 	.word	0x40021000

080043f8 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80043f8:	4b04      	ldr	r3, [pc, #16]	; (800440c <RCC_APB1PeriphClockCmd+0x14>)
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80043fa:	69da      	ldr	r2, [r3, #28]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80043fc:	b109      	cbz	r1, 8004402 <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80043fe:	4310      	orrs	r0, r2
 8004400:	e001      	b.n	8004406 <RCC_APB1PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8004402:	ea22 0000 	bic.w	r0, r2, r0
 8004406:	61d8      	str	r0, [r3, #28]
 8004408:	4770      	bx	lr
 800440a:	bf00      	nop
 800440c:	40021000 	.word	0x40021000

08004410 <RCC_AHBPeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8004410:	4b04      	ldr	r3, [pc, #16]	; (8004424 <RCC_AHBPeriphResetCmd+0x14>)
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 8004412:	6a9a      	ldr	r2, [r3, #40]	; 0x28
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004414:	b109      	cbz	r1, 800441a <RCC_AHBPeriphResetCmd+0xa>
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 8004416:	4310      	orrs	r0, r2
 8004418:	e001      	b.n	800441e <RCC_AHBPeriphResetCmd+0xe>
  }
  else
  {
    RCC->AHBRSTR &= ~RCC_AHBPeriph;
 800441a:	ea22 0000 	bic.w	r0, r2, r0
 800441e:	6298      	str	r0, [r3, #40]	; 0x28
 8004420:	4770      	bx	lr
 8004422:	bf00      	nop
 8004424:	40021000 	.word	0x40021000

08004428 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8004428:	4b04      	ldr	r3, [pc, #16]	; (800443c <RCC_APB2PeriphResetCmd+0x14>)
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800442a:	68da      	ldr	r2, [r3, #12]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800442c:	b109      	cbz	r1, 8004432 <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800442e:	4310      	orrs	r0, r2
 8004430:	e001      	b.n	8004436 <RCC_APB2PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8004432:	ea22 0000 	bic.w	r0, r2, r0
 8004436:	60d8      	str	r0, [r3, #12]
 8004438:	4770      	bx	lr
 800443a:	bf00      	nop
 800443c:	40021000 	.word	0x40021000

08004440 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8004440:	4b04      	ldr	r3, [pc, #16]	; (8004454 <RCC_APB1PeriphResetCmd+0x14>)
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8004442:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004444:	b109      	cbz	r1, 800444a <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8004446:	4310      	orrs	r0, r2
 8004448:	e001      	b.n	800444e <RCC_APB1PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 800444a:	ea22 0000 	bic.w	r0, r2, r0
 800444e:	6118      	str	r0, [r3, #16]
 8004450:	4770      	bx	lr
 8004452:	bf00      	nop
 8004454:	40021000 	.word	0x40021000

08004458 <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 8004458:	4b04      	ldr	r3, [pc, #16]	; (800446c <RCC_ITConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800445a:	781a      	ldrb	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800445c:	b109      	cbz	r1, 8004462 <RCC_ITConfig+0xa>
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800445e:	4310      	orrs	r0, r2
 8004460:	e001      	b.n	8004466 <RCC_ITConfig+0xe>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8004462:	ea22 0000 	bic.w	r0, r2, r0
 8004466:	7018      	strb	r0, [r3, #0]
 8004468:	4770      	bx	lr
 800446a:	bf00      	nop
 800446c:	40021009 	.word	0x40021009

08004470 <RCC_GetFlagStatus>:
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

   if (tmp == 0)               /* The flag to check is in CR register */
 8004470:	0943      	lsrs	r3, r0, #5
 8004472:	4a09      	ldr	r2, [pc, #36]	; (8004498 <RCC_GetFlagStatus+0x28>)
 8004474:	d101      	bne.n	800447a <RCC_GetFlagStatus+0xa>
  {
    statusreg = RCC->CR;
 8004476:	6813      	ldr	r3, [r2, #0]
 8004478:	e007      	b.n	800448a <RCC_GetFlagStatus+0x1a>
  }
  else if (tmp == 1)          /* The flag to check is in BDCR register */
 800447a:	2b01      	cmp	r3, #1
 800447c:	d101      	bne.n	8004482 <RCC_GetFlagStatus+0x12>
  {
    statusreg = RCC->BDCR;
 800447e:	6a13      	ldr	r3, [r2, #32]
 8004480:	e003      	b.n	800448a <RCC_GetFlagStatus+0x1a>
  }
  else if (tmp == 4)          /* The flag to check is in CFGR register */
 8004482:	2b04      	cmp	r3, #4
  {
    statusreg = RCC->CFGR;
 8004484:	bf0c      	ite	eq
 8004486:	6853      	ldreq	r3, [r2, #4]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8004488:	6a53      	ldrne	r3, [r2, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;

  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800448a:	f000 001f 	and.w	r0, r0, #31
 800448e:	fa23 f000 	lsr.w	r0, r3, r0
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8004492:	f000 0001 	and.w	r0, r0, #1
 8004496:	4770      	bx	lr
 8004498:	40021000 	.word	0x40021000

0800449c <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800449c:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 800449e:	2300      	movs	r3, #0
 80044a0:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if timeout is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 80044a2:	2011      	movs	r0, #17
 80044a4:	f7ff ffe4 	bl	8004470 <RCC_GetFlagStatus>
    StartUpCounter++;  
 80044a8:	9b01      	ldr	r3, [sp, #4]
 80044aa:	3301      	adds	r3, #1
 80044ac:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 80044ae:	9b01      	ldr	r3, [sp, #4]
 80044b0:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80044b4:	d001      	beq.n	80044ba <RCC_WaitForHSEStartUp+0x1e>
 80044b6:	2800      	cmp	r0, #0
 80044b8:	d0f3      	beq.n	80044a2 <RCC_WaitForHSEStartUp+0x6>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 80044ba:	2011      	movs	r0, #17
 80044bc:	f7ff ffd8 	bl	8004470 <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }  
  return (status);
}
 80044c0:	3000      	adds	r0, #0
 80044c2:	bf18      	it	ne
 80044c4:	2001      	movne	r0, #1
 80044c6:	bd0e      	pop	{r1, r2, r3, pc}

080044c8 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 80044c8:	4b02      	ldr	r3, [pc, #8]	; (80044d4 <RCC_ClearFlag+0xc>)
 80044ca:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80044cc:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80044d0:	625a      	str	r2, [r3, #36]	; 0x24
 80044d2:	4770      	bx	lr
 80044d4:	40021000 	.word	0x40021000

080044d8 <RCC_GetITStatus>:
  
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));
  
  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 80044d8:	4b03      	ldr	r3, [pc, #12]	; (80044e8 <RCC_GetITStatus+0x10>)
 80044da:	689b      	ldr	r3, [r3, #8]
 80044dc:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 80044de:	bf0c      	ite	eq
 80044e0:	2000      	moveq	r0, #0
 80044e2:	2001      	movne	r0, #1
 80044e4:	4770      	bx	lr
 80044e6:	bf00      	nop
 80044e8:	40021000 	.word	0x40021000

080044ec <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
  
  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 80044ec:	4b01      	ldr	r3, [pc, #4]	; (80044f4 <RCC_ClearITPendingBit+0x8>)
 80044ee:	7018      	strb	r0, [r3, #0]
 80044f0:	4770      	bx	lr
 80044f2:	bf00      	nop
 80044f4:	4002100a 	.word	0x4002100a

080044f8 <SPI_I2S_DeInit>:
  * @param  SPIx: To select the SPIx peripheral, where x can be: 1, 2 or 3 
  *         in SPI mode.
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 80044f8:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 80044fa:	4b15      	ldr	r3, [pc, #84]	; (8004550 <SPI_I2S_DeInit+0x58>)
 80044fc:	4298      	cmp	r0, r3
 80044fe:	d10b      	bne.n	8004518 <SPI_I2S_DeInit+0x20>
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 8004500:	2101      	movs	r1, #1
 8004502:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8004506:	f7ff ff8f 	bl	8004428 <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 800450a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800450e:	2100      	movs	r1, #0
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
    }
  }
}
 8004510:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 8004514:	f7ff bf88 	b.w	8004428 <RCC_APB2PeriphResetCmd>
  }
  else if (SPIx == SPI2)
 8004518:	4b0e      	ldr	r3, [pc, #56]	; (8004554 <SPI_I2S_DeInit+0x5c>)
 800451a:	4298      	cmp	r0, r3
 800451c:	d107      	bne.n	800452e <SPI_I2S_DeInit+0x36>
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 800451e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8004522:	2101      	movs	r1, #1
 8004524:	f7ff ff8c 	bl	8004440 <RCC_APB1PeriphResetCmd>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 8004528:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800452c:	e009      	b.n	8004542 <SPI_I2S_DeInit+0x4a>
  }
  else
  {
    if (SPIx == SPI3)
 800452e:	4b0a      	ldr	r3, [pc, #40]	; (8004558 <SPI_I2S_DeInit+0x60>)
 8004530:	4298      	cmp	r0, r3
 8004532:	d10b      	bne.n	800454c <SPI_I2S_DeInit+0x54>
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 8004534:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004538:	2101      	movs	r1, #1
 800453a:	f7ff ff81 	bl	8004440 <RCC_APB1PeriphResetCmd>
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 800453e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004542:	2100      	movs	r1, #0
    }
  }
}
 8004544:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (SPIx == SPI3)
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 8004548:	f7ff bf7a 	b.w	8004440 <RCC_APB1PeriphResetCmd>
 800454c:	bd08      	pop	{r3, pc}
 800454e:	bf00      	nop
 8004550:	40013000 	.word	0x40013000
 8004554:	40003800 	.word	0x40003800
 8004558:	40003c00 	.word	0x40003c00

0800455c <SPI_StructInit>:
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 800455c:	2300      	movs	r3, #0
 800455e:	8003      	strh	r3, [r0, #0]
  /* Initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 8004560:	8043      	strh	r3, [r0, #2]
  /* Initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 8004562:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 8004566:	80c3      	strh	r3, [r0, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 8004568:	8103      	strh	r3, [r0, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 800456a:	8143      	strh	r3, [r0, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 800456c:	8183      	strh	r3, [r0, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 800456e:	81c3      	strh	r3, [r0, #14]
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8004570:	2307      	movs	r3, #7
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
  /* Initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
  /* Initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 8004572:	8082      	strh	r2, [r0, #4]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8004574:	8203      	strh	r3, [r0, #16]
 8004576:	4770      	bx	lr

08004578 <SPI_Init>:
  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

  /* Configuring the SPI in master mode */
  if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
 8004578:	884a      	ldrh	r2, [r1, #2]
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 800457a:	b530      	push	{r4, r5, lr}
  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

  /* Configuring the SPI in master mode */
  if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
 800457c:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 8004580:	d11a      	bne.n	80045b8 <SPI_Init+0x40>
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
 8004582:	880c      	ldrh	r4, [r1, #0]
 8004584:	88cb      	ldrh	r3, [r1, #6]
  /* Configuring the SPI in master mode */
  if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
  {
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
 8004586:	8802      	ldrh	r2, [r0, #0]
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
 8004588:	4323      	orrs	r3, r4
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 800458a:	890c      	ldrh	r4, [r1, #8]
 800458c:	f443 7382 	orr.w	r3, r3, #260	; 0x104
 8004590:	4323      	orrs	r3, r4
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
 8004592:	894c      	ldrh	r4, [r1, #10]
  {
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
    /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    tmpreg &= CR1_CLEAR_MASK;
 8004594:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
 8004598:	4323      	orrs	r3, r4
 800459a:	898c      	ldrh	r4, [r1, #12]
 800459c:	4323      	orrs	r3, r4
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
 800459e:	89cc      	ldrh	r4, [r1, #14]
 80045a0:	4323      	orrs	r3, r4
 80045a2:	4313      	orrs	r3, r2
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
                         SPI_InitStruct->SPI_FirstBit)));
    /* Write to SPIx CR1 */
    SPIx->CR1 = tmpreg;
 80045a4:	8003      	strh	r3, [r0, #0]
    /*-------------------------Data Size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
 80045a6:	8883      	ldrh	r3, [r0, #4]
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 80045a8:	888a      	ldrh	r2, [r1, #4]
    SPIx->CR1 = tmpreg;
    /*-------------------------Data Size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
 80045aa:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80045ae:	041b      	lsls	r3, r3, #16
 80045b0:	0c1b      	lsrs	r3, r3, #16
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 80045b2:	4313      	orrs	r3, r2
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
 80045b4:	8083      	strh	r3, [r0, #4]
 80045b6:	e018      	b.n	80045ea <SPI_Init+0x72>
  /* Configuring the SPI in slave mode */
  else
  {
/*---------------------------- Data size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
 80045b8:	8883      	ldrh	r3, [r0, #4]
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 80045ba:	888c      	ldrh	r4, [r1, #4]
  {
/*---------------------------- Data size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
 80045bc:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80045c0:	041b      	lsls	r3, r3, #16
 80045c2:	0c1b      	lsrs	r3, r3, #16
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 80045c4:	4323      	orrs	r3, r4
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
 80045c6:	8083      	strh	r3, [r0, #4]
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 80045c8:	880b      	ldrh	r3, [r1, #0]
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 80045ca:	88cd      	ldrh	r5, [r1, #6]
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 80045cc:	4313      	orrs	r3, r2
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 80045ce:	432b      	orrs	r3, r5
 80045d0:	890d      	ldrh	r5, [r1, #8]
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
 80045d2:	8804      	ldrh	r4, [r0, #0]
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 80045d4:	432b      	orrs	r3, r5
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
 80045d6:	894d      	ldrh	r5, [r1, #10]
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 80045d8:	89ca      	ldrh	r2, [r1, #14]
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
 80045da:	432b      	orrs	r3, r5
 80045dc:	898d      	ldrh	r5, [r1, #12]
    SPIx->CR2 = tmpreg;
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
    /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    tmpreg &= CR1_CLEAR_MASK;
 80045de:	f404 5441 	and.w	r4, r4, #12352	; 0x3040
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
 80045e2:	432b      	orrs	r3, r5
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 80045e4:	4313      	orrs	r3, r2
 80045e6:	4323      	orrs	r3, r4
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
                         SPI_InitStruct->SPI_FirstBit)));

    /* Write to SPIx CR1 */
    SPIx->CR1 = tmpreg;
 80045e8:	8003      	strh	r3, [r0, #0]
  }

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 80045ea:	8b83      	ldrh	r3, [r0, #28]
 80045ec:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80045f0:	041b      	lsls	r3, r3, #16
 80045f2:	0c1b      	lsrs	r3, r3, #16
 80045f4:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 80045f6:	8a0b      	ldrh	r3, [r1, #16]
 80045f8:	8203      	strh	r3, [r0, #16]
 80045fa:	bd30      	pop	{r4, r5, pc}

080045fc <I2S_StructInit>:
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 80045fc:	2300      	movs	r3, #0

  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;

  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 80045fe:	2202      	movs	r2, #2
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8004600:	8003      	strh	r3, [r0, #0]

  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 8004602:	8043      	strh	r3, [r0, #2]

  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 8004604:	8083      	strh	r3, [r0, #4]

  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 8004606:	80c3      	strh	r3, [r0, #6]

  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 8004608:	6082      	str	r2, [r0, #8]

  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 800460a:	8183      	strh	r3, [r0, #12]
 800460c:	4770      	bx	lr

0800460e <I2S_Init>:
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800460e:	8b83      	ldrh	r3, [r0, #28]
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.     
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 8004610:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8004612:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8004616:	f023 030f 	bic.w	r3, r3, #15
 800461a:	041b      	lsls	r3, r3, #16
 800461c:	0c1b      	lsrs	r3, r3, #16
 800461e:	8383      	strh	r3, [r0, #28]
  SPIx->I2SPR = 0x0002;
 8004620:	2302      	movs	r3, #2
 8004622:	8403      	strh	r3, [r0, #32]

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8004624:	688b      	ldr	r3, [r1, #8]
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.     
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 8004626:	b091      	sub	sp, #68	; 0x44

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8004628:	2b02      	cmp	r3, #2
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.     
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 800462a:	4605      	mov	r5, r0
 800462c:	460c      	mov	r4, r1
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  SPIx->I2SPR = 0x0002;

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 800462e:	8b86      	ldrh	r6, [r0, #28]

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8004630:	d023      	beq.n	800467a <I2S_Init+0x6c>
      /* Packet length is 32 bits */
      packetlength = 2;
    }

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      
 8004632:	a801      	add	r0, sp, #4
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) */
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 8004634:	888f      	ldrh	r7, [r1, #4]
      /* Packet length is 32 bits */
      packetlength = 2;
    }

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      
 8004636:	f7ff fd21 	bl	800407c <RCC_GetClocksFreq>

    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 800463a:	88e3      	ldrh	r3, [r4, #6]
  {
    /* Check the frame length (For the Prescaler computing) */
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
    {
      /* Packet length is 16 bits */
      packetlength = 1;
 800463c:	2f00      	cmp	r7, #0
 800463e:	bf14      	ite	ne
 8004640:	2702      	movne	r7, #2
 8004642:	2701      	moveq	r7, #1

    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8004644:	f5b3 7f00 	cmp.w	r3, #512	; 0x200

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      

    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    
 8004648:	9a01      	ldr	r2, [sp, #4]
 800464a:	f04f 030a 	mov.w	r3, #10

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 800464e:	d101      	bne.n	8004654 <I2S_Init+0x46>
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004650:	0a12      	lsrs	r2, r2, #8
 8004652:	e002      	b.n	800465a <I2S_Init+0x4c>
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004654:	017f      	lsls	r7, r7, #5
 8004656:	fbb2 f2f7 	udiv	r2, r2, r7
 800465a:	4353      	muls	r3, r2
 800465c:	68a1      	ldr	r1, [r4, #8]
    }
    
    /* Remove the floating point */
    tmp = tmp / 10;
 800465e:	220a      	movs	r2, #10
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004660:	fbb3 f3f1 	udiv	r3, r3, r1
 8004664:	3305      	adds	r3, #5
 8004666:	b29b      	uxth	r3, r3
    }
    
    /* Remove the floating point */
    tmp = tmp / 10;
 8004668:	fbb3 f3f2 	udiv	r3, r3, r2

    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 800466c:	f003 0201 	and.w	r2, r3, #1

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 8004670:	0212      	lsls	r2, r2, #8

    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8004672:	f3c3 034f 	ubfx	r3, r3, #1, #16

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 8004676:	b292      	uxth	r2, r2
 8004678:	e000      	b.n	800467c <I2S_Init+0x6e>
  tmpreg = SPIx->I2SCFGR;

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
  {
    i2sodd = (uint16_t)0;
 800467a:	2200      	movs	r2, #0
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 800467c:	1e99      	subs	r1, r3, #2
 800467e:	b289      	uxth	r1, r1
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 8004680:	29fe      	cmp	r1, #254	; 0xfe
 8004682:	bf28      	it	cs
 8004684:	2200      	movcs	r2, #0
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8004686:	88e1      	ldrh	r1, [r4, #6]
  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 8004688:	bf28      	it	cs
 800468a:	2302      	movcs	r3, #2
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 800468c:	4313      	orrs	r3, r2
 800468e:	430b      	orrs	r3, r1
 8004690:	842b      	strh	r3, [r5, #32]

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
 8004692:	8823      	ldrh	r3, [r4, #0]

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
 8004694:	8862      	ldrh	r2, [r4, #2]
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
 8004696:	4333      	orrs	r3, r6
 8004698:	f443 6300 	orr.w	r3, r3, #2048	; 0x800

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
 800469c:	4313      	orrs	r3, r2
 800469e:	88a2      	ldrh	r2, [r4, #4]
 80046a0:	4313      	orrs	r3, r2
 80046a2:	89a2      	ldrh	r2, [r4, #12]
 80046a4:	4313      	orrs	r3, r2
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
                       I2S_InitStruct->I2S_CPOL)));

  /* Write to SPIx I2SCFGR */
  SPIx->I2SCFGR = tmpreg;
 80046a6:	83ab      	strh	r3, [r5, #28]
}
 80046a8:	b011      	add	sp, #68	; 0x44
 80046aa:	bdf0      	pop	{r4, r5, r6, r7, pc}

080046ac <SPI_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 80046ac:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80046ae:	b119      	cbz	r1, 80046b8 <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 80046b0:	b29b      	uxth	r3, r3
 80046b2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80046b6:	e003      	b.n	80046c0 <SPI_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 80046b8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80046bc:	041b      	lsls	r3, r3, #16
 80046be:	0c1b      	lsrs	r3, r3, #16
 80046c0:	8003      	strh	r3, [r0, #0]
 80046c2:	4770      	bx	lr

080046c4 <SPI_TIModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 80046c4:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80046c6:	b119      	cbz	r1, 80046d0 <SPI_TIModeCmd+0xc>
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 80046c8:	b29b      	uxth	r3, r3
 80046ca:	f043 0310 	orr.w	r3, r3, #16
 80046ce:	e003      	b.n	80046d8 <SPI_TIModeCmd+0x14>
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
 80046d0:	f023 0310 	bic.w	r3, r3, #16
 80046d4:	041b      	lsls	r3, r3, #16
 80046d6:	0c1b      	lsrs	r3, r3, #16
 80046d8:	8083      	strh	r3, [r0, #4]
 80046da:	4770      	bx	lr

080046dc <I2S_Cmd>:
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80046dc:	8b83      	ldrh	r3, [r0, #28]
void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80046de:	b119      	cbz	r1, 80046e8 <I2S_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80046e0:	b29b      	uxth	r3, r3
 80046e2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80046e6:	e003      	b.n	80046f0 <I2S_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 80046e8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80046ec:	041b      	lsls	r3, r3, #16
 80046ee:	0c1b      	lsrs	r3, r3, #16
 80046f0:	8383      	strh	r3, [r0, #28]
 80046f2:	4770      	bx	lr

080046f4 <SPI_DataSizeConfig>:
  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
  /* Read the CR2 register */
  tmpreg = SPIx->CR2;
 80046f4:	8883      	ldrh	r3, [r0, #4]
  /* Clear DS[3:0] bits */
  tmpreg &= (uint16_t)~SPI_CR2_DS;
 80046f6:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80046fa:	041b      	lsls	r3, r3, #16
 80046fc:	0c1b      	lsrs	r3, r3, #16
  /* Set new DS[3:0] bits value */
  tmpreg |= SPI_DataSize;
 80046fe:	4319      	orrs	r1, r3
  SPIx->CR2 = tmpreg;
 8004700:	8081      	strh	r1, [r0, #4]
 8004702:	4770      	bx	lr

08004704 <SPI_RxFIFOThresholdConfig>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));

  /* Clear FRXTH bit */
  SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
 8004704:	8883      	ldrh	r3, [r0, #4]
 8004706:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800470a:	041b      	lsls	r3, r3, #16
 800470c:	0c1b      	lsrs	r3, r3, #16
 800470e:	8083      	strh	r3, [r0, #4]

  /* Set new FRXTH bit value */
  SPIx->CR2 |= SPI_RxFIFOThreshold;
 8004710:	8883      	ldrh	r3, [r0, #4]
 8004712:	b29b      	uxth	r3, r3
 8004714:	4319      	orrs	r1, r3
 8004716:	8081      	strh	r1, [r0, #4]
 8004718:	4770      	bx	lr

0800471a <SPI_BiDirectionalLineConfig>:
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 800471a:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 800471e:	8803      	ldrh	r3, [r0, #0]
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8004720:	d103      	bne.n	800472a <SPI_BiDirectionalLineConfig+0x10>
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8004722:	b29b      	uxth	r3, r3
 8004724:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8004728:	e003      	b.n	8004732 <SPI_BiDirectionalLineConfig+0x18>
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 800472a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800472e:	041b      	lsls	r3, r3, #16
 8004730:	0c1b      	lsrs	r3, r3, #16
 8004732:	8003      	strh	r3, [r0, #0]
 8004734:	4770      	bx	lr

08004736 <SPI_NSSInternalSoftwareConfig>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));

  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8004736:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 800473a:	4299      	cmp	r1, r3
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 800473c:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));

  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 800473e:	d003      	beq.n	8004748 <SPI_NSSInternalSoftwareConfig+0x12>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8004740:	b29b      	uxth	r3, r3
 8004742:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004746:	e003      	b.n	8004750 <SPI_NSSInternalSoftwareConfig+0x1a>
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 8004748:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800474c:	041b      	lsls	r3, r3, #16
 800474e:	0c1b      	lsrs	r3, r3, #16
 8004750:	8003      	strh	r3, [r0, #0]
 8004752:	4770      	bx	lr

08004754 <I2S_FullDuplexConfig>:
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8004754:	8b83      	ldrh	r3, [r0, #28]
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
 8004756:	b510      	push	{r4, lr}
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8004758:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 800475c:	f023 030f 	bic.w	r3, r3, #15
 8004760:	041b      	lsls	r3, r3, #16
 8004762:	0c1b      	lsrs	r3, r3, #16
 8004764:	8383      	strh	r3, [r0, #28]
  I2Sxext->I2SPR = 0x0002;
 8004766:	2302      	movs	r3, #2
 8004768:	8403      	strh	r3, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 800476a:	880b      	ldrh	r3, [r1, #0]
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  I2Sxext->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 800476c:	8b82      	ldrh	r2, [r0, #28]
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 800476e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004772:	d102      	bne.n	800477a <I2S_FullDuplexConfig+0x26>
  {
    tmp = I2S_Mode_SlaveRx;
 8004774:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004778:	e002      	b.n	8004780 <I2S_FullDuplexConfig+0x2c>
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 800477a:	2b00      	cmp	r3, #0
 800477c:	d0fa      	beq.n	8004774 <I2S_FullDuplexConfig+0x20>
  }
  else
  {
    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
    {
      tmp = I2S_Mode_SlaveTx;
 800477e:	2300      	movs	r3, #0
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004780:	884c      	ldrh	r4, [r1, #2]
 8004782:	4322      	orrs	r2, r4
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8004784:	888c      	ldrh	r4, [r1, #4]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004786:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 800478a:	8989      	ldrh	r1, [r1, #12]
 800478c:	4322      	orrs	r2, r4
 800478e:	430a      	orrs	r2, r1
 8004790:	b292      	uxth	r2, r2
 8004792:	4313      	orrs	r3, r2
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 8004794:	8383      	strh	r3, [r0, #28]
 8004796:	bd10      	pop	{r4, pc}

08004798 <SPI_SSOutputCmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 8004798:	8883      	ldrh	r3, [r0, #4]
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800479a:	b119      	cbz	r1, 80047a4 <SPI_SSOutputCmd+0xc>
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 800479c:	b29b      	uxth	r3, r3
 800479e:	f043 0304 	orr.w	r3, r3, #4
 80047a2:	e003      	b.n	80047ac <SPI_SSOutputCmd+0x14>
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 80047a4:	f023 0304 	bic.w	r3, r3, #4
 80047a8:	041b      	lsls	r3, r3, #16
 80047aa:	0c1b      	lsrs	r3, r3, #16
 80047ac:	8083      	strh	r3, [r0, #4]
 80047ae:	4770      	bx	lr

080047b0 <SPI_NSSPulseModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the NSS pulse management mode */
    SPIx->CR2 |= SPI_CR2_NSSP;
 80047b0:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80047b2:	b119      	cbz	r1, 80047bc <SPI_NSSPulseModeCmd+0xc>
  {
    /* Enable the NSS pulse management mode */
    SPIx->CR2 |= SPI_CR2_NSSP;
 80047b4:	b29b      	uxth	r3, r3
 80047b6:	f043 0308 	orr.w	r3, r3, #8
 80047ba:	e003      	b.n	80047c4 <SPI_NSSPulseModeCmd+0x14>
  }
  else
  {
    /* Disable the NSS pulse management mode */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
 80047bc:	f023 0308 	bic.w	r3, r3, #8
 80047c0:	041b      	lsls	r3, r3, #16
 80047c2:	0c1b      	lsrs	r3, r3, #16
 80047c4:	8083      	strh	r3, [r0, #4]
 80047c6:	4770      	bx	lr

080047c8 <SPI_SendData8>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  spixbase = (uint32_t)SPIx; 
  spixbase += 0x0C;
  
  *(__IO uint8_t *) spixbase = Data;
 80047c8:	7301      	strb	r1, [r0, #12]
 80047ca:	4770      	bx	lr

080047cc <SPI_I2S_SendData16>:
void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  SPIx->DR = (uint16_t)Data;
 80047cc:	8181      	strh	r1, [r0, #12]
 80047ce:	4770      	bx	lr

080047d0 <SPI_ReceiveData8>:
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  spixbase = (uint32_t)SPIx; 
  spixbase += 0x0C;
  
  return *(__IO uint8_t *) spixbase;
 80047d0:	7b00      	ldrb	r0, [r0, #12]
}
 80047d2:	4770      	bx	lr

080047d4 <SPI_I2S_ReceiveData16>:
uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
{  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  return SPIx->DR;
 80047d4:	8980      	ldrh	r0, [r0, #12]
}
 80047d6:	b280      	uxth	r0, r0
 80047d8:	4770      	bx	lr

080047da <SPI_CRCLengthConfig>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));

  /* Clear CRCL bit */
  SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
 80047da:	8803      	ldrh	r3, [r0, #0]
 80047dc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80047e0:	041b      	lsls	r3, r3, #16
 80047e2:	0c1b      	lsrs	r3, r3, #16
 80047e4:	8003      	strh	r3, [r0, #0]

  /* Set new CRCL bit value */
  SPIx->CR1 |= SPI_CRCLength;
 80047e6:	8803      	ldrh	r3, [r0, #0]
 80047e8:	b29b      	uxth	r3, r3
 80047ea:	4319      	orrs	r1, r3
 80047ec:	8001      	strh	r1, [r0, #0]
 80047ee:	4770      	bx	lr

080047f0 <SPI_CalculateCRC>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 80047f0:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80047f2:	b119      	cbz	r1, 80047fc <SPI_CalculateCRC+0xc>
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 80047f4:	b29b      	uxth	r3, r3
 80047f6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80047fa:	e003      	b.n	8004804 <SPI_CalculateCRC+0x14>
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 80047fc:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8004800:	041b      	lsls	r3, r3, #16
 8004802:	0c1b      	lsrs	r3, r3, #16
 8004804:	8003      	strh	r3, [r0, #0]
 8004806:	4770      	bx	lr

08004808 <SPI_TransmitCRC>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 8004808:	8803      	ldrh	r3, [r0, #0]
 800480a:	b29b      	uxth	r3, r3
 800480c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004810:	8003      	strh	r3, [r0, #0]
 8004812:	4770      	bx	lr

08004814 <SPI_GetCRC>:
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));

  if (SPI_CRC != SPI_CRC_Rx)
 8004814:	2901      	cmp	r1, #1
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 8004816:	bf14      	ite	ne
 8004818:	8b00      	ldrhne	r0, [r0, #24]
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 800481a:	8a80      	ldrheq	r0, [r0, #20]
 800481c:	b280      	uxth	r0, r0
  }
  /* Return the selected CRC register */
  return crcreg;
}
 800481e:	4770      	bx	lr

08004820 <SPI_GetCRCPolynomial>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 8004820:	8a00      	ldrh	r0, [r0, #16]
}
 8004822:	b280      	uxth	r0, r0
 8004824:	4770      	bx	lr

08004826 <SPI_I2S_DMACmd>:
  assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8004826:	8883      	ldrh	r3, [r0, #4]
 8004828:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
 800482a:	b10a      	cbz	r2, 8004830 <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 800482c:	4319      	orrs	r1, r3
 800482e:	e001      	b.n	8004834 <SPI_I2S_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8004830:	ea23 0101 	bic.w	r1, r3, r1
 8004834:	8081      	strh	r1, [r0, #4]
 8004836:	4770      	bx	lr

08004838 <SPI_LastDMATransferCmd>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));

  /* Clear LDMA_TX and LDMA_RX bits */
  SPIx->CR2 &= CR2_LDMA_MASK;
 8004838:	8883      	ldrh	r3, [r0, #4]
 800483a:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 800483e:	041b      	lsls	r3, r3, #16
 8004840:	0c1b      	lsrs	r3, r3, #16
 8004842:	8083      	strh	r3, [r0, #4]

  /* Set new LDMA_TX and LDMA_RX bits value */
  SPIx->CR2 |= SPI_LastDMATransfer; 
 8004844:	8883      	ldrh	r3, [r0, #4]
 8004846:	b29b      	uxth	r3, r3
 8004848:	4319      	orrs	r1, r3
 800484a:	8081      	strh	r1, [r0, #4]
 800484c:	4770      	bx	lr

0800484e <SPI_I2S_ITConfig>:

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 800484e:	0909      	lsrs	r1, r1, #4
 8004850:	2301      	movs	r3, #1
 8004852:	fa03 f301 	lsl.w	r3, r3, r1
 8004856:	b29b      	uxth	r3, r3

  if (NewState != DISABLE)
 8004858:	b11a      	cbz	r2, 8004862 <SPI_I2S_ITConfig+0x14>
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 800485a:	8882      	ldrh	r2, [r0, #4]
 800485c:	b292      	uxth	r2, r2
 800485e:	4313      	orrs	r3, r2
 8004860:	e003      	b.n	800486a <SPI_I2S_ITConfig+0x1c>
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 8004862:	8882      	ldrh	r2, [r0, #4]
 8004864:	b292      	uxth	r2, r2
 8004866:	ea22 0303 	bic.w	r3, r2, r3
 800486a:	8083      	strh	r3, [r0, #4]
 800486c:	4770      	bx	lr

0800486e <SPI_GetTransmissionFIFOStatus>:
  *   - SPI_TransmissionFIFOStatus_Full: when FIFO is full.
  */
uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
{
  /* Get the SPIx Transmission FIFO level bits */
  return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
 800486e:	8900      	ldrh	r0, [r0, #8]
}
 8004870:	f400 50c0 	and.w	r0, r0, #6144	; 0x1800
 8004874:	4770      	bx	lr

08004876 <SPI_GetReceptionFIFOStatus>:
  *   - SPI_ReceptionFIFOStatus_Full: when FIFO is full.
  */
uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
{
  /* Get the SPIx Reception FIFO level bits */
  return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
 8004876:	8900      	ldrh	r0, [r0, #8]
}
 8004878:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 800487c:	4770      	bx	lr

0800487e <SPI_I2S_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));

  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 800487e:	8903      	ldrh	r3, [r0, #8]
 8004880:	4219      	tst	r1, r3
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 8004882:	bf0c      	ite	eq
 8004884:	2000      	moveq	r0, #0
 8004886:	2001      	movne	r0, #1
 8004888:	4770      	bx	lr

0800488a <SPI_I2S_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));

  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 800488a:	43c9      	mvns	r1, r1
 800488c:	8101      	strh	r1, [r0, #8]
 800488e:	4770      	bx	lr

08004890 <SPI_I2S_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8004890:	2301      	movs	r3, #1
 8004892:	f001 020f 	and.w	r2, r1, #15
 8004896:	fa03 f202 	lsl.w	r2, r3, r2
  *     @arg I2S_IT_UDR: Underrun interrupt.  
  *     @arg SPI_I2S_IT_FRE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 800489a:	b510      	push	{r4, lr}

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 800489c:	8884      	ldrh	r4, [r0, #4]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 800489e:	8900      	ldrh	r0, [r0, #8]

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 80048a0:	b2a4      	uxth	r4, r4

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80048a2:	b280      	uxth	r0, r0
 80048a4:	4010      	ands	r0, r2
 80048a6:	d006      	beq.n	80048b6 <SPI_I2S_GetITStatus+0x26>

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 80048a8:	0909      	lsrs	r1, r1, #4
 80048aa:	fa03 f301 	lsl.w	r3, r3, r1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80048ae:	421c      	tst	r4, r3
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 80048b0:	bf0c      	ite	eq
 80048b2:	2000      	moveq	r0, #0
 80048b4:	2001      	movne	r0, #1
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 80048b6:	bd10      	pop	{r4, pc}

080048b8 <SYSCFG_DeInit>:
  *         MEM_MODE bits took the value from the user option bytes.
  */
void SYSCFG_DeInit(void)
{
  /* Reset SYSCFG_CFGR1 register to reset value without affecting MEM_MODE bits */
  SYSCFG->CFGR1 &= SYSCFG_CFGR1_MEM_MODE;
 80048b8:	4b08      	ldr	r3, [pc, #32]	; (80048dc <SYSCFG_DeInit+0x24>)
 80048ba:	681a      	ldr	r2, [r3, #0]
 80048bc:	f002 0203 	and.w	r2, r2, #3
 80048c0:	601a      	str	r2, [r3, #0]
  /* Set FPU Interrupt Enable bits to default value */
  SYSCFG->CFGR1 |= 0x7C000000;
 80048c2:	681a      	ldr	r2, [r3, #0]
 80048c4:	f042 42f8 	orr.w	r2, r2, #2080374784	; 0x7c000000
 80048c8:	601a      	str	r2, [r3, #0]
  /* Reset RAM Write protection bits to default value */
  SYSCFG->RCR = 0x00000000;
 80048ca:	2200      	movs	r2, #0
 80048cc:	605a      	str	r2, [r3, #4]
  /* Set EXTICRx registers to reset value */
  SYSCFG->EXTICR[0] = 0;
 80048ce:	609a      	str	r2, [r3, #8]
  SYSCFG->EXTICR[1] = 0;
 80048d0:	60da      	str	r2, [r3, #12]
  SYSCFG->EXTICR[2] = 0;
 80048d2:	611a      	str	r2, [r3, #16]
  SYSCFG->EXTICR[3] = 0;
 80048d4:	615a      	str	r2, [r3, #20]
  /* Set CFGR2 register to reset value */
  SYSCFG->CFGR2 = 0;
 80048d6:	619a      	str	r2, [r3, #24]
 80048d8:	4770      	bx	lr
 80048da:	bf00      	nop
 80048dc:	40010000 	.word	0x40010000

080048e0 <SYSCFG_MemoryRemapConfig>:

  /* Check the parameter */
  assert_param(IS_SYSCFG_MEMORY_REMAP(SYSCFG_MemoryRemap));

  /* Get CFGR1 register value */
  tmpcfgr1 = SYSCFG->CFGR1;
 80048e0:	4b03      	ldr	r3, [pc, #12]	; (80048f0 <SYSCFG_MemoryRemapConfig+0x10>)
 80048e2:	681a      	ldr	r2, [r3, #0]

  /* Clear MEM_MODE bits */
  tmpcfgr1 &= (uint32_t) (~SYSCFG_CFGR1_MEM_MODE);
 80048e4:	f022 0203 	bic.w	r2, r2, #3

  /* Set the new MEM_MODE bits value */
  tmpcfgr1 |= (uint32_t) SYSCFG_MemoryRemap;
 80048e8:	4310      	orrs	r0, r2

  /* Set CFGR1 register with the new memory remap configuration */
  SYSCFG->CFGR1 = tmpcfgr1;
 80048ea:	6018      	str	r0, [r3, #0]
 80048ec:	4770      	bx	lr
 80048ee:	bf00      	nop
 80048f0:	40010000 	.word	0x40010000

080048f4 <SYSCFG_DMAChannelRemapConfig>:
  *           use SYSCFG_DMAChannelRemapConfig(SYSCFG_DMARemap_TIM17, Disable)
  *           to map TIM17 DMA requests to DMA1 channel 1 (default mapping)
  * @retval None
  */
void SYSCFG_DMAChannelRemapConfig(uint32_t SYSCFG_DMARemap, FunctionalState NewState)
{
 80048f4:	4b04      	ldr	r3, [pc, #16]	; (8004908 <SYSCFG_DMAChannelRemapConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Remap the DMA channel */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_DMARemap;
 80048f6:	681a      	ldr	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_DMA_REMAP(SYSCFG_DMARemap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80048f8:	b109      	cbz	r1, 80048fe <SYSCFG_DMAChannelRemapConfig+0xa>
  {
    /* Remap the DMA channel */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_DMARemap;
 80048fa:	4310      	orrs	r0, r2
 80048fc:	e001      	b.n	8004902 <SYSCFG_DMAChannelRemapConfig+0xe>
  }
  else
  {
    /* use the default DMA channel mapping */
    SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_DMARemap);
 80048fe:	ea22 0000 	bic.w	r0, r2, r0
 8004902:	6018      	str	r0, [r3, #0]
 8004904:	4770      	bx	lr
 8004906:	bf00      	nop
 8004908:	40010000 	.word	0x40010000

0800490c <SYSCFG_TriggerRemapConfig>:
  * @note   ENABLE:  Enable fast mode plus driving capability for selected pin
  * @note   DISABLE: Disable fast mode plus driving capability for selected pin
  * @retval None
  */
void SYSCFG_TriggerRemapConfig(uint32_t SYSCFG_TriggerRemap, FunctionalState NewState)
{
 800490c:	4b04      	ldr	r3, [pc, #16]	; (8004920 <SYSCFG_TriggerRemapConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Remap the trigger */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_TriggerRemap;
 800490e:	681a      	ldr	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_TRIGGER_REMAP(SYSCFG_TriggerRemap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004910:	b109      	cbz	r1, 8004916 <SYSCFG_TriggerRemapConfig+0xa>
  {
    /* Remap the trigger */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_TriggerRemap;
 8004912:	4310      	orrs	r0, r2
 8004914:	e001      	b.n	800491a <SYSCFG_TriggerRemapConfig+0xe>
  }
  else
  {
    /* Use the default trigger mapping */
    SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_TriggerRemap);
 8004916:	ea22 0000 	bic.w	r0, r2, r0
 800491a:	6018      	str	r0, [r3, #0]
 800491c:	4770      	bx	lr
 800491e:	bf00      	nop
 8004920:	40010000 	.word	0x40010000

08004924 <SYSCFG_EncoderRemapConfig>:
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_ENCODER_REMAP(SYSCFG_EncoderRemap));

  /* Reset the encoder mode remapping bits */
  SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_CFGR1_ENCODER_MODE);
 8004924:	4b04      	ldr	r3, [pc, #16]	; (8004938 <SYSCFG_EncoderRemapConfig+0x14>)
 8004926:	681a      	ldr	r2, [r3, #0]
 8004928:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800492c:	601a      	str	r2, [r3, #0]

  /* Set the selected configuration */
  SYSCFG->CFGR1 |= (uint32_t)(SYSCFG_EncoderRemap);
 800492e:	681a      	ldr	r2, [r3, #0]
 8004930:	4310      	orrs	r0, r2
 8004932:	6018      	str	r0, [r3, #0]
 8004934:	4770      	bx	lr
 8004936:	bf00      	nop
 8004938:	40010000 	.word	0x40010000

0800493c <SYSCFG_USBInterruptLineRemapCmd>:
{
  /* Check the parameter */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Remap the USB interupt lines */
  *(__IO uint32_t *) CFGR1_USBITRMP_BB = (uint32_t)NewState;
 800493c:	4b01      	ldr	r3, [pc, #4]	; (8004944 <SYSCFG_USBInterruptLineRemapCmd+0x8>)
 800493e:	6018      	str	r0, [r3, #0]
 8004940:	4770      	bx	lr
 8004942:	bf00      	nop
 8004944:	42200014 	.word	0x42200014

08004948 <SYSCFG_I2CFastModePlusConfig>:
  * @note  For all I2C2 pins fast mode plus driving capability can be enabled
  *        only by using SYSCFG_I2CFastModePlus_I2C2 parameter.
  * @retval None
  */
void SYSCFG_I2CFastModePlusConfig(uint32_t SYSCFG_I2CFastModePlus, FunctionalState NewState)
{
 8004948:	4b04      	ldr	r3, [pc, #16]	; (800495c <SYSCFG_I2CFastModePlusConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable fast mode plus driving capability for selected I2C pin */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_I2CFastModePlus;
 800494a:	681a      	ldr	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_I2C_FMP(SYSCFG_I2CFastModePlus));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800494c:	b109      	cbz	r1, 8004952 <SYSCFG_I2CFastModePlusConfig+0xa>
  {
    /* Enable fast mode plus driving capability for selected I2C pin */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_I2CFastModePlus;
 800494e:	4310      	orrs	r0, r2
 8004950:	e001      	b.n	8004956 <SYSCFG_I2CFastModePlusConfig+0xe>
  }
  else
  {
    /* Disable fast mode plus driving capability for selected I2C pin */
    SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_I2CFastModePlus);
 8004952:	ea22 0000 	bic.w	r0, r2, r0
 8004956:	6018      	str	r0, [r3, #0]
 8004958:	4770      	bx	lr
 800495a:	bf00      	nop
 800495c:	40010000 	.word	0x40010000

08004960 <SYSCFG_ITConfig>:
  * @param  NewState: new state of the specified SYSCFG interrupts.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SYSCFG_ITConfig(uint32_t SYSCFG_IT, FunctionalState NewState)  
{
 8004960:	4b04      	ldr	r3, [pc, #16]	; (8004974 <SYSCFG_ITConfig+0x14>)
  assert_param(IS_SYSCFG_IT(SYSCFG_IT)); 

  if (NewState != DISABLE)
  {
    /* Enable the selected SYSCFG interrupts */
    SYSCFG->CFGR1 |= SYSCFG_IT;
 8004962:	681a      	ldr	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SYSCFG_IT(SYSCFG_IT)); 

  if (NewState != DISABLE)
 8004964:	b109      	cbz	r1, 800496a <SYSCFG_ITConfig+0xa>
  {
    /* Enable the selected SYSCFG interrupts */
    SYSCFG->CFGR1 |= SYSCFG_IT;
 8004966:	4310      	orrs	r0, r2
 8004968:	e001      	b.n	800496e <SYSCFG_ITConfig+0xe>
  }
  else
  {
    /* Disable the selected SYSCFG interrupts */
    SYSCFG->CFGR1 &= ((uint32_t)~SYSCFG_IT);
 800496a:	ea22 0000 	bic.w	r0, r2, r0
 800496e:	6018      	str	r0, [r3, #0]
 8004970:	4770      	bx	lr
 8004972:	bf00      	nop
 8004974:	40010000 	.word	0x40010000

08004978 <SYSCFG_EXTILineConfig>:

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 8004978:	f001 0203 	and.w	r2, r1, #3
  * @param  EXTI_PinSourcex: specifies the EXTI line to be configured.
  *         This parameter can be EXTI_PinSourcex where x can be (0..15)
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 800497c:	b530      	push	{r4, r5, lr}

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 800497e:	0092      	lsls	r2, r2, #2
 8004980:	240f      	movs	r4, #15
 8004982:	fa04 f402 	lsl.w	r4, r4, r2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8004986:	fa00 f002 	lsl.w	r0, r0, r2
  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 800498a:	4b07      	ldr	r3, [pc, #28]	; (80049a8 <SYSCFG_EXTILineConfig+0x30>)
 800498c:	0889      	lsrs	r1, r1, #2
 800498e:	3102      	adds	r1, #2
 8004990:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
 8004994:	ea25 0404 	bic.w	r4, r5, r4
 8004998:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 800499c:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 80049a0:	4304      	orrs	r4, r0
 80049a2:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
 80049a6:	bd30      	pop	{r4, r5, pc}
 80049a8:	40010000 	.word	0x40010000

080049ac <SYSCFG_BreakConfig>:
void SYSCFG_BreakConfig(uint32_t SYSCFG_Break)
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_LOCK_CONFIG(SYSCFG_Break));

  SYSCFG->CFGR2 |= (uint32_t) SYSCFG_Break;
 80049ac:	4b02      	ldr	r3, [pc, #8]	; (80049b8 <SYSCFG_BreakConfig+0xc>)
 80049ae:	699a      	ldr	r2, [r3, #24]
 80049b0:	4310      	orrs	r0, r2
 80049b2:	6198      	str	r0, [r3, #24]
 80049b4:	4770      	bx	lr
 80049b6:	bf00      	nop
 80049b8:	40010000 	.word	0x40010000

080049bc <SYSCFG_BypassParityCheckDisable>:
  * @retval None
  */
void SYSCFG_BypassParityCheckDisable(void)
{
  /* Disable the adddress parity check on RAM */
  *(__IO uint32_t *) CFGR1_BYPADDRPAR_BB = (uint32_t)0x00000001;
 80049bc:	4b01      	ldr	r3, [pc, #4]	; (80049c4 <SYSCFG_BypassParityCheckDisable+0x8>)
 80049be:	2201      	movs	r2, #1
 80049c0:	601a      	str	r2, [r3, #0]
 80049c2:	4770      	bx	lr
 80049c4:	42200310 	.word	0x42200310

080049c8 <SYSCFG_SRAMWRPEnable>:
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_PAGE(SYSCFG_SRAMWRP));

  /* Enable the write-protection on the selected ICODE SRAM page */
  SYSCFG->RCR |= (uint32_t)SYSCFG_SRAMWRP;
 80049c8:	4b02      	ldr	r3, [pc, #8]	; (80049d4 <SYSCFG_SRAMWRPEnable+0xc>)
 80049ca:	685a      	ldr	r2, [r3, #4]
 80049cc:	4310      	orrs	r0, r2
 80049ce:	6058      	str	r0, [r3, #4]
 80049d0:	4770      	bx	lr
 80049d2:	bf00      	nop
 80049d4:	40010000 	.word	0x40010000

080049d8 <SYSCFG_GetFlagStatus>:

  /* Check the parameter */
  assert_param(IS_SYSCFG_FLAG(SYSCFG_Flag));

  /* Check the status of the specified SPI flag */
  if ((SYSCFG->CFGR2 & SYSCFG_CFGR2_SRAM_PE) != (uint32_t)RESET)
 80049d8:	4b02      	ldr	r3, [pc, #8]	; (80049e4 <SYSCFG_GetFlagStatus+0xc>)
 80049da:	6998      	ldr	r0, [r3, #24]
    /* SYSCFG_Flag is reset */
    bitstatus = RESET;
  }
  /* Return the SYSCFG_Flag status */
  return  bitstatus;
}
 80049dc:	f3c0 2000 	ubfx	r0, r0, #8, #1
 80049e0:	4770      	bx	lr
 80049e2:	bf00      	nop
 80049e4:	40010000 	.word	0x40010000

080049e8 <SYSCFG_ClearFlag>:
void SYSCFG_ClearFlag(uint32_t SYSCFG_Flag)
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_FLAG(SYSCFG_Flag));

  SYSCFG->CFGR2 |= (uint32_t) SYSCFG_Flag;
 80049e8:	4b02      	ldr	r3, [pc, #8]	; (80049f4 <SYSCFG_ClearFlag+0xc>)
 80049ea:	699a      	ldr	r2, [r3, #24]
 80049ec:	4310      	orrs	r0, r2
 80049ee:	6198      	str	r0, [r3, #24]
 80049f0:	4770      	bx	lr
 80049f2:	bf00      	nop
 80049f4:	40010000 	.word	0x40010000

080049f8 <TI1_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 80049f8:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 80049fa:	6a04      	ldr	r4, [r0, #32]
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint32_t)(TIM_ICPolarity | (uint32_t)TIM_CCER_CC1E);
 80049fc:	f041 0101 	orr.w	r1, r1, #1
                       uint16_t TIM_ICFilter)
{
  uint32_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 8004a00:	f024 0401 	bic.w	r4, r4, #1
 8004a04:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004a06:	6985      	ldr	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 8004a08:	6a04      	ldr	r4, [r0, #32]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
 8004a0a:	f025 05f3 	bic.w	r5, r5, #243	; 0xf3
  tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));
 8004a0e:	432a      	orrs	r2, r5

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004a10:	f024 040a 	bic.w	r4, r4, #10
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));
 8004a14:	ea42 1303 	orr.w	r3, r2, r3, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint32_t)(TIM_ICPolarity | (uint32_t)TIM_CCER_CC1E);
 8004a18:	430c      	orrs	r4, r1

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8004a1a:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8004a1c:	6204      	str	r4, [r0, #32]
 8004a1e:	bd30      	pop	{r4, r5, pc}

08004a20 <TI2_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8004a20:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8004a22:	6a05      	ldr	r5, [r0, #32]
 8004a24:	f64f 74ef 	movw	r4, #65519	; 0xffef
 8004a28:	402c      	ands	r4, r5
 8004a2a:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004a2c:	6984      	ldr	r4, [r0, #24]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8004a2e:	0109      	lsls	r1, r1, #4

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
 8004a30:	f424 4473 	bic.w	r4, r4, #62208	; 0xf300
  uint32_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8004a34:	6a05      	ldr	r5, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICFilter << 12);
 8004a36:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICSelection << 8);
 8004a3a:	ea42 3303 	orr.w	r3, r2, r3, lsl #12

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8004a3e:	f64f 745f 	movw	r4, #65375	; 0xff5f
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8004a42:	f041 0210 	orr.w	r2, r1, #16
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICFilter << 12);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8004a46:	402c      	ands	r4, r5
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8004a48:	b292      	uxth	r2, r2
 8004a4a:	4314      	orrs	r4, r2

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8004a4c:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8004a4e:	6204      	str	r4, [r0, #32]
 8004a50:	bd30      	pop	{r4, r5, pc}

08004a52 <TIM_DeInit>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 6 ,7 ,8, 15, 16 or 17 to select the TIM peripheral.
  * @retval None

  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 8004a52:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 8004a54:	4b36      	ldr	r3, [pc, #216]	; (8004b30 <TIM_DeInit+0xde>)
 8004a56:	4298      	cmp	r0, r3
 8004a58:	d107      	bne.n	8004a6a <TIM_DeInit+0x18>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 8004a5a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8004a5e:	2101      	movs	r1, #1
 8004a60:	f7ff fce2 	bl	8004428 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 8004a64:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8004a68:	e05b      	b.n	8004b22 <TIM_DeInit+0xd0>
  } 
  else if (TIMx == TIM2) 
 8004a6a:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004a6e:	d105      	bne.n	8004a7c <TIM_DeInit+0x2a>
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8004a70:	2001      	movs	r0, #1
 8004a72:	4601      	mov	r1, r0
 8004a74:	f7ff fce4 	bl	8004440 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8004a78:	2001      	movs	r0, #1
 8004a7a:	e007      	b.n	8004a8c <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM3)
 8004a7c:	4b2d      	ldr	r3, [pc, #180]	; (8004b34 <TIM_DeInit+0xe2>)
 8004a7e:	4298      	cmp	r0, r3
 8004a80:	d109      	bne.n	8004a96 <TIM_DeInit+0x44>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 8004a82:	2002      	movs	r0, #2
 8004a84:	2101      	movs	r1, #1
 8004a86:	f7ff fcdb 	bl	8004440 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8004a8a:	2002      	movs	r0, #2
 8004a8c:	2100      	movs	r1, #0
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
    }   
  }
}
 8004a8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
  }  
  else if (TIMx == TIM3)
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8004a92:	f7ff bcd5 	b.w	8004440 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM4)
 8004a96:	4b28      	ldr	r3, [pc, #160]	; (8004b38 <TIM_DeInit+0xe6>)
 8004a98:	4298      	cmp	r0, r3
 8004a9a:	d105      	bne.n	8004aa8 <TIM_DeInit+0x56>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 8004a9c:	2004      	movs	r0, #4
 8004a9e:	2101      	movs	r1, #1
 8004aa0:	f7ff fcce 	bl	8004440 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 8004aa4:	2004      	movs	r0, #4
 8004aa6:	e7f1      	b.n	8004a8c <TIM_DeInit+0x3a>
  }   
  else if (TIMx == TIM6)  
 8004aa8:	4b24      	ldr	r3, [pc, #144]	; (8004b3c <TIM_DeInit+0xea>)
 8004aaa:	4298      	cmp	r0, r3
 8004aac:	d105      	bne.n	8004aba <TIM_DeInit+0x68>
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 8004aae:	2010      	movs	r0, #16
 8004ab0:	2101      	movs	r1, #1
 8004ab2:	f7ff fcc5 	bl	8004440 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 8004ab6:	2010      	movs	r0, #16
 8004ab8:	e7e8      	b.n	8004a8c <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM7)
 8004aba:	4b21      	ldr	r3, [pc, #132]	; (8004b40 <TIM_DeInit+0xee>)
 8004abc:	4298      	cmp	r0, r3
 8004abe:	d105      	bne.n	8004acc <TIM_DeInit+0x7a>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 8004ac0:	2020      	movs	r0, #32
 8004ac2:	2101      	movs	r1, #1
 8004ac4:	f7ff fcbc 	bl	8004440 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 8004ac8:	2020      	movs	r0, #32
 8004aca:	e7df      	b.n	8004a8c <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM8)
 8004acc:	4b1d      	ldr	r3, [pc, #116]	; (8004b44 <TIM_DeInit+0xf2>)
 8004ace:	4298      	cmp	r0, r3
 8004ad0:	d107      	bne.n	8004ae2 <TIM_DeInit+0x90>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 8004ad2:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8004ad6:	2101      	movs	r1, #1
 8004ad8:	f7ff fca6 	bl	8004428 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 8004adc:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8004ae0:	e01f      	b.n	8004b22 <TIM_DeInit+0xd0>
  }    
  else if (TIMx == TIM15)
 8004ae2:	4b19      	ldr	r3, [pc, #100]	; (8004b48 <TIM_DeInit+0xf6>)
 8004ae4:	4298      	cmp	r0, r3
 8004ae6:	d107      	bne.n	8004af8 <TIM_DeInit+0xa6>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
 8004ae8:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8004aec:	2101      	movs	r1, #1
 8004aee:	f7ff fc9b 	bl	8004428 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);  
 8004af2:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8004af6:	e014      	b.n	8004b22 <TIM_DeInit+0xd0>
  }  
  else if (TIMx == TIM16) 
 8004af8:	4b14      	ldr	r3, [pc, #80]	; (8004b4c <TIM_DeInit+0xfa>)
 8004afa:	4298      	cmp	r0, r3
 8004afc:	d107      	bne.n	8004b0e <TIM_DeInit+0xbc>
  {       
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
 8004afe:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004b02:	2101      	movs	r1, #1
 8004b04:	f7ff fc90 	bl	8004428 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);  
 8004b08:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004b0c:	e009      	b.n	8004b22 <TIM_DeInit+0xd0>
  }  
  else
  { 
    if (TIMx == TIM17) 
 8004b0e:	4b10      	ldr	r3, [pc, #64]	; (8004b50 <TIM_DeInit+0xfe>)
 8004b10:	4298      	cmp	r0, r3
 8004b12:	d10b      	bne.n	8004b2c <TIM_DeInit+0xda>
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
 8004b14:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8004b18:	2101      	movs	r1, #1
 8004b1a:	f7ff fc85 	bl	8004428 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
 8004b1e:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8004b22:	2100      	movs	r1, #0
    }   
  }
}
 8004b24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  { 
    if (TIMx == TIM17) 
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
 8004b28:	f7ff bc7e 	b.w	8004428 <RCC_APB2PeriphResetCmd>
 8004b2c:	bd08      	pop	{r3, pc}
 8004b2e:	bf00      	nop
 8004b30:	40012c00 	.word	0x40012c00
 8004b34:	40000400 	.word	0x40000400
 8004b38:	40000800 	.word	0x40000800
 8004b3c:	40001000 	.word	0x40001000
 8004b40:	40001400 	.word	0x40001400
 8004b44:	40013400 	.word	0x40013400
 8004b48:	40014000 	.word	0x40014000
 8004b4c:	40014400 	.word	0x40014400
 8004b50:	40014800 	.word	0x40014800

08004b54 <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 8004b54:	4a20      	ldr	r2, [pc, #128]	; (8004bd8 <TIM_TimeBaseInit+0x84>)
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8004b56:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 8004b58:	4290      	cmp	r0, r2
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8004b5a:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 8004b5c:	d00e      	beq.n	8004b7c <TIM_TimeBaseInit+0x28>
 8004b5e:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8004b62:	4290      	cmp	r0, r2
 8004b64:	d00a      	beq.n	8004b7c <TIM_TimeBaseInit+0x28>
 8004b66:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004b6a:	d007      	beq.n	8004b7c <TIM_TimeBaseInit+0x28>
 8004b6c:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8004b70:	4290      	cmp	r0, r2
 8004b72:	d003      	beq.n	8004b7c <TIM_TimeBaseInit+0x28>
     (TIMx == TIM3)|| (TIMx == TIM4)) 
 8004b74:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004b78:	4290      	cmp	r0, r2
 8004b7a:	d103      	bne.n	8004b84 <TIM_TimeBaseInit+0x30>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8004b7c:	884a      	ldrh	r2, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
     (TIMx == TIM3)|| (TIMx == TIM4)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 8004b7e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8004b82:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8004b84:	4a15      	ldr	r2, [pc, #84]	; (8004bdc <TIM_TimeBaseInit+0x88>)
 8004b86:	4290      	cmp	r0, r2
 8004b88:	d008      	beq.n	8004b9c <TIM_TimeBaseInit+0x48>
 8004b8a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004b8e:	4290      	cmp	r0, r2
 8004b90:	d004      	beq.n	8004b9c <TIM_TimeBaseInit+0x48>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8004b92:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8004b96:	890a      	ldrh	r2, [r1, #8]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8004b98:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8004b9a:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8004b9c:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8004b9e:	684b      	ldr	r3, [r1, #4]
 8004ba0:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8004ba2:	880b      	ldrh	r3, [r1, #0]
 8004ba4:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15) || 
 8004ba6:	4b0c      	ldr	r3, [pc, #48]	; (8004bd8 <TIM_TimeBaseInit+0x84>)
 8004ba8:	4298      	cmp	r0, r3
 8004baa:	d00f      	beq.n	8004bcc <TIM_TimeBaseInit+0x78>
 8004bac:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004bb0:	4298      	cmp	r0, r3
 8004bb2:	d00b      	beq.n	8004bcc <TIM_TimeBaseInit+0x78>
 8004bb4:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 8004bb8:	4298      	cmp	r0, r3
 8004bba:	d007      	beq.n	8004bcc <TIM_TimeBaseInit+0x78>
 8004bbc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004bc0:	4298      	cmp	r0, r3
 8004bc2:	d003      	beq.n	8004bcc <TIM_TimeBaseInit+0x78>
      (TIMx == TIM16) || (TIMx == TIM17))  
 8004bc4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004bc8:	4298      	cmp	r0, r3
 8004bca:	d101      	bne.n	8004bd0 <TIM_TimeBaseInit+0x7c>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8004bcc:	7a8b      	ldrb	r3, [r1, #10]
 8004bce:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 8004bd0:	2301      	movs	r3, #1
 8004bd2:	6143      	str	r3, [r0, #20]
 8004bd4:	4770      	bx	lr
 8004bd6:	bf00      	nop
 8004bd8:	40012c00 	.word	0x40012c00
 8004bdc:	40001000 	.word	0x40001000

08004be0 <TIM_TimeBaseStructInit>:
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 8004be0:	f04f 33ff 	mov.w	r3, #4294967295
 8004be4:	6043      	str	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 8004be6:	2300      	movs	r3, #0
 8004be8:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 8004bea:	8103      	strh	r3, [r0, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 8004bec:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 8004bee:	7283      	strb	r3, [r0, #10]
 8004bf0:	4770      	bx	lr

08004bf2 <TIM_PrescalerConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 8004bf2:	8501      	strh	r1, [r0, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 8004bf4:	6142      	str	r2, [r0, #20]
 8004bf6:	4770      	bx	lr

08004bf8 <TIM_CounterModeConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));

  tmpcr1 = TIMx->CR1;
 8004bf8:	8803      	ldrh	r3, [r0, #0]

  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004bfa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004bfe:	041b      	lsls	r3, r3, #16
 8004c00:	0c1b      	lsrs	r3, r3, #16

  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 8004c02:	4319      	orrs	r1, r3

  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 8004c04:	8001      	strh	r1, [r0, #0]
 8004c06:	4770      	bx	lr

08004c08 <TIM_SetCounter>:
{
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 8004c08:	6241      	str	r1, [r0, #36]	; 0x24
 8004c0a:	4770      	bx	lr

08004c0c <TIM_SetAutoreload>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 8004c0c:	62c1      	str	r1, [r0, #44]	; 0x2c
 8004c0e:	4770      	bx	lr

08004c10 <TIM_GetCounter>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Counter Register value */
  return TIMx->CNT;
 8004c10:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
 8004c12:	4770      	bx	lr

08004c14 <TIM_GetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Prescaler Register value */
  return TIMx->PSC;
 8004c14:	8d00      	ldrh	r0, [r0, #40]	; 0x28
}
 8004c16:	b280      	uxth	r0, r0
 8004c18:	4770      	bx	lr

08004c1a <TIM_UpdateDisableConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 8004c1a:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004c1c:	b119      	cbz	r1, 8004c26 <TIM_UpdateDisableConfig+0xc>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 8004c1e:	b29b      	uxth	r3, r3
 8004c20:	f043 0302 	orr.w	r3, r3, #2
 8004c24:	e003      	b.n	8004c2e <TIM_UpdateDisableConfig+0x14>
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 8004c26:	f023 0302 	bic.w	r3, r3, #2
 8004c2a:	041b      	lsls	r3, r3, #16
 8004c2c:	0c1b      	lsrs	r3, r3, #16
 8004c2e:	8003      	strh	r3, [r0, #0]
 8004c30:	4770      	bx	lr

08004c32 <TIM_UpdateRequestConfig>:
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 8004c32:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 8004c34:	b119      	cbz	r1, 8004c3e <TIM_UpdateRequestConfig+0xc>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 8004c36:	b29b      	uxth	r3, r3
 8004c38:	f043 0304 	orr.w	r3, r3, #4
 8004c3c:	e003      	b.n	8004c46 <TIM_UpdateRequestConfig+0x14>
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 8004c3e:	f023 0304 	bic.w	r3, r3, #4
 8004c42:	041b      	lsls	r3, r3, #16
 8004c44:	0c1b      	lsrs	r3, r3, #16
 8004c46:	8003      	strh	r3, [r0, #0]
 8004c48:	4770      	bx	lr

08004c4a <TIM_UIFRemap>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_UIFREMAP;
 8004c4a:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004c4c:	b119      	cbz	r1, 8004c56 <TIM_UIFRemap+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_UIFREMAP;
 8004c4e:	b29b      	uxth	r3, r3
 8004c50:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8004c54:	e003      	b.n	8004c5e <TIM_UIFRemap+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UIFREMAP;
 8004c56:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8004c5a:	041b      	lsls	r3, r3, #16
 8004c5c:	0c1b      	lsrs	r3, r3, #16
 8004c5e:	8003      	strh	r3, [r0, #0]
 8004c60:	4770      	bx	lr

08004c62 <TIM_ARRPreloadConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8004c62:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004c64:	b119      	cbz	r1, 8004c6e <TIM_ARRPreloadConfig+0xc>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8004c66:	b29b      	uxth	r3, r3
 8004c68:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004c6c:	e003      	b.n	8004c76 <TIM_ARRPreloadConfig+0x14>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 8004c6e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004c72:	041b      	lsls	r3, r3, #16
 8004c74:	0c1b      	lsrs	r3, r3, #16
 8004c76:	8003      	strh	r3, [r0, #0]
 8004c78:	4770      	bx	lr

08004c7a <TIM_SelectOnePulseMode>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));

  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 8004c7a:	8803      	ldrh	r3, [r0, #0]
 8004c7c:	f023 0308 	bic.w	r3, r3, #8
 8004c80:	041b      	lsls	r3, r3, #16
 8004c82:	0c1b      	lsrs	r3, r3, #16
 8004c84:	8003      	strh	r3, [r0, #0]

  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 8004c86:	8803      	ldrh	r3, [r0, #0]
 8004c88:	b29b      	uxth	r3, r3
 8004c8a:	4319      	orrs	r1, r3
 8004c8c:	8001      	strh	r1, [r0, #0]
 8004c8e:	4770      	bx	lr

08004c90 <TIM_SetClockDivision>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));

  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 8004c90:	8803      	ldrh	r3, [r0, #0]
 8004c92:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004c96:	041b      	lsls	r3, r3, #16
 8004c98:	0c1b      	lsrs	r3, r3, #16
 8004c9a:	8003      	strh	r3, [r0, #0]

  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 8004c9c:	8803      	ldrh	r3, [r0, #0]
 8004c9e:	b29b      	uxth	r3, r3
 8004ca0:	4319      	orrs	r1, r3
 8004ca2:	8001      	strh	r1, [r0, #0]
 8004ca4:	4770      	bx	lr

08004ca6 <TIM_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8004ca6:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004ca8:	b119      	cbz	r1, 8004cb2 <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8004caa:	b29b      	uxth	r3, r3
 8004cac:	f043 0301 	orr.w	r3, r3, #1
 8004cb0:	e003      	b.n	8004cba <TIM_Cmd+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 8004cb2:	f023 0301 	bic.w	r3, r3, #1
 8004cb6:	041b      	lsls	r3, r3, #16
 8004cb8:	0c1b      	lsrs	r3, r3, #16
 8004cba:	8003      	strh	r3, [r0, #0]
 8004cbc:	4770      	bx	lr

08004cbe <TIM_OC1Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 8004cbe:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004cc0:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 8004cc2:	f023 0301 	bic.w	r3, r3, #1
 8004cc6:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004cc8:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004cca:	6842      	ldr	r2, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004ccc:	6985      	ldr	r5, [r0, #24]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004cce:	680c      	ldr	r4, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
 8004cd0:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
 8004cd4:	f025 0573 	bic.w	r5, r5, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004cd8:	432c      	orrs	r4, r5
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004cda:	898d      	ldrh	r5, [r1, #12]
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC1P;
 8004cdc:	f023 0302 	bic.w	r3, r3, #2
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004ce0:	432b      	orrs	r3, r5
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8004ce2:	888d      	ldrh	r5, [r1, #4]
 8004ce4:	432b      	orrs	r3, r5
    
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
 8004ce6:	4d13      	ldr	r5, [pc, #76]	; (8004d34 <TIM_OC1Init+0x76>)
 8004ce8:	42a8      	cmp	r0, r5
 8004cea:	d00f      	beq.n	8004d0c <TIM_OC1Init+0x4e>
 8004cec:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004cf0:	42a8      	cmp	r0, r5
 8004cf2:	d00b      	beq.n	8004d0c <TIM_OC1Init+0x4e>
 8004cf4:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8004cf8:	42a8      	cmp	r0, r5
 8004cfa:	d007      	beq.n	8004d0c <TIM_OC1Init+0x4e>
 8004cfc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004d00:	42a8      	cmp	r0, r5
 8004d02:	d003      	beq.n	8004d0c <TIM_OC1Init+0x4e>
 8004d04:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004d08:	42a8      	cmp	r0, r5
 8004d0a:	d10d      	bne.n	8004d28 <TIM_OC1Init+0x6a>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004d0c:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
 8004d0e:	f023 0308 	bic.w	r3, r3, #8
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004d12:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004d14:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
 8004d16:	f023 0304 	bic.w	r3, r3, #4
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004d1a:	432b      	orrs	r3, r5
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004d1c:	8a0d      	ldrh	r5, [r1, #16]
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1N;
 8004d1e:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004d22:	432a      	orrs	r2, r5
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 8004d24:	8a4d      	ldrh	r5, [r1, #18]
 8004d26:	432a      	orrs	r2, r5
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004d28:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8004d2a:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004d2c:	6184      	str	r4, [r0, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8004d2e:	6342      	str	r2, [r0, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004d30:	6203      	str	r3, [r0, #32]
 8004d32:	bd30      	pop	{r4, r5, pc}
 8004d34:	40012c00 	.word	0x40012c00

08004d38 <TIM_OC2Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
 8004d38:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004d3a:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
 8004d3c:	f023 0310 	bic.w	r3, r3, #16
 8004d40:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 8004d42:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004d44:	6842      	ldr	r2, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004d46:	6983      	ldr	r3, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC2S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004d48:	680c      	ldr	r4, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC2S;
 8004d4a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004d4e:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004d52:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004d56:	898e      	ldrh	r6, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 4);
 8004d58:	888b      	ldrh	r3, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC2P;
 8004d5a:	f025 0520 	bic.w	r5, r5, #32
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004d5e:	4333      	orrs	r3, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 4);
 8004d60:	ea45 1303 	orr.w	r3, r5, r3, lsl #4
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004d64:	4d0e      	ldr	r5, [pc, #56]	; (8004da0 <TIM_OC2Init+0x68>)
 8004d66:	42a8      	cmp	r0, r5
 8004d68:	d003      	beq.n	8004d72 <TIM_OC2Init+0x3a>
 8004d6a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004d6e:	42a8      	cmp	r0, r5
 8004d70:	d110      	bne.n	8004d94 <TIM_OC2Init+0x5c>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8004d72:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
 8004d74:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8004d78:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NE;
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
 8004d7c:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NE;
 8004d7e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
 8004d82:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 2);
 8004d86:	8a0e      	ldrh	r6, [r1, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8004d88:	8a4d      	ldrh	r5, [r1, #18]
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2N;
 8004d8a:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 2);
 8004d8e:	4335      	orrs	r5, r6
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8004d90:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004d94:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8004d96:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004d98:	6184      	str	r4, [r0, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8004d9a:	6382      	str	r2, [r0, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004d9c:	6203      	str	r3, [r0, #32]
 8004d9e:	bd70      	pop	{r4, r5, r6, pc}
 8004da0:	40012c00 	.word	0x40012c00

08004da4 <TIM_OC3Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
 8004da4:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004da6:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
 8004da8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004dac:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004dae:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004db0:	6842      	ldr	r2, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004db2:	69c3      	ldr	r3, [r0, #28]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004db4:	680c      	ldr	r4, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
 8004db6:	f023 0373 	bic.w	r3, r3, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004dba:	431c      	orrs	r4, r3
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 8);
 8004dbc:	898e      	ldrh	r6, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 8);
 8004dbe:	888b      	ldrh	r3, [r1, #4]
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
 8004dc0:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 8);
 8004dc4:	4333      	orrs	r3, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 8);
 8004dc6:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004dca:	4d0f      	ldr	r5, [pc, #60]	; (8004e08 <TIM_OC3Init+0x64>)
 8004dcc:	42a8      	cmp	r0, r5
 8004dce:	d003      	beq.n	8004dd8 <TIM_OC3Init+0x34>
 8004dd0:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004dd4:	42a8      	cmp	r0, r5
 8004dd6:	d110      	bne.n	8004dfa <TIM_OC3Init+0x56>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8004dd8:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
 8004dda:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8004dde:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NE;
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
 8004de2:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NE;
 8004de4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
 8004de8:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 4);
 8004dec:	8a0e      	ldrh	r6, [r1, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8004dee:	8a4d      	ldrh	r5, [r1, #18]
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3N;
 8004df0:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 4);
 8004df4:	4335      	orrs	r5, r6
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8004df6:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004dfa:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8004dfc:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8004dfe:	61c4      	str	r4, [r0, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8004e00:	63c2      	str	r2, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004e02:	6203      	str	r3, [r0, #32]
 8004e04:	bd70      	pop	{r4, r5, r6, pc}
 8004e06:	bf00      	nop
 8004e08:	40012c00 	.word	0x40012c00

08004e0c <TIM_OC4Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
 8004e0c:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004e0e:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
 8004e10:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8004e14:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004e16:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004e18:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004e1a:	69c4      	ldr	r4, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004e1c:	680a      	ldr	r2, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC4S;
 8004e1e:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004e22:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 12);
 8004e26:	898e      	ldrh	r6, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 12);
 8004e28:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
 8004e2a:	f425 5500 	bic.w	r5, r5, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 12);
 8004e2e:	4334      	orrs	r4, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 12);
 8004e30:	ea45 3404 	orr.w	r4, r5, r4, lsl #12
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004e34:	4d08      	ldr	r5, [pc, #32]	; (8004e58 <TIM_OC4Init+0x4c>)
 8004e36:	42a8      	cmp	r0, r5
 8004e38:	d003      	beq.n	8004e42 <TIM_OC4Init+0x36>
 8004e3a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004e3e:	42a8      	cmp	r0, r5
 8004e40:	d104      	bne.n	8004e4c <TIM_OC4Init+0x40>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 6);
 8004e42:	8a0d      	ldrh	r5, [r1, #16]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS4;
 8004e44:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 6);
 8004e48:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004e4c:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8004e4e:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 8004e50:	61c2      	str	r2, [r0, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8004e52:	6403      	str	r3, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004e54:	6204      	str	r4, [r0, #32]
 8004e56:	bd70      	pop	{r4, r5, r6, pc}
 8004e58:	40012c00 	.word	0x40012c00

08004e5c <TIM_OC5Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC5E; /* to be verified*/
 8004e5c:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC5Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004e5e:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC5E; /* to be verified*/
 8004e60:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004e64:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004e66:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004e68:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
 8004e6a:	6d44      	ldr	r4, [r0, #84]	; 0x54
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC5M;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
 8004e6c:	680a      	ldr	r2, [r1, #0]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC5M;
 8004e6e:	f024 0470 	bic.w	r4, r4, #112	; 0x70
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
 8004e72:	4322      	orrs	r2, r4
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 16);
 8004e74:	898e      	ldrh	r6, [r1, #12]

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 16);
 8004e76:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
 8004e78:	f425 3500 	bic.w	r5, r5, #131072	; 0x20000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 16);
 8004e7c:	4334      	orrs	r4, r6

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 16);
 8004e7e:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004e82:	4d09      	ldr	r5, [pc, #36]	; (8004ea8 <TIM_OC5Init+0x4c>)
 8004e84:	42a8      	cmp	r0, r5
 8004e86:	d003      	beq.n	8004e90 <TIM_OC5Init+0x34>
 8004e88:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004e8c:	42a8      	cmp	r0, r5
 8004e8e:	d104      	bne.n	8004e9a <TIM_OC5Init+0x3e>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 16);
 8004e90:	8a0d      	ldrh	r5, [r1, #16]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS5;
 8004e92:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 16);
 8004e96:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004e9a:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = TIM_OCInitStruct->TIM_Pulse;
 8004e9c:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
 8004e9e:	6542      	str	r2, [r0, #84]	; 0x54
    
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = TIM_OCInitStruct->TIM_Pulse;
 8004ea0:	6583      	str	r3, [r0, #88]	; 0x58
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004ea2:	6204      	str	r4, [r0, #32]
 8004ea4:	bd70      	pop	{r4, r5, r6, pc}
 8004ea6:	bf00      	nop
 8004ea8:	40012c00 	.word	0x40012c00

08004eac <TIM_OC6Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC6E; /* to be verified*/
 8004eac:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC6Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004eae:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC6E; /* to be verified*/
 8004eb0:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8004eb4:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004eb6:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004eb8:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
 8004eba:	6d44      	ldr	r4, [r0, #84]	; 0x54
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC6M;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004ebc:	680a      	ldr	r2, [r1, #0]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC6M;
 8004ebe:	f424 44e0 	bic.w	r4, r4, #28672	; 0x7000
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004ec2:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 20);
 8004ec6:	898e      	ldrh	r6, [r1, #12]

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 20);
 8004ec8:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8004eca:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 20);
 8004ece:	4334      	orrs	r4, r6

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 20);
 8004ed0:	ea45 5404 	orr.w	r4, r5, r4, lsl #20
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004ed4:	4d07      	ldr	r5, [pc, #28]	; (8004ef4 <TIM_OC6Init+0x48>)
 8004ed6:	42a8      	cmp	r0, r5
 8004ed8:	d003      	beq.n	8004ee2 <TIM_OC6Init+0x36>
 8004eda:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004ede:	42a8      	cmp	r0, r5
 8004ee0:	d101      	bne.n	8004ee6 <TIM_OC6Init+0x3a>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS6;
 8004ee2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 18);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004ee6:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = TIM_OCInitStruct->TIM_Pulse;
 8004ee8:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
 8004eea:	6542      	str	r2, [r0, #84]	; 0x54
    
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = TIM_OCInitStruct->TIM_Pulse;
 8004eec:	65c3      	str	r3, [r0, #92]	; 0x5c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004eee:	6204      	str	r4, [r0, #32]
 8004ef0:	bd70      	pop	{r4, r5, r6, pc}
 8004ef2:	bf00      	nop
 8004ef4:	40012c00 	.word	0x40012c00

08004ef8 <TIM_SelectGC5C1>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C1 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C1;
 8004ef8:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004efa:	b111      	cbz	r1, 8004f02 <TIM_SelectGC5C1+0xa>
  {
    /* Set the GC5C1 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C1;
 8004efc:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8004f00:	e001      	b.n	8004f06 <TIM_SelectGC5C1+0xe>
  }
  else
  {
    /* Reset the GC5C1 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C1;
 8004f02:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8004f06:	6583      	str	r3, [r0, #88]	; 0x58
 8004f08:	4770      	bx	lr

08004f0a <TIM_SelectGC5C2>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C2 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C2;
 8004f0a:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004f0c:	b111      	cbz	r1, 8004f14 <TIM_SelectGC5C2+0xa>
  {
    /* Set the GC5C2 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C2;
 8004f0e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004f12:	e001      	b.n	8004f18 <TIM_SelectGC5C2+0xe>
  }
  else
  {
    /* Reset the GC5C2 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C2;
 8004f14:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8004f18:	6583      	str	r3, [r0, #88]	; 0x58
 8004f1a:	4770      	bx	lr

08004f1c <TIM_SelectGC5C3>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C3 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C3;
 8004f1c:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004f1e:	b111      	cbz	r1, 8004f26 <TIM_SelectGC5C3+0xa>
  {
    /* Set the GC5C3 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C3;
 8004f20:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8004f24:	e001      	b.n	8004f2a <TIM_SelectGC5C3+0xe>
  }
  else
  {
    /* Reset the GC5C3 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C3;
 8004f26:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8004f2a:	6583      	str	r3, [r0, #88]	; 0x58
 8004f2c:	4770      	bx	lr

08004f2e <TIM_OCStructInit>:
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 8004f2e:	2300      	movs	r3, #0
 8004f30:	6003      	str	r3, [r0, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 8004f32:	8083      	strh	r3, [r0, #4]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 8004f34:	80c3      	strh	r3, [r0, #6]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 8004f36:	6083      	str	r3, [r0, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 8004f38:	8183      	strh	r3, [r0, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 8004f3a:	81c3      	strh	r3, [r0, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 8004f3c:	8203      	strh	r3, [r0, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 8004f3e:	8243      	strh	r3, [r0, #18]
 8004f40:	4770      	bx	lr

08004f42 <TIM_SelectOCxM>:
  *            @arg TIM_OCMode_Asymmetric_PWM1
  *            @arg TIM_OCMode_Asymmetric_PWM2            
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint32_t TIM_OCMode) /* to be updated*/
{
 8004f42:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 8004f44:	2401      	movs	r4, #1
 8004f46:	fa04 f401 	lsl.w	r4, r4, r1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004f4a:	6a05      	ldr	r5, [r0, #32]
 8004f4c:	43e4      	mvns	r4, r4
 8004f4e:	b2a4      	uxth	r4, r4
 8004f50:	402c      	ands	r4, r5
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;
 8004f52:	f100 0318 	add.w	r3, r0, #24

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004f56:	6204      	str	r4, [r0, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 8004f58:	b109      	cbz	r1, 8004f5e <TIM_SelectOCxM+0x1c>
 8004f5a:	2908      	cmp	r1, #8
 8004f5c:	d108      	bne.n	8004f70 <TIM_SelectOCxM+0x2e>
  {
    tmp += (TIM_Channel>>1);
 8004f5e:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 8004f60:	58c8      	ldr	r0, [r1, r3]
 8004f62:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
 8004f66:	f020 0070 	bic.w	r0, r0, #112	; 0x70
 8004f6a:	50c8      	str	r0, [r1, r3]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 8004f6c:	58c8      	ldr	r0, [r1, r3]
 8004f6e:	e00a      	b.n	8004f86 <TIM_SelectOCxM+0x44>
  }
  else
  {
    tmp += (uint32_t)(TIM_Channel - (uint32_t)4)>> (uint32_t)1;
 8004f70:	3904      	subs	r1, #4
 8004f72:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8004f74:	58c8      	ldr	r0, [r1, r3]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8004f76:	0212      	lsls	r2, r2, #8
  else
  {
    tmp += (uint32_t)(TIM_Channel - (uint32_t)4)>> (uint32_t)1;

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8004f78:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
 8004f7c:	f420 40e0 	bic.w	r0, r0, #28672	; 0x7000
 8004f80:	50c8      	str	r0, [r1, r3]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8004f82:	58c8      	ldr	r0, [r1, r3]
 8004f84:	b292      	uxth	r2, r2
 8004f86:	4302      	orrs	r2, r0
 8004f88:	50ca      	str	r2, [r1, r3]
 8004f8a:	bd30      	pop	{r4, r5, pc}

08004f8c <TIM_SetCompare1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8004f8c:	6341      	str	r1, [r0, #52]	; 0x34
 8004f8e:	4770      	bx	lr

08004f90 <TIM_SetCompare2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 8004f90:	6381      	str	r1, [r0, #56]	; 0x38
 8004f92:	4770      	bx	lr

08004f94 <TIM_SetCompare3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 8004f94:	63c1      	str	r1, [r0, #60]	; 0x3c
 8004f96:	4770      	bx	lr

08004f98 <TIM_SetCompare4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 8004f98:	6401      	str	r1, [r0, #64]	; 0x40
 8004f9a:	4770      	bx	lr

08004f9c <TIM_SetCompare5>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));

  /* Set the Capture Compare5 Register value */
  TIMx->CCR5 = Compare5;
 8004f9c:	6581      	str	r1, [r0, #88]	; 0x58
 8004f9e:	4770      	bx	lr

08004fa0 <TIM_SetCompare6>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));

  /* Set the Capture Compare6 Register value */
  TIMx->CCR6 = Compare6;
 8004fa0:	65c1      	str	r1, [r0, #92]	; 0x5c
 8004fa2:	4770      	bx	lr

08004fa4 <TIM_ForcedOC1Config>:
  uint32_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8004fa4:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1M;
 8004fa6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004faa:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 8004fae:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004fb0:	6181      	str	r1, [r0, #24]
 8004fb2:	4770      	bx	lr

08004fb4 <TIM_ForcedOC2Config>:
  uint32_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8004fb4:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC2M;
 8004fb6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004fba:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr1 |= ((uint32_t)TIM_ForcedAction << 8);
 8004fbe:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004fc2:	6181      	str	r1, [r0, #24]
 8004fc4:	4770      	bx	lr

08004fc6 <TIM_ForcedOC3Config>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));

  tmpccmr2 = TIMx->CCMR2;
 8004fc6:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3M;
 8004fc8:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 8004fcc:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004fce:	61c1      	str	r1, [r0, #28]
 8004fd0:	4770      	bx	lr

08004fd2 <TIM_ForcedOC4Config>:
  uint32_t tmpccmr2 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 8004fd2:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC4M;
 8004fd4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr2 |= ((uint32_t)TIM_ForcedAction << 8);
 8004fd8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004fdc:	61c1      	str	r1, [r0, #28]
 8004fde:	4770      	bx	lr

08004fe0 <TIM_ForcedOC5Config>:
  uint32_t tmpccmr3 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr3 = TIMx->CCMR3;
 8004fe0:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5M Bits */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC5M;
 8004fe2:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr3 |= (uint32_t)(TIM_ForcedAction);
 8004fe6:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004fe8:	6541      	str	r1, [r0, #84]	; 0x54
 8004fea:	4770      	bx	lr

08004fec <TIM_ForcedOC6Config>:
  uint32_t tmpccmr3 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr3 = TIMx->CCMR3;
 8004fec:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC6M Bits */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC6M;
 8004fee:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr3 |= ((uint32_t)TIM_ForcedAction << 8);
 8004ff2:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004ff6:	6541      	str	r1, [r0, #84]	; 0x54
 8004ff8:	4770      	bx	lr

08004ffa <TIM_OC1PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8004ffa:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC1PE);
 8004ffc:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 8005000:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8005002:	6181      	str	r1, [r0, #24]
 8005004:	4770      	bx	lr

08005006 <TIM_OC2PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8005006:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC2PE);
 8005008:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= ((uint32_t)TIM_OCPreload << 8);
 800500c:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8005010:	6181      	str	r1, [r0, #24]
 8005012:	4770      	bx	lr

08005014 <TIM_OC3PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8005014:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC3PE);
 8005016:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 800501a:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800501c:	61c1      	str	r1, [r0, #28]
 800501e:	4770      	bx	lr

08005020 <TIM_OC4PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8005020:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC4PE);
 8005022:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= ((uint32_t)TIM_OCPreload << 8);
 8005026:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800502a:	61c1      	str	r1, [r0, #28]
 800502c:	4770      	bx	lr

0800502e <TIM_OC5PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr3 = TIMx->CCMR3;
 800502e:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5PE Bit */
  tmpccmr3 &= (uint32_t)(~TIM_CCMR3_OC5PE);
 8005030:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr3 |= (uint32_t)(TIM_OCPreload);
 8005034:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8005036:	6541      	str	r1, [r0, #84]	; 0x54
 8005038:	4770      	bx	lr

0800503a <TIM_OC6PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr3 = TIMx->CCMR3;
 800503a:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5PE Bit */
  tmpccmr3 &= (uint32_t)(~TIM_CCMR3_OC6PE);
 800503c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr3 |= ((uint32_t)TIM_OCPreload << 8);
 8005040:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8005044:	6541      	str	r1, [r0, #84]	; 0x54
 8005046:	4770      	bx	lr

08005048 <TIM_OC1FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8005048:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1FE;
 800504a:	f023 0304 	bic.w	r3, r3, #4

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 800504e:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8005050:	6181      	str	r1, [r0, #24]
 8005052:	4770      	bx	lr

08005054 <TIM_OC2FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8005054:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC2FE);
 8005056:	f423 6380 	bic.w	r3, r3, #1024	; 0x400

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= ((uint32_t)TIM_OCFast << 8);
 800505a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800505e:	6181      	str	r1, [r0, #24]
 8005060:	4770      	bx	lr

08005062 <TIM_OC3FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8005062:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3FE;
 8005064:	f023 0304 	bic.w	r3, r3, #4

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 8005068:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 800506a:	61c1      	str	r1, [r0, #28]
 800506c:	4770      	bx	lr

0800506e <TIM_OC4FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800506e:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC4FE);
 8005070:	f423 6380 	bic.w	r3, r3, #1024	; 0x400

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= ((uint32_t)TIM_OCFast << 8);
 8005074:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8005078:	61c1      	str	r1, [r0, #28]
 800507a:	4770      	bx	lr

0800507c <TIM_ClearOC1Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 800507c:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1CE;
 800507e:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 8005082:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8005084:	6181      	str	r1, [r0, #24]
 8005086:	4770      	bx	lr

08005088 <TIM_ClearOC2Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8005088:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC2CE;
 800508a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= ((uint32_t)TIM_OCClear << 8);
 800508e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8005092:	6181      	str	r1, [r0, #24]
 8005094:	4770      	bx	lr

08005096 <TIM_ClearOC3Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8005096:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3CE;
 8005098:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 800509c:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800509e:	61c1      	str	r1, [r0, #28]
 80050a0:	4770      	bx	lr

080050a2 <TIM_ClearOC4Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 80050a2:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC4CE;
 80050a4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= ((uint32_t)TIM_OCClear << 8);
 80050a8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80050ac:	61c1      	str	r1, [r0, #28]
 80050ae:	4770      	bx	lr

080050b0 <TIM_ClearOC5Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr3 = TIMx->CCMR3;
 80050b0:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5CE Bit */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC5CE;
 80050b2:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr3 |= (uint32_t)(TIM_OCClear);
 80050b6:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 80050b8:	6541      	str	r1, [r0, #84]	; 0x54
 80050ba:	4770      	bx	lr

080050bc <TIM_ClearOC6Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr3 = TIMx->CCMR3;
 80050bc:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5CE Bit */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC6CE;
 80050be:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr3 |= ((uint32_t)TIM_OCClear << 8);
 80050c2:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 80050c6:	6541      	str	r1, [r0, #84]	; 0x54
 80050c8:	4770      	bx	lr

080050ca <TIM_SelectOCREFClear>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));

  /* Set the TIM_OCReferenceClear source */
  TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
 80050ca:	6882      	ldr	r2, [r0, #8]
 80050cc:	f64f 73f7 	movw	r3, #65527	; 0xfff7
 80050d0:	4013      	ands	r3, r2
 80050d2:	6083      	str	r3, [r0, #8]
  TIMx->SMCR |=  TIM_OCReferenceClear;
 80050d4:	6883      	ldr	r3, [r0, #8]
 80050d6:	4319      	orrs	r1, r3
 80050d8:	6081      	str	r1, [r0, #8]
 80050da:	4770      	bx	lr

080050dc <TIM_OC1PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 80050dc:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint32_t)(~TIM_CCER_CC1P);
 80050de:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= TIM_OCPolarity;
 80050e2:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80050e4:	6201      	str	r1, [r0, #32]
 80050e6:	4770      	bx	lr

080050e8 <TIM_OC1NPolarityConfig>:
  uint32_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 80050e8:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
 80050ea:	f023 0308 	bic.w	r3, r3, #8
  tmpccer |= TIM_OCNPolarity;
 80050ee:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80050f0:	6201      	str	r1, [r0, #32]
 80050f2:	4770      	bx	lr

080050f4 <TIM_OC2PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 80050f4:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint32_t)(~TIM_CCER_CC2P);
 80050f6:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= ((uint32_t)TIM_OCPolarity << 4);
 80050fa:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80050fe:	6201      	str	r1, [r0, #32]
 8005100:	4770      	bx	lr

08005102 <TIM_OC2NPolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 8005102:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
 8005104:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpccer |= ((uint32_t)TIM_OCNPolarity << 4);
 8005108:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800510c:	6201      	str	r1, [r0, #32]
 800510e:	4770      	bx	lr

08005110 <TIM_OC3PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8005110:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
 8005112:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= ((uint32_t)TIM_OCPolarity << 8);
 8005116:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800511a:	6201      	str	r1, [r0, #32]
 800511c:	4770      	bx	lr

0800511e <TIM_OC3NPolarityConfig>:
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 800511e:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
 8005120:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  tmpccer |= ((uint32_t)TIM_OCNPolarity << 8);
 8005124:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8005128:	6201      	str	r1, [r0, #32]
 800512a:	4770      	bx	lr

0800512c <TIM_OC4PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800512c:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
 800512e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 12);
 8005132:	ea43 3101 	orr.w	r1, r3, r1, lsl #12

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8005136:	6201      	str	r1, [r0, #32]
 8005138:	4770      	bx	lr

0800513a <TIM_OC5PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800513a:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC5P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
 800513c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 16);
 8005140:	ea43 4101 	orr.w	r1, r3, r1, lsl #16

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8005144:	6201      	str	r1, [r0, #32]
 8005146:	4770      	bx	lr

08005148 <TIM_OC6PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8005148:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC6P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800514a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 20);
 800514e:	ea43 5101 	orr.w	r1, r3, r1, lsl #20

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8005152:	6201      	str	r1, [r0, #32]
 8005154:	4770      	bx	lr

08005156 <TIM_CCxCmd>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = (uint32_t)CCER_CCE_SET << (uint32_t)TIM_Channel;
 8005156:	2301      	movs	r3, #1
 8005158:	fa03 f301 	lsl.w	r3, r3, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint32_t)(~tmp);

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCx << (uint32_t)TIM_Channel);
 800515c:	fa02 f201 	lsl.w	r2, r2, r1
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 8005160:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = (uint32_t)CCER_CCE_SET << (uint32_t)TIM_Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint32_t)(~tmp);
 8005162:	6a04      	ldr	r4, [r0, #32]
 8005164:	ea24 0303 	bic.w	r3, r4, r3
 8005168:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCx << (uint32_t)TIM_Channel);
 800516a:	6a03      	ldr	r3, [r0, #32]
 800516c:	4313      	orrs	r3, r2
 800516e:	6203      	str	r3, [r0, #32]
 8005170:	bd10      	pop	{r4, pc}

08005172 <TIM_CCxNCmd>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = (uint32_t)CCER_CCNE_SET << (uint32_t)TIM_Channel;
 8005172:	2304      	movs	r3, #4
 8005174:	fa03 f301 	lsl.w	r3, r3, r1

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint32_t) ~tmp;

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCxN << (uint32_t)TIM_Channel);
 8005178:	fa02 f201 	lsl.w	r2, r2, r1
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 800517c:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = (uint32_t)CCER_CCNE_SET << (uint32_t)TIM_Channel;

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint32_t) ~tmp;
 800517e:	6a04      	ldr	r4, [r0, #32]
 8005180:	ea24 0303 	bic.w	r3, r4, r3
 8005184:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCxN << (uint32_t)TIM_Channel);
 8005186:	6a03      	ldr	r3, [r0, #32]
 8005188:	4313      	orrs	r3, r2
 800518a:	6203      	str	r3, [r0, #32]
 800518c:	bd10      	pop	{r4, pc}

0800518e <TIM_ICStructInit>:
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 800518e:	2300      	movs	r3, #0
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8005190:	2201      	movs	r2, #1
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8005192:	8003      	strh	r3, [r0, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 8005194:	8043      	strh	r3, [r0, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8005196:	8082      	strh	r2, [r0, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 8005198:	80c3      	strh	r3, [r0, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 800519a:	8103      	strh	r3, [r0, #8]
 800519c:	4770      	bx	lr

0800519e <TIM_GetCapture1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 800519e:	6b40      	ldr	r0, [r0, #52]	; 0x34
}
 80051a0:	4770      	bx	lr

080051a2 <TIM_GetCapture2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 80051a2:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 80051a4:	4770      	bx	lr

080051a6 <TIM_GetCapture3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 

  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 80051a6:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 80051a8:	4770      	bx	lr

080051aa <TIM_GetCapture4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 80051aa:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 80051ac:	4770      	bx	lr

080051ae <TIM_SetIC1Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint32_t)~TIM_CCMR1_IC1PSC;
 80051ae:	6983      	ldr	r3, [r0, #24]
 80051b0:	f023 030c 	bic.w	r3, r3, #12
 80051b4:	6183      	str	r3, [r0, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 80051b6:	6983      	ldr	r3, [r0, #24]
 80051b8:	4319      	orrs	r1, r3
 80051ba:	6181      	str	r1, [r0, #24]
 80051bc:	4770      	bx	lr

080051be <TIM_SetIC2Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint32_t)~TIM_CCMR1_IC2PSC;
 80051be:	6983      	ldr	r3, [r0, #24]
 80051c0:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80051c4:	6183      	str	r3, [r0, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint32_t)((uint32_t)TIM_ICPSC << 8);
 80051c6:	6983      	ldr	r3, [r0, #24]
 80051c8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80051cc:	6181      	str	r1, [r0, #24]
 80051ce:	4770      	bx	lr

080051d0 <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 80051d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80051d2:	460c      	mov	r4, r1
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 80051d4:	88a2      	ldrh	r2, [r4, #4]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 80051d6:	8849      	ldrh	r1, [r1, #2]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 80051d8:	f8b4 e000 	ldrh.w	lr, [r4]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 80051dc:	4605      	mov	r5, r0
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 80051de:	2900      	cmp	r1, #0
 80051e0:	bf0c      	ite	eq
 80051e2:	2702      	moveq	r7, #2
 80051e4:	2700      	movne	r7, #0
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 80051e6:	2a01      	cmp	r2, #1
 80051e8:	bf14      	ite	ne
 80051ea:	2601      	movne	r6, #1
 80051ec:	2602      	moveq	r6, #2
 80051ee:	8923      	ldrh	r3, [r4, #8]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 80051f0:	f1be 0f00 	cmp.w	lr, #0
 80051f4:	d111      	bne.n	800521a <TIM_PWMIConfig+0x4a>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 80051f6:	f7ff fbff 	bl	80049f8 <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80051fa:	4628      	mov	r0, r5
 80051fc:	88e1      	ldrh	r1, [r4, #6]
 80051fe:	f7ff ffd6 	bl	80051ae <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8005202:	4628      	mov	r0, r5
 8005204:	4639      	mov	r1, r7
 8005206:	4632      	mov	r2, r6
 8005208:	8923      	ldrh	r3, [r4, #8]
 800520a:	f7ff fc09 	bl	8004a20 <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800520e:	88e1      	ldrh	r1, [r4, #6]
 8005210:	4628      	mov	r0, r5
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005212:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005216:	f7ff bfd2 	b.w	80051be <TIM_SetIC2Prescaler>
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800521a:	f7ff fc01 	bl	8004a20 <TI2_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800521e:	4628      	mov	r0, r5
 8005220:	88e1      	ldrh	r1, [r4, #6]
 8005222:	f7ff ffcc 	bl	80051be <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8005226:	4628      	mov	r0, r5
 8005228:	4639      	mov	r1, r7
 800522a:	4632      	mov	r2, r6
 800522c:	8923      	ldrh	r3, [r4, #8]
 800522e:	f7ff fbe3 	bl	80049f8 <TI1_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005232:	88e1      	ldrh	r1, [r4, #6]
 8005234:	4628      	mov	r0, r5
  }
}
 8005236:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800523a:	f7ff bfb8 	b.w	80051ae <TIM_SetIC1Prescaler>

0800523e <TIM_SetIC3Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 800523e:	69c2      	ldr	r2, [r0, #28]
 8005240:	f64f 73f3 	movw	r3, #65523	; 0xfff3
 8005244:	4013      	ands	r3, r2
 8005246:	61c3      	str	r3, [r0, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 8005248:	69c3      	ldr	r3, [r0, #28]
 800524a:	4319      	orrs	r1, r3
 800524c:	61c1      	str	r1, [r0, #28]
 800524e:	4770      	bx	lr

08005250 <TIM_SetIC4Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 8005250:	69c2      	ldr	r2, [r0, #28]
 8005252:	f24f 33ff 	movw	r3, #62463	; 0xf3ff
 8005256:	4013      	ands	r3, r2
 8005258:	61c3      	str	r3, [r0, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 800525a:	69c3      	ldr	r3, [r0, #28]
 800525c:	0209      	lsls	r1, r1, #8
 800525e:	b289      	uxth	r1, r1
 8005260:	430b      	orrs	r3, r1
 8005262:	61c3      	str	r3, [r0, #28]
 8005264:	4770      	bx	lr

08005266 <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8005266:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8005268:	880b      	ldrh	r3, [r1, #0]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800526a:	460d      	mov	r5, r1
 800526c:	4604      	mov	r4, r0
 800526e:	8849      	ldrh	r1, [r1, #2]
 8005270:	88aa      	ldrh	r2, [r5, #4]
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8005272:	b943      	cbnz	r3, 8005286 <TIM_ICInit+0x20>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8005274:	892b      	ldrh	r3, [r5, #8]
 8005276:	f7ff fbbf 	bl	80049f8 <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800527a:	88e9      	ldrh	r1, [r5, #6]
 800527c:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 800527e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005282:	f7ff bf94 	b.w	80051ae <TIM_SetIC1Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 8005286:	2b04      	cmp	r3, #4
 8005288:	d108      	bne.n	800529c <TIM_ICInit+0x36>
  {
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800528a:	892b      	ldrh	r3, [r5, #8]
 800528c:	f7ff fbc8 	bl	8004a20 <TI2_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005290:	88e9      	ldrh	r1, [r5, #6]
 8005292:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005294:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005298:	f7ff bf91 	b.w	80051be <TIM_SetIC2Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 800529c:	2b08      	cmp	r3, #8
 800529e:	f8b5 c008 	ldrh.w	ip, [r5, #8]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 80052a2:	6a06      	ldr	r6, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 80052a4:	d11b      	bne.n	80052de <TIM_ICInit+0x78>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 80052a6:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 80052aa:	4033      	ands	r3, r6
 80052ac:	6203      	str	r3, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 80052ae:	69c3      	ldr	r3, [r0, #28]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 80052b0:	f64f 770c 	movw	r7, #65292	; 0xff0c
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
 80052b4:	6a06      	ldr	r6, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 80052b6:	401f      	ands	r7, r3
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 80052b8:	f24f 53ff 	movw	r3, #62975	; 0xf5ff
 80052bc:	4033      	ands	r3, r6
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 80052be:	ea42 120c 	orr.w	r2, r2, ip, lsl #4

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 80052c2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 80052c6:	4317      	orrs	r7, r2

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 80052c8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80052cc:	88e9      	ldrh	r1, [r5, #6]
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80052ce:	b2bf      	uxth	r7, r7
  TIMx->CCER = tmpccer;
 80052d0:	b29b      	uxth	r3, r3
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80052d2:	61c7      	str	r7, [r0, #28]
  TIMx->CCER = tmpccer;
 80052d4:	6203      	str	r3, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 80052d6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80052da:	f7ff bfb0 	b.w	800523e <TIM_SetIC3Prescaler>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 80052de:	f64e 73ff 	movw	r3, #61439	; 0xefff
 80052e2:	4033      	ands	r3, r6
 80052e4:	6203      	str	r3, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 80052e6:	69c3      	ldr	r3, [r0, #28]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 80052e8:	f640 46ff 	movw	r6, #3327	; 0xcff
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
 80052ec:	6a07      	ldr	r7, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 80052ee:	401e      	ands	r6, r3
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 80052f0:	f645 73ff 	movw	r3, #24575	; 0x5fff
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 80052f4:	0212      	lsls	r2, r2, #8
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 80052f6:	403b      	ands	r3, r7
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 80052f8:	ea42 3c0c 	orr.w	ip, r2, ip, lsl #12
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 80052fc:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8005300:	fa1f fc8c 	uxth.w	ip, ip
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8005304:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005308:	88e9      	ldrh	r1, [r5, #6]
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800530a:	ea4c 0606 	orr.w	r6, ip, r6
  TIMx->CCER = tmpccer ;
 800530e:	b29b      	uxth	r3, r3
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8005310:	61c6      	str	r6, [r0, #28]
  TIMx->CCER = tmpccer ;
 8005312:	6203      	str	r3, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005314:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005318:	f7ff bf9a 	b.w	8005250 <TIM_SetIC4Prescaler>

0800531c <TIM_BDTRConfig>:

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 800531c:	884a      	ldrh	r2, [r1, #2]
 800531e:	880b      	ldrh	r3, [r1, #0]
 8005320:	4313      	orrs	r3, r2
 8005322:	888a      	ldrh	r2, [r1, #4]
 8005324:	4313      	orrs	r3, r2
 8005326:	88ca      	ldrh	r2, [r1, #6]
 8005328:	4313      	orrs	r3, r2
 800532a:	890a      	ldrh	r2, [r1, #8]
 800532c:	4313      	orrs	r3, r2
 800532e:	894a      	ldrh	r2, [r1, #10]
 8005330:	4313      	orrs	r3, r2
 8005332:	898a      	ldrh	r2, [r1, #12]
 8005334:	4313      	orrs	r3, r2
 8005336:	b29b      	uxth	r3, r3
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8005338:	6443      	str	r3, [r0, #68]	; 0x44
 800533a:	4770      	bx	lr

0800533c <TIM_Break1Config>:
{   /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_BREAK1_FILTER(TIM_Break1Filter));

  /* Reset the BKP and BKF Bits */
  TIMx->BDTR &= (uint32_t)~ (TIM_BDTR_BKP | TIM_BDTR_BKF);
 800533c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800533e:	f423 2372 	bic.w	r3, r3, #991232	; 0xf2000
 8005342:	6443      	str	r3, [r0, #68]	; 0x44
  /* Configure the Break1 polarity and filter */
  TIMx->BDTR |=	TIM_Break1Polarity |((uint32_t)TIM_Break1Filter << 16);
 8005344:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8005346:	4319      	orrs	r1, r3
 8005348:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 800534c:	6442      	str	r2, [r0, #68]	; 0x44
 800534e:	4770      	bx	lr

08005350 <TIM_Break2Config>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_BREAK2_FILTER(TIM_Break2Filter));

  /* Reset the BKP and BKF Bits */
  TIMx->BDTR &= (uint32_t)~ (TIM_BDTR_BK2P | TIM_BDTR_BK2F);
 8005350:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8005352:	f023 733c 	bic.w	r3, r3, #49283072	; 0x2f00000
 8005356:	6443      	str	r3, [r0, #68]	; 0x44

  /* Configure the Break1 polarity and filter */
  TIMx->BDTR |=	TIM_Break2Polarity |((uint32_t)TIM_Break2Filter << 20);
 8005358:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800535a:	4319      	orrs	r1, r3
 800535c:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
 8005360:	6442      	str	r2, [r0, #68]	; 0x44
 8005362:	4770      	bx	lr

08005364 <TIM_Break1Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BKE;
 8005364:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005366:	b111      	cbz	r1, 800536e <TIM_Break1Cmd+0xa>
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BKE;
 8005368:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800536c:	e001      	b.n	8005372 <TIM_Break1Cmd+0xe>
  }
  else
  {
    /* Disable the Break1 */
    TIMx->BDTR &= (uint32_t)~TIM_BDTR_BKE;
 800536e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8005372:	6443      	str	r3, [r0, #68]	; 0x44
 8005374:	4770      	bx	lr

08005376 <TIM_Break2Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BK2E;
 8005376:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005378:	b111      	cbz	r1, 8005380 <TIM_Break2Cmd+0xa>
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BK2E;
 800537a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800537e:	e001      	b.n	8005384 <TIM_Break2Cmd+0xe>
  }
  else
  {
    /* Disable the Break1 */
    TIMx->BDTR &= (uint32_t)~TIM_BDTR_BK2E;
 8005380:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8005384:	6443      	str	r3, [r0, #68]	; 0x44
 8005386:	4770      	bx	lr

08005388 <TIM_BDTRStructInit>:
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 8005388:	2300      	movs	r3, #0
 800538a:	8003      	strh	r3, [r0, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 800538c:	8043      	strh	r3, [r0, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 800538e:	8083      	strh	r3, [r0, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 8005390:	80c3      	strh	r3, [r0, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 8005392:	8103      	strh	r3, [r0, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 8005394:	8143      	strh	r3, [r0, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 8005396:	8183      	strh	r3, [r0, #12]
 8005398:	4770      	bx	lr

0800539a <TIM_CtrlPWMOutputs>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 800539a:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800539c:	b111      	cbz	r1, 80053a4 <TIM_CtrlPWMOutputs+0xa>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 800539e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80053a2:	e001      	b.n	80053a8 <TIM_CtrlPWMOutputs+0xe>
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 80053a4:	045b      	lsls	r3, r3, #17
 80053a6:	0c5b      	lsrs	r3, r3, #17
 80053a8:	6443      	str	r3, [r0, #68]	; 0x44
 80053aa:	4770      	bx	lr

080053ac <TIM_SelectCOM>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80053ac:	b119      	cbz	r1, 80053b6 <TIM_SelectCOM+0xa>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 80053ae:	6843      	ldr	r3, [r0, #4]
 80053b0:	f043 0304 	orr.w	r3, r3, #4
 80053b4:	e003      	b.n	80053be <TIM_SelectCOM+0x12>
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 80053b6:	6842      	ldr	r2, [r0, #4]
 80053b8:	f64f 73fb 	movw	r3, #65531	; 0xfffb
 80053bc:	4013      	ands	r3, r2
 80053be:	6043      	str	r3, [r0, #4]
 80053c0:	4770      	bx	lr

080053c2 <TIM_CCPreloadControl>:
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80053c2:	b119      	cbz	r1, 80053cc <TIM_CCPreloadControl+0xa>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 80053c4:	6843      	ldr	r3, [r0, #4]
 80053c6:	f043 0301 	orr.w	r3, r3, #1
 80053ca:	e003      	b.n	80053d4 <TIM_CCPreloadControl+0x12>
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 80053cc:	6842      	ldr	r2, [r0, #4]
 80053ce:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80053d2:	4013      	ands	r3, r2
 80053d4:	6043      	str	r3, [r0, #4]
 80053d6:	4770      	bx	lr

080053d8 <TIM_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 80053d8:	68c3      	ldr	r3, [r0, #12]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80053da:	b10a      	cbz	r2, 80053e0 <TIM_ITConfig+0x8>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 80053dc:	4319      	orrs	r1, r3
 80053de:	e002      	b.n	80053e6 <TIM_ITConfig+0xe>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 80053e0:	43c9      	mvns	r1, r1
 80053e2:	b289      	uxth	r1, r1
 80053e4:	4019      	ands	r1, r3
 80053e6:	60c1      	str	r1, [r0, #12]
 80053e8:	4770      	bx	lr

080053ea <TIM_GenerateEvent>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 80053ea:	6141      	str	r1, [r0, #20]
 80053ec:	4770      	bx	lr

080053ee <TIM_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));

  
  if ((TIMx->SR & TIM_FLAG) != RESET)
 80053ee:	6903      	ldr	r3, [r0, #16]
 80053f0:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80053f2:	bf0c      	ite	eq
 80053f4:	2000      	moveq	r0, #0
 80053f6:	2001      	movne	r0, #1
 80053f8:	4770      	bx	lr

080053fa <TIM_ClearFlag>:
{  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 80053fa:	43c9      	mvns	r1, r1
 80053fc:	b289      	uxth	r1, r1
 80053fe:	6101      	str	r1, [r0, #16]
 8005400:	4770      	bx	lr

08005402 <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8005402:	6903      	ldr	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 8005404:	68c2      	ldr	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8005406:	ea11 0003 	ands.w	r0, r1, r3
 800540a:	d003      	beq.n	8005414 <TIM_GetITStatus+0x12>
 800540c:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 800540e:	bf0c      	ite	eq
 8005410:	2000      	moveq	r0, #0
 8005412:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8005414:	4770      	bx	lr

08005416 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8005416:	43c9      	mvns	r1, r1
 8005418:	b289      	uxth	r1, r1
 800541a:	6101      	str	r1, [r0, #16]
 800541c:	4770      	bx	lr

0800541e <TIM_DMAConfig>:
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));

  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 800541e:	430a      	orrs	r2, r1
 8005420:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
 8005424:	4770      	bx	lr

08005426 <TIM_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 8005426:	68c3      	ldr	r3, [r0, #12]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005428:	b10a      	cbz	r2, 800542e <TIM_DMACmd+0x8>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 800542a:	4319      	orrs	r1, r3
 800542c:	e002      	b.n	8005434 <TIM_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 800542e:	43c9      	mvns	r1, r1
 8005430:	b289      	uxth	r1, r1
 8005432:	4019      	ands	r1, r3
 8005434:	60c1      	str	r1, [r0, #12]
 8005436:	4770      	bx	lr

08005438 <TIM_SelectCCDMA>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005438:	b119      	cbz	r1, 8005442 <TIM_SelectCCDMA+0xa>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 800543a:	6843      	ldr	r3, [r0, #4]
 800543c:	f043 0308 	orr.w	r3, r3, #8
 8005440:	e003      	b.n	800544a <TIM_SelectCCDMA+0x12>
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 8005442:	6842      	ldr	r2, [r0, #4]
 8005444:	f64f 73f7 	movw	r3, #65527	; 0xfff7
 8005448:	4013      	ands	r3, r2
 800544a:	6043      	str	r3, [r0, #4]
 800544c:	4770      	bx	lr

0800544e <TIM_InternalClockConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 800544e:	6882      	ldr	r2, [r0, #8]
 8005450:	f64f 73f8 	movw	r3, #65528	; 0xfff8
 8005454:	4013      	ands	r3, r2
 8005456:	6083      	str	r3, [r0, #8]
 8005458:	4770      	bx	lr

0800545a <TIM_ITRxExternalClockConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800545a:	6882      	ldr	r2, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 800545c:	f64f 738f 	movw	r3, #65423	; 0xff8f
 8005460:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005462:	4319      	orrs	r1, r3
 8005464:	6081      	str	r1, [r0, #8]

  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);

  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8005466:	6883      	ldr	r3, [r0, #8]
 8005468:	f043 0307 	orr.w	r3, r3, #7
 800546c:	6083      	str	r3, [r0, #8]
 800546e:	4770      	bx	lr

08005470 <TIM_TIxExternalClockConfig>:
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 8005470:	b538      	push	{r3, r4, r5, lr}
 8005472:	460d      	mov	r5, r1
 8005474:	4611      	mov	r1, r2
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 8005476:	2201      	movs	r2, #1
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 8005478:	2d60      	cmp	r5, #96	; 0x60
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 800547a:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 800547c:	d102      	bne.n	8005484 <TIM_TIxExternalClockConfig+0x14>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 800547e:	f7ff facf 	bl	8004a20 <TI2_Config>
 8005482:	e001      	b.n	8005488 <TIM_TIxExternalClockConfig+0x18>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 8005484:	f7ff fab8 	bl	80049f8 <TI1_Config>
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005488:	68a2      	ldr	r2, [r4, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 800548a:	f64f 738f 	movw	r3, #65423	; 0xff8f
 800548e:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005490:	432b      	orrs	r3, r5
 8005492:	60a3      	str	r3, [r4, #8]
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8005494:	68a3      	ldr	r3, [r4, #8]
 8005496:	f043 0307 	orr.w	r3, r3, #7
 800549a:	60a3      	str	r3, [r4, #8]
 800549c:	bd38      	pop	{r3, r4, r5, pc}

0800549e <TIM_SelectInputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800549e:	6882      	ldr	r2, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80054a0:	f64f 738f 	movw	r3, #65423	; 0xff8f
 80054a4:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80054a6:	4319      	orrs	r1, r3
 80054a8:	6081      	str	r1, [r0, #8]
 80054aa:	4770      	bx	lr

080054ac <TIM_SelectOutputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST7_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 80054ac:	6842      	ldr	r2, [r0, #4]
 80054ae:	f64f 738f 	movw	r3, #65423	; 0xff8f
 80054b2:	4013      	ands	r3, r2
 80054b4:	6043      	str	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 80054b6:	6843      	ldr	r3, [r0, #4]
 80054b8:	4319      	orrs	r1, r3
 80054ba:	6041      	str	r1, [r0, #4]
 80054bc:	4770      	bx	lr

080054be <TIM_SelectOutputTrigger2>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO2_SOURCE(TIM_TRGO2Source));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint32_t)~TIM_CR2_MMS2;
 80054be:	6843      	ldr	r3, [r0, #4]
 80054c0:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80054c4:	6043      	str	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGO2Source;
 80054c6:	6843      	ldr	r3, [r0, #4]
 80054c8:	4319      	orrs	r1, r3
 80054ca:	6041      	str	r1, [r0, #4]
 80054cc:	4770      	bx	lr

080054ce <TIM_SelectSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));

  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint32_t)~TIM_SMCR_SMS;
 80054ce:	6883      	ldr	r3, [r0, #8]
 80054d0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80054d4:	f023 0307 	bic.w	r3, r3, #7
 80054d8:	6083      	str	r3, [r0, #8]

  /* Select the Slave Mode */
  TIMx->SMCR |= (uint32_t)TIM_SlaveMode;
 80054da:	6883      	ldr	r3, [r0, #8]
 80054dc:	4319      	orrs	r1, r3
 80054de:	6081      	str	r1, [r0, #8]
 80054e0:	4770      	bx	lr

080054e2 <TIM_SelectMasterSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));

  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 80054e2:	6882      	ldr	r2, [r0, #8]
 80054e4:	f64f 737f 	movw	r3, #65407	; 0xff7f
 80054e8:	4013      	ands	r3, r2
 80054ea:	6083      	str	r3, [r0, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 80054ec:	6883      	ldr	r3, [r0, #8]
 80054ee:	4319      	orrs	r1, r3
 80054f0:	6081      	str	r1, [r0, #8]
 80054f2:	4770      	bx	lr

080054f4 <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 80054f4:	b510      	push	{r4, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 80054f6:	6884      	ldr	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 80054f8:	b2e4      	uxtb	r4, r4

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 80054fa:	4321      	orrs	r1, r4
 80054fc:	430a      	orrs	r2, r1
 80054fe:	ea42 2303 	orr.w	r3, r2, r3, lsl #8

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005502:	b29c      	uxth	r4, r3
 8005504:	6084      	str	r4, [r0, #8]
 8005506:	bd10      	pop	{r4, pc}

08005508 <TIM_ETRClockMode2Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8005508:	b510      	push	{r4, lr}
 800550a:	4604      	mov	r4, r0
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800550c:	f7ff fff2 	bl	80054f4 <TIM_ETRConfig>

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8005510:	68a3      	ldr	r3, [r4, #8]
 8005512:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005516:	60a3      	str	r3, [r4, #8]
 8005518:	bd10      	pop	{r4, pc}

0800551a <TIM_ETRClockMode1Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 800551a:	b510      	push	{r4, lr}
 800551c:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800551e:	f7ff ffe9 	bl	80054f4 <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005522:	68a2      	ldr	r2, [r4, #8]

  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;

  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8005524:	f64f 7388 	movw	r3, #65416	; 0xff88
 8005528:	4013      	ands	r3, r2
  tmpsmcr |= TIM_TS_ETRF;
 800552a:	f043 0377 	orr.w	r3, r3, #119	; 0x77

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800552e:	60a3      	str	r3, [r4, #8]
 8005530:	bd10      	pop	{r4, pc}

08005532 <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 8005532:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005534:	6885      	ldr	r5, [r0, #8]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8005536:	f64f 74f8 	movw	r4, #65528	; 0xfff8

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 800553a:	6986      	ldr	r6, [r0, #24]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 800553c:	402c      	ands	r4, r5
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 800553e:	f64f 45fc 	movw	r5, #64764	; 0xfcfc
 8005542:	4035      	ands	r5, r6

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8005544:	6a07      	ldr	r7, [r0, #32]
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 8005546:	f445 7580 	orr.w	r5, r5, #256	; 0x100
 800554a:	f045 0601 	orr.w	r6, r5, #1

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 800554e:	f64f 75dd 	movw	r5, #65501	; 0xffdd
 8005552:	403d      	ands	r5, r7
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 8005554:	432a      	orrs	r2, r5
 8005556:	ea42 1303 	orr.w	r3, r2, r3, lsl #4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800555a:	4321      	orrs	r1, r4

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800555c:	b29d      	uxth	r5, r3
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800555e:	6081      	str	r1, [r0, #8]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8005560:	6186      	str	r6, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005562:	6205      	str	r5, [r0, #32]
 8005564:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005566 <TIM_SelectHallSensor>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005566:	b119      	cbz	r1, 8005570 <TIM_SelectHallSensor+0xa>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 8005568:	6843      	ldr	r3, [r0, #4]
 800556a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800556e:	e003      	b.n	8005578 <TIM_SelectHallSensor+0x12>
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 8005570:	6842      	ldr	r2, [r0, #4]
 8005572:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8005576:	4013      	ands	r3, r2
 8005578:	6043      	str	r3, [r0, #4]
 800557a:	4770      	bx	lr

0800557c <TIM_RemapConfig>:
 /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 800557c:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
 8005580:	4770      	bx	lr
 8005582:	bf00      	nop

08005584 <USART_DeInit>:
  * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
  *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 8005584:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 8005586:	4b20      	ldr	r3, [pc, #128]	; (8005608 <USART_DeInit+0x84>)
 8005588:	4298      	cmp	r0, r3
 800558a:	d10b      	bne.n	80055a4 <USART_DeInit+0x20>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 800558c:	2101      	movs	r1, #1
 800558e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8005592:	f7fe ff49 	bl	8004428 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 8005596:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800559a:	2100      	movs	r1, #0
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 800559c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80055a0:	f7fe bf42 	b.w	8004428 <RCC_APB2PeriphResetCmd>
  }
  else if (USARTx == USART2)
 80055a4:	4b19      	ldr	r3, [pc, #100]	; (800560c <USART_DeInit+0x88>)
 80055a6:	4298      	cmp	r0, r3
 80055a8:	d107      	bne.n	80055ba <USART_DeInit+0x36>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 80055aa:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80055ae:	2101      	movs	r1, #1
 80055b0:	f7fe ff46 	bl	8004440 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 80055b4:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80055b8:	e01f      	b.n	80055fa <USART_DeInit+0x76>
  }
  else if (USARTx == USART3)
 80055ba:	4b15      	ldr	r3, [pc, #84]	; (8005610 <USART_DeInit+0x8c>)
 80055bc:	4298      	cmp	r0, r3
 80055be:	d107      	bne.n	80055d0 <USART_DeInit+0x4c>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 80055c0:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80055c4:	2101      	movs	r1, #1
 80055c6:	f7fe ff3b 	bl	8004440 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 80055ca:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80055ce:	e014      	b.n	80055fa <USART_DeInit+0x76>
  }
  else if (USARTx == UART4)
 80055d0:	4b10      	ldr	r3, [pc, #64]	; (8005614 <USART_DeInit+0x90>)
 80055d2:	4298      	cmp	r0, r3
 80055d4:	d107      	bne.n	80055e6 <USART_DeInit+0x62>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 80055d6:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80055da:	2101      	movs	r1, #1
 80055dc:	f7fe ff30 	bl	8004440 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 80055e0:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80055e4:	e009      	b.n	80055fa <USART_DeInit+0x76>
  }
  else
  {
    if  (USARTx == UART5)
 80055e6:	4b0c      	ldr	r3, [pc, #48]	; (8005618 <USART_DeInit+0x94>)
 80055e8:	4298      	cmp	r0, r3
 80055ea:	d10b      	bne.n	8005604 <USART_DeInit+0x80>
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 80055ec:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80055f0:	2101      	movs	r1, #1
 80055f2:	f7fe ff25 	bl	8004440 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 80055f6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80055fa:	2100      	movs	r1, #0
    }
  }
}
 80055fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if  (USARTx == UART5)
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 8005600:	f7fe bf1e 	b.w	8004440 <RCC_APB1PeriphResetCmd>
 8005604:	bd08      	pop	{r3, pc}
 8005606:	bf00      	nop
 8005608:	40013800 	.word	0x40013800
 800560c:	40004400 	.word	0x40004400
 8005610:	40004800 	.word	0x40004800
 8005614:	40004c00 	.word	0x40004c00
 8005618:	40005000 	.word	0x40005000

0800561c <USART_Init>:
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 800561c:	6803      	ldr	r3, [r0, #0]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800561e:	b530      	push	{r4, r5, lr}
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8005620:	f023 0301 	bic.w	r3, r3, #1
 8005624:	6003      	str	r3, [r0, #0]
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005626:	6842      	ldr	r2, [r0, #4]
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8005628:	688b      	ldr	r3, [r1, #8]
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 800562a:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800562e:	460d      	mov	r5, r1
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8005630:	4313      	orrs	r3, r2
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 8005632:	6043      	str	r3, [r0, #4]
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005634:	686a      	ldr	r2, [r5, #4]
 8005636:	68eb      	ldr	r3, [r5, #12]
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8005638:	6801      	ldr	r1, [r0, #0]
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 800563a:	431a      	orrs	r2, r3
 800563c:	692b      	ldr	r3, [r5, #16]
  USARTx->CR2 = tmpreg;
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 800563e:	f421 51b0 	bic.w	r1, r1, #5632	; 0x1600
 8005642:	f021 010c 	bic.w	r1, r1, #12
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005646:	4313      	orrs	r3, r2
 8005648:	430b      	orrs	r3, r1
    USART_InitStruct->USART_Mode;
  
  /* Write to USART CR1 */
  USARTx->CR1 = tmpreg;
 800564a:	6003      	str	r3, [r0, #0]
  
  /*---------------------------- USART CR3 Configuration -----------------------*/
  tmpreg = USARTx->CR3;
 800564c:	6882      	ldr	r2, [r0, #8]
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 800564e:	696b      	ldr	r3, [r5, #20]
  USARTx->CR1 = tmpreg;
  
  /*---------------------------- USART CR3 Configuration -----------------------*/
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 8005650:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8005654:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8005656:	b091      	sub	sp, #68	; 0x44
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
 8005658:	6083      	str	r3, [r0, #8]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800565a:	4604      	mov	r4, r0
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
  
  /*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 800565c:	a801      	add	r0, sp, #4
 800565e:	f7fe fd0d 	bl	800407c <RCC_GetClocksFreq>
  
  if (USARTx == USART1)
 8005662:	4b18      	ldr	r3, [pc, #96]	; (80056c4 <USART_Init+0xa8>)
 8005664:	429c      	cmp	r4, r3
 8005666:	d101      	bne.n	800566c <USART_Init+0x50>
  {
    apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 8005668:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800566a:	e00e      	b.n	800568a <USART_Init+0x6e>
  }
  else if (USARTx == USART2)
 800566c:	4b16      	ldr	r3, [pc, #88]	; (80056c8 <USART_Init+0xac>)
 800566e:	429c      	cmp	r4, r3
 8005670:	d101      	bne.n	8005676 <USART_Init+0x5a>
  {
    apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 8005672:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8005674:	e009      	b.n	800568a <USART_Init+0x6e>
  }
  else if (USARTx == USART3)
 8005676:	4b15      	ldr	r3, [pc, #84]	; (80056cc <USART_Init+0xb0>)
 8005678:	429c      	cmp	r4, r3
 800567a:	d101      	bne.n	8005680 <USART_Init+0x64>
  {
    apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 800567c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800567e:	e004      	b.n	800568a <USART_Init+0x6e>
  }
  else if (USARTx == UART4)
 8005680:	4b13      	ldr	r3, [pc, #76]	; (80056d0 <USART_Init+0xb4>)
 8005682:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.UART4CLK_Frequency;
 8005684:	bf0c      	ite	eq
 8005686:	9a0e      	ldreq	r2, [sp, #56]	; 0x38
  }
  else 
  {
    apbclock = RCC_ClocksStatus.UART5CLK_Frequency;
 8005688:	9a0f      	ldrne	r2, [sp, #60]	; 0x3c
  }  
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 800568a:	6823      	ldr	r3, [r4, #0]
 800568c:	6829      	ldr	r1, [r5, #0]
 800568e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  {
    /* (divider * 10) computing in case Oversampling mode is 8 Samples */
    divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 8005692:	bf18      	it	ne
 8005694:	0052      	lslne	r2, r2, #1
    tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* (divider * 10) computing in case Oversampling mode is 16 Samples */
    divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 8005696:	fbb2 f3f1 	udiv	r3, r2, r1
    tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 800569a:	fb01 2113 	mls	r1, r1, r3, r2
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 800569e:	682a      	ldr	r2, [r5, #0]
 80056a0:	ebb1 0f52 	cmp.w	r1, r2, lsr #1
  {
    divider++;
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80056a4:	6822      	ldr	r2, [r4, #0]
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
  {
    divider++;
 80056a6:	bf28      	it	cs
 80056a8:	3301      	addcs	r3, #1
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80056aa:	0412      	lsls	r2, r2, #16
 80056ac:	d506      	bpl.n	80056bc <USART_Init+0xa0>
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 80056ae:	f64f 72f0 	movw	r2, #65520	; 0xfff0
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
 80056b2:	f3c3 0142 	ubfx	r1, r3, #1, #3
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 80056b6:	401a      	ands	r2, r3
 80056b8:	ea41 0302 	orr.w	r3, r1, r2
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)divider;
 80056bc:	81a3      	strh	r3, [r4, #12]
}
 80056be:	b011      	add	sp, #68	; 0x44
 80056c0:	bd30      	pop	{r4, r5, pc}
 80056c2:	bf00      	nop
 80056c4:	40013800 	.word	0x40013800
 80056c8:	40004400 	.word	0x40004400
 80056cc:	40004800 	.word	0x40004800
 80056d0:	40004c00 	.word	0x40004c00

080056d4 <USART_StructInit>:
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 80056d4:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 80056d8:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80056da:	220c      	movs	r2, #12
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 80056dc:	2300      	movs	r3, #0
 80056de:	6043      	str	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 80056e0:	6083      	str	r3, [r0, #8]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 80056e2:	60c3      	str	r3, [r0, #12]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80056e4:	6102      	str	r2, [r0, #16]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 80056e6:	6143      	str	r3, [r0, #20]
 80056e8:	4770      	bx	lr

080056ea <USART_ClockInit>:
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 80056ea:	e891 000c 	ldmia.w	r1, {r2, r3}
 80056ee:	431a      	orrs	r2, r3
 80056f0:	688b      	ldr	r3, [r1, #8]
  *         structure that contains the configuration information for the specified
  *         USART peripheral.
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 80056f2:	b510      	push	{r4, lr}
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 80056f4:	68c9      	ldr	r1, [r1, #12]
  assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80056f6:	6844      	ldr	r4, [r0, #4]
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 80056f8:	4313      	orrs	r3, r2
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 80056fa:	f424 6470 	bic.w	r4, r4, #3840	; 0xf00
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 80056fe:	430b      	orrs	r3, r1
 8005700:	4323      	orrs	r3, r4
                       USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 8005702:	6043      	str	r3, [r0, #4]
 8005704:	bd10      	pop	{r4, pc}

08005706 <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 8005706:	2300      	movs	r3, #0
 8005708:	6003      	str	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 800570a:	6043      	str	r3, [r0, #4]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 800570c:	6083      	str	r3, [r0, #8]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 800570e:	60c3      	str	r3, [r0, #12]
 8005710:	4770      	bx	lr

08005712 <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8005712:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005714:	b111      	cbz	r1, 800571c <USART_Cmd+0xa>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8005716:	f043 0301 	orr.w	r3, r3, #1
 800571a:	e001      	b.n	8005720 <USART_Cmd+0xe>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 800571c:	f023 0301 	bic.w	r3, r3, #1
 8005720:	6003      	str	r3, [r0, #0]
 8005722:	4770      	bx	lr

08005724 <USART_DirectionModeCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the USART's transfer interface by setting the TE and/or RE bits 
       in the USART CR1 register */
    USARTx->CR1 |= USART_DirectionMode;
 8005724:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_MODE(USART_DirectionMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8005726:	b10a      	cbz	r2, 800572c <USART_DirectionModeCmd+0x8>
  {
    /* Enable the USART's transfer interface by setting the TE and/or RE bits 
       in the USART CR1 register */
    USARTx->CR1 |= USART_DirectionMode;
 8005728:	4319      	orrs	r1, r3
 800572a:	e001      	b.n	8005730 <USART_DirectionModeCmd+0xc>
  }
  else
  {
    /* Disable the USART's transfer interface by clearing the TE and/or RE bits
       in the USART CR3 register */
    USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
 800572c:	ea23 0101 	bic.w	r1, r3, r1
 8005730:	6001      	str	r1, [r0, #0]
 8005732:	4770      	bx	lr

08005734 <USART_OverSampling8Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8005734:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005736:	b111      	cbz	r1, 800573e <USART_OverSampling8Cmd+0xa>
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8005738:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800573c:	e001      	b.n	8005742 <USART_OverSampling8Cmd+0xe>
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
 800573e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005742:	6003      	str	r3, [r0, #0]
 8005744:	4770      	bx	lr

08005746 <USART_OneBitMethodCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 8005746:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005748:	b111      	cbz	r1, 8005750 <USART_OneBitMethodCmd+0xa>
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 800574a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800574e:	e001      	b.n	8005754 <USART_OneBitMethodCmd+0xe>
  }
  else
  {
    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
 8005750:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005754:	6083      	str	r3, [r0, #8]
 8005756:	4770      	bx	lr

08005758 <USART_MSBFirstCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the most significant bit first transmitted/received following the
       start bit by setting the MSBFIRST bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_MSBFIRST;
 8005758:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800575a:	b111      	cbz	r1, 8005762 <USART_MSBFirstCmd+0xa>
  {
    /* Enable the most significant bit first transmitted/received following the
       start bit by setting the MSBFIRST bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_MSBFIRST;
 800575c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8005760:	e001      	b.n	8005766 <USART_MSBFirstCmd+0xe>
  }
  else
  {
    /* Disable the most significant bit first transmitted/received following the
       start bit by clearing the MSBFIRST bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
 8005762:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8005766:	6043      	str	r3, [r0, #4]
 8005768:	4770      	bx	lr

0800576a <USART_DataInvCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the binary data inversion feature by setting the DATAINV bit in
       the CR2 register */
    USARTx->CR2 |= USART_CR2_DATAINV;
 800576a:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800576c:	b111      	cbz	r1, 8005774 <USART_DataInvCmd+0xa>
  {
    /* Enable the binary data inversion feature by setting the DATAINV bit in
       the CR2 register */
    USARTx->CR2 |= USART_CR2_DATAINV;
 800576e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8005772:	e001      	b.n	8005778 <USART_DataInvCmd+0xe>
  }
  else
  {
    /* Disable the binary data inversion feature by clearing the DATAINV bit in
       the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
 8005774:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8005778:	6043      	str	r3, [r0, #4]
 800577a:	4770      	bx	lr

0800577c <USART_InvPinCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the active level inversion for selected pins by setting the TXINV 
       and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 |= USART_InvPin;
 800577c:	6843      	ldr	r3, [r0, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 800577e:	b10a      	cbz	r2, 8005784 <USART_InvPinCmd+0x8>
  {
    /* Enable the active level inversion for selected pins by setting the TXINV 
       and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 |= USART_InvPin;
 8005780:	4319      	orrs	r1, r3
 8005782:	e001      	b.n	8005788 <USART_InvPinCmd+0xc>
  }
  else
  {
    /* Disable the active level inversion for selected requests by clearing the 
       TXINV and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 &= (uint32_t)~USART_InvPin;
 8005784:	ea23 0101 	bic.w	r1, r3, r1
 8005788:	6041      	str	r1, [r0, #4]
 800578a:	4770      	bx	lr

0800578c <USART_SWAPPinCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_SWAP;
 800578c:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800578e:	b111      	cbz	r1, 8005796 <USART_SWAPPinCmd+0xa>
  {
    /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_SWAP;
 8005790:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005794:	e001      	b.n	800579a <USART_SWAPPinCmd+0xe>
  }
  else
  {
    /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
 8005796:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800579a:	6043      	str	r3, [r0, #4]
 800579c:	4770      	bx	lr

0800579e <USART_ReceiverTimeOutCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_RTOEN;
 800579e:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80057a0:	b111      	cbz	r1, 80057a8 <USART_ReceiverTimeOutCmd+0xa>
  {
    /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_RTOEN;
 80057a2:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80057a6:	e001      	b.n	80057ac <USART_ReceiverTimeOutCmd+0xe>
  }
  else
  {
    /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
       register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
 80057a8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 80057ac:	6043      	str	r3, [r0, #4]
 80057ae:	4770      	bx	lr

080057b0 <USART_SetReceiverTimeOut>:
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));

  /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
     register  */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
 80057b0:	6943      	ldr	r3, [r0, #20]
 80057b2:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 80057b6:	6143      	str	r3, [r0, #20]
  /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
     register  */
  USARTx->RTOR |= USART_ReceiverTimeOut;
 80057b8:	6943      	ldr	r3, [r0, #20]
 80057ba:	4319      	orrs	r1, r3
 80057bc:	6141      	str	r1, [r0, #20]
 80057be:	4770      	bx	lr

080057c0 <USART_SetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Clear the USART prescaler */
  USARTx->GTPR &= USART_GTPR_GT;
 80057c0:	8a03      	ldrh	r3, [r0, #16]
 80057c2:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80057c6:	8203      	strh	r3, [r0, #16]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 80057c8:	8a03      	ldrh	r3, [r0, #16]
 80057ca:	b29b      	uxth	r3, r3
 80057cc:	4319      	orrs	r1, r3
 80057ce:	8201      	strh	r1, [r0, #16]
 80057d0:	4770      	bx	lr

080057d2 <USART_STOPModeCmd>:
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
       register */
    USARTx->CR1 |= USART_CR1_UESM;
 80057d2:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80057d4:	b111      	cbz	r1, 80057dc <USART_STOPModeCmd+0xa>
  {
    /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
       register */
    USARTx->CR1 |= USART_CR1_UESM;
 80057d6:	f043 0302 	orr.w	r3, r3, #2
 80057da:	e001      	b.n	80057e0 <USART_STOPModeCmd+0xe>
  }
  else
  {
    /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
       register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
 80057dc:	f023 0302 	bic.w	r3, r3, #2
 80057e0:	6003      	str	r3, [r0, #0]
 80057e2:	4770      	bx	lr

080057e4 <USART_StopModeWakeUpSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
 80057e4:	6883      	ldr	r3, [r0, #8]
 80057e6:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80057ea:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_WakeUpSource;
 80057ec:	6883      	ldr	r3, [r0, #8]
 80057ee:	4319      	orrs	r1, r3
 80057f0:	6081      	str	r1, [r0, #8]
 80057f2:	4770      	bx	lr

080057f4 <USART_AutoBaudRateCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_ABREN;
 80057f4:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80057f6:	b111      	cbz	r1, 80057fe <USART_AutoBaudRateCmd+0xa>
  {
    /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_ABREN;
 80057f8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80057fc:	e001      	b.n	8005802 <USART_AutoBaudRateCmd+0xe>
  }
  else
  {
    /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
       register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
 80057fe:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8005802:	6043      	str	r3, [r0, #4]
 8005804:	4770      	bx	lr

08005806 <USART_AutoBaudRateConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
 8005806:	6843      	ldr	r3, [r0, #4]
 8005808:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 800580c:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_AutoBaudRate;
 800580e:	6843      	ldr	r3, [r0, #4]
 8005810:	4319      	orrs	r1, r3
 8005812:	6041      	str	r1, [r0, #4]
 8005814:	4770      	bx	lr

08005816 <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 

  /* Transmit Data */
  USARTx->TDR = (Data & (uint16_t)0x01FF);
 8005816:	05c9      	lsls	r1, r1, #23
 8005818:	0dc9      	lsrs	r1, r1, #23
 800581a:	8501      	strh	r1, [r0, #40]	; 0x28
 800581c:	4770      	bx	lr

0800581e <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Receive Data */
  return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
 800581e:	8c80      	ldrh	r0, [r0, #36]	; 0x24
 8005820:	05c0      	lsls	r0, r0, #23
}
 8005822:	0dc0      	lsrs	r0, r0, #23
 8005824:	4770      	bx	lr

08005826 <USART_SetAddress>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Clear the USART address */
  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
 8005826:	6843      	ldr	r3, [r0, #4]
 8005828:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800582c:	6043      	str	r3, [r0, #4]
  /* Set the USART address node */
  USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
 800582e:	6843      	ldr	r3, [r0, #4]
 8005830:	ea43 6101 	orr.w	r1, r3, r1, lsl #24
 8005834:	6041      	str	r1, [r0, #4]
 8005836:	4770      	bx	lr

08005838 <USART_MuteModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode by setting the MME bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_MME;
 8005838:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 800583a:	b111      	cbz	r1, 8005842 <USART_MuteModeCmd+0xa>
  {
    /* Enable the USART mute mode by setting the MME bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_MME;
 800583c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005840:	e001      	b.n	8005846 <USART_MuteModeCmd+0xe>
  }
  else
  {
    /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
 8005842:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005846:	6003      	str	r3, [r0, #0]
 8005848:	4770      	bx	lr

0800584a <USART_MuteModeWakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));

  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
 800584a:	6803      	ldr	r3, [r0, #0]
 800584c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005850:	6003      	str	r3, [r0, #0]
  USARTx->CR1 |= USART_WakeUp;
 8005852:	6803      	ldr	r3, [r0, #0]
 8005854:	4319      	orrs	r1, r3
 8005856:	6001      	str	r1, [r0, #0]
 8005858:	4770      	bx	lr

0800585a <USART_AddressDetectionConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
 800585a:	6843      	ldr	r3, [r0, #4]
 800585c:	f023 0310 	bic.w	r3, r3, #16
 8005860:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_AddressLength;
 8005862:	6843      	ldr	r3, [r0, #4]
 8005864:	4319      	orrs	r1, r3
 8005866:	6041      	str	r1, [r0, #4]
 8005868:	4770      	bx	lr

0800586a <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
 800586a:	6843      	ldr	r3, [r0, #4]
 800586c:	f023 0320 	bic.w	r3, r3, #32
 8005870:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 8005872:	6843      	ldr	r3, [r0, #4]
 8005874:	4319      	orrs	r1, r3
 8005876:	6041      	str	r1, [r0, #4]
 8005878:	4770      	bx	lr

0800587a <USART_LINCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 800587a:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800587c:	b111      	cbz	r1, 8005884 <USART_LINCmd+0xa>
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 800587e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005882:	e001      	b.n	8005888 <USART_LINCmd+0xe>
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
 8005884:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005888:	6043      	str	r3, [r0, #4]
 800588a:	4770      	bx	lr

0800588c <USART_HalfDuplexCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 800588c:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800588e:	b111      	cbz	r1, 8005896 <USART_HalfDuplexCmd+0xa>
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 8005890:	f043 0308 	orr.w	r3, r3, #8
 8005894:	e001      	b.n	800589a <USART_HalfDuplexCmd+0xe>
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
 8005896:	f023 0308 	bic.w	r3, r3, #8
 800589a:	6083      	str	r3, [r0, #8]
 800589c:	4770      	bx	lr

0800589e <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 800589e:	8a03      	ldrh	r3, [r0, #16]
 80058a0:	b2db      	uxtb	r3, r3
 80058a2:	8203      	strh	r3, [r0, #16]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 80058a4:	8a03      	ldrh	r3, [r0, #16]
 80058a6:	b29b      	uxth	r3, r3
 80058a8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80058ac:	8201      	strh	r1, [r0, #16]
 80058ae:	4770      	bx	lr

080058b0 <USART_SmartCardCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 80058b0:	6883      	ldr	r3, [r0, #8]
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80058b2:	b111      	cbz	r1, 80058ba <USART_SmartCardCmd+0xa>
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 80058b4:	f043 0320 	orr.w	r3, r3, #32
 80058b8:	e001      	b.n	80058be <USART_SmartCardCmd+0xe>
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
 80058ba:	f023 0320 	bic.w	r3, r3, #32
 80058be:	6083      	str	r3, [r0, #8]
 80058c0:	4770      	bx	lr

080058c2 <USART_SmartCardNACKCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 80058c2:	6883      	ldr	r3, [r0, #8]
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80058c4:	b111      	cbz	r1, 80058cc <USART_SmartCardNACKCmd+0xa>
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 80058c6:	f043 0310 	orr.w	r3, r3, #16
 80058ca:	e001      	b.n	80058d0 <USART_SmartCardNACKCmd+0xe>
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
 80058cc:	f023 0310 	bic.w	r3, r3, #16
 80058d0:	6083      	str	r3, [r0, #8]
 80058d2:	4770      	bx	lr

080058d4 <USART_SetAutoRetryCount>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
  /* Clear the USART auto retry count */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
 80058d4:	6883      	ldr	r3, [r0, #8]
 80058d6:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
 80058da:	6083      	str	r3, [r0, #8]
  /* Set the USART auto retry count*/
  USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
 80058dc:	6883      	ldr	r3, [r0, #8]
 80058de:	ea43 4141 	orr.w	r1, r3, r1, lsl #17
 80058e2:	6081      	str	r1, [r0, #8]
 80058e4:	4770      	bx	lr

080058e6 <USART_SetBlockLength>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the Smart card block length */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
 80058e6:	6943      	ldr	r3, [r0, #20]
 80058e8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80058ec:	6143      	str	r3, [r0, #20]
  /* Set the Smart Card block length */
  USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
 80058ee:	6943      	ldr	r3, [r0, #20]
 80058f0:	ea43 6101 	orr.w	r1, r3, r1, lsl #24
 80058f4:	6141      	str	r1, [r0, #20]
 80058f6:	4770      	bx	lr

080058f8 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
 80058f8:	6883      	ldr	r3, [r0, #8]
 80058fa:	f023 0304 	bic.w	r3, r3, #4
 80058fe:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_IrDAMode;
 8005900:	6883      	ldr	r3, [r0, #8]
 8005902:	4319      	orrs	r1, r3
 8005904:	6081      	str	r1, [r0, #8]
 8005906:	4770      	bx	lr

08005908 <USART_IrDACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 8005908:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800590a:	b111      	cbz	r1, 8005912 <USART_IrDACmd+0xa>
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 800590c:	f043 0302 	orr.w	r3, r3, #2
 8005910:	e001      	b.n	8005916 <USART_IrDACmd+0xe>
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
 8005912:	f023 0302 	bic.w	r3, r3, #2
 8005916:	6083      	str	r3, [r0, #8]
 8005918:	4770      	bx	lr

0800591a <USART_DECmd>:
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the DE functionality by setting the DEM bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_DEM;
 800591a:	6883      	ldr	r3, [r0, #8]
void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800591c:	b111      	cbz	r1, 8005924 <USART_DECmd+0xa>
  {
    /* Enable the DE functionality by setting the DEM bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_DEM;
 800591e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005922:	e001      	b.n	8005928 <USART_DECmd+0xe>
  }
  else
  {
    /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
 8005924:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005928:	6083      	str	r3, [r0, #8]
 800592a:	4770      	bx	lr

0800592c <USART_DEPolarityConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
 800592c:	6883      	ldr	r3, [r0, #8]
 800592e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005932:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_DEPolarity;
 8005934:	6883      	ldr	r3, [r0, #8]
 8005936:	4319      	orrs	r1, r3
 8005938:	6081      	str	r1, [r0, #8]
 800593a:	4770      	bx	lr

0800593c <USART_SetDEAssertionTime>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 

  /* Clear the DE assertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
 800593c:	6803      	ldr	r3, [r0, #0]
 800593e:	f023 7378 	bic.w	r3, r3, #65011712	; 0x3e00000
 8005942:	6003      	str	r3, [r0, #0]
  /* Set the new value for the DE assertion time */
  USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
 8005944:	6803      	ldr	r3, [r0, #0]
 8005946:	ea43 5141 	orr.w	r1, r3, r1, lsl #21
 800594a:	6001      	str	r1, [r0, #0]
 800594c:	4770      	bx	lr

0800594e <USART_SetDEDeassertionTime>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 

  /* Clear the DE deassertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
 800594e:	6803      	ldr	r3, [r0, #0]
 8005950:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8005954:	6003      	str	r3, [r0, #0]
  /* Set the new value for the DE deassertion time */
  USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
 8005956:	6803      	ldr	r3, [r0, #0]
 8005958:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800595c:	6001      	str	r1, [r0, #0]
 800595e:	4770      	bx	lr

08005960 <USART_DMACmd>:

  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8005960:	6883      	ldr	r3, [r0, #8]
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8005962:	b10a      	cbz	r2, 8005968 <USART_DMACmd+0x8>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8005964:	4319      	orrs	r1, r3
 8005966:	e001      	b.n	800596c <USART_DMACmd+0xc>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint32_t)~USART_DMAReq;
 8005968:	ea23 0101 	bic.w	r1, r3, r1
 800596c:	6081      	str	r1, [r0, #8]
 800596e:	4770      	bx	lr

08005970 <USART_DMAReceptionErrorConfig>:
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
  
  /* Clear the DMA Reception error detection bit */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
 8005970:	6883      	ldr	r3, [r0, #8]
 8005972:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005976:	6083      	str	r3, [r0, #8]
  /* Set the new value for the DMA Reception error detection bit */
  USARTx->CR3 |= USART_DMAOnError;
 8005978:	6883      	ldr	r3, [r0, #8]
 800597a:	4319      	orrs	r1, r3
 800597c:	6081      	str	r1, [r0, #8]
 800597e:	4770      	bx	lr

08005980 <USART_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 8005980:	f3c1 2307 	ubfx	r3, r1, #8, #8
  * @param  NewState: new state of the specified USARTx interrupts.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
{
 8005984:	b510      	push	{r4, lr}

  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 8005986:	b2c9      	uxtb	r1, r1
  itmask = (((uint32_t)0x01) << itpos);
 8005988:	2401      	movs	r4, #1

  if (usartreg == 0x02) /* The IT is in CR2 register */
 800598a:	2b02      	cmp	r3, #2
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 800598c:	fa04 f101 	lsl.w	r1, r4, r1

  if (usartreg == 0x02) /* The IT is in CR2 register */
 8005990:	d101      	bne.n	8005996 <USART_ITConfig+0x16>
  {
    usartxbase += 0x04;
 8005992:	3004      	adds	r0, #4
 8005994:	e002      	b.n	800599c <USART_ITConfig+0x1c>
  }
  else if (usartreg == 0x03) /* The IT is in CR3 register */
 8005996:	2b03      	cmp	r3, #3
  {
    usartxbase += 0x08;
 8005998:	bf08      	it	eq
 800599a:	3008      	addeq	r0, #8
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 800599c:	6803      	ldr	r3, [r0, #0]
    usartxbase += 0x08;
  }
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
 800599e:	b10a      	cbz	r2, 80059a4 <USART_ITConfig+0x24>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80059a0:	4319      	orrs	r1, r3
 80059a2:	e001      	b.n	80059a8 <USART_ITConfig+0x28>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80059a4:	ea23 0101 	bic.w	r1, r3, r1
 80059a8:	6001      	str	r1, [r0, #0]
 80059aa:	bd10      	pop	{r4, pc}

080059ac <USART_RequestCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
       register.*/
    USARTx->RQR |= USART_Request;
 80059ac:	8b03      	ldrh	r3, [r0, #24]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_REQUEST(USART_Request));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 80059ae:	b10a      	cbz	r2, 80059b4 <USART_RequestCmd+0x8>
  {
    /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
       register.*/
    USARTx->RQR |= USART_Request;
 80059b0:	4319      	orrs	r1, r3
 80059b2:	e002      	b.n	80059ba <USART_RequestCmd+0xe>
  }
  else
  {
    /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
       register.*/
    USARTx->RQR &= (uint32_t)~USART_Request;
 80059b4:	b29b      	uxth	r3, r3
 80059b6:	ea23 0101 	bic.w	r1, r3, r1
 80059ba:	8301      	strh	r1, [r0, #24]
 80059bc:	4770      	bx	lr

080059be <USART_OverrunDetectionConfig>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
  
  /* Clear the OVR detection bit */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
 80059be:	6883      	ldr	r3, [r0, #8]
 80059c0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80059c4:	6083      	str	r3, [r0, #8]
  /* Set the new value for the OVR detection bit */
  USARTx->CR3 |= USART_OVRDetection;
 80059c6:	6883      	ldr	r3, [r0, #8]
 80059c8:	4319      	orrs	r1, r3
 80059ca:	6081      	str	r1, [r0, #8]
 80059cc:	4770      	bx	lr

080059ce <USART_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_FLAG(USART_FLAG));
  
  if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
 80059ce:	69c3      	ldr	r3, [r0, #28]
 80059d0:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80059d2:	bf0c      	ite	eq
 80059d4:	2000      	moveq	r0, #0
 80059d6:	2001      	movne	r0, #1
 80059d8:	4770      	bx	lr

080059da <USART_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
     
  USARTx->ICR = USART_FLAG;
 80059da:	6201      	str	r1, [r0, #32]
 80059dc:	4770      	bx	lr

080059de <USART_GetITStatus>:
  *         @arg USART_IT_FE:  Framing Error interrupt.
  *         @arg USART_IT_PE:  Parity Error interrupt.
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
{
 80059de:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 80059e0:	f3c1 2207 	ubfx	r2, r1, #8, #8
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 80059e4:	2401      	movs	r4, #1
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 80059e6:	b2cb      	uxtb	r3, r1
  itmask = (uint32_t)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 80059e8:	42a2      	cmp	r2, r4
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 80059ea:	fa04 f303 	lsl.w	r3, r4, r3
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 80059ee:	d101      	bne.n	80059f4 <USART_GetITStatus+0x16>
  {
    itmask &= USARTx->CR1;
 80059f0:	6802      	ldr	r2, [r0, #0]
 80059f2:	e003      	b.n	80059fc <USART_GetITStatus+0x1e>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 80059f4:	2a02      	cmp	r2, #2
  {
    itmask &= USARTx->CR2;
 80059f6:	bf0c      	ite	eq
 80059f8:	6842      	ldreq	r2, [r0, #4]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 80059fa:	6882      	ldrne	r2, [r0, #8]
 80059fc:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->ISR;
 80059fe:	69c2      	ldr	r2, [r0, #28]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8005a00:	b143      	cbz	r3, 8005a14 <USART_GetITStatus+0x36>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
 8005a02:	2301      	movs	r3, #1
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x10;
 8005a04:	0c09      	lsrs	r1, r1, #16
  bitpos = (uint32_t)0x01 << bitpos;
 8005a06:	fa03 f101 	lsl.w	r1, r3, r1
  bitpos &= USARTx->ISR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8005a0a:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 8005a0c:	bf0c      	ite	eq
 8005a0e:	2000      	moveq	r0, #0
 8005a10:	2001      	movne	r0, #1
 8005a12:	bd10      	pop	{r4, pc}
  }
  else
  {
    bitstatus = RESET;
 8005a14:	4618      	mov	r0, r3
  }
  
  return bitstatus;  
}
 8005a16:	bd10      	pop	{r4, pc}

08005a18 <USART_ClearITPendingBit>:
  uint32_t bitpos = 0, itmask = 0;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_IT(USART_IT)); 
  
  bitpos = USART_IT >> 0x10;
 8005a18:	0c09      	lsrs	r1, r1, #16
  itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
 8005a1a:	2301      	movs	r3, #1
 8005a1c:	fa03 f101 	lsl.w	r1, r3, r1
  USARTx->ICR = (uint32_t)itmask;
 8005a20:	6201      	str	r1, [r0, #32]
 8005a22:	4770      	bx	lr

08005a24 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8005a24:	b538      	push	{r3, r4, r5, lr}
void *pvReturn = NULL;
static unsigned char *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8005a26:	0743      	lsls	r3, r0, #29
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8005a28:	4605      	mov	r5, r0
	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8005a2a:	bf1c      	itt	ne
 8005a2c:	f020 0507 	bicne.w	r5, r0, #7
 8005a30:	3508      	addne	r5, #8
		}
	#endif

	vTaskSuspendAll();
 8005a32:	f000 fff9 	bl	8006a28 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 8005a36:	4b10      	ldr	r3, [pc, #64]	; (8005a78 <pvPortMalloc+0x54>)
 8005a38:	681a      	ldr	r2, [r3, #0]
 8005a3a:	b922      	cbnz	r2, 8005a46 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 8005a3c:	f103 020c 	add.w	r2, r3, #12
 8005a40:	f022 0207 	bic.w	r2, r2, #7
 8005a44:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8005a46:	4a0d      	ldr	r2, [pc, #52]	; (8005a7c <pvPortMalloc+0x58>)
 8005a48:	f242 71f7 	movw	r1, #10231	; 0x27f7
 8005a4c:	f8d2 3614 	ldr.w	r3, [r2, #1556]	; 0x614
 8005a50:	18ed      	adds	r5, r5, r3
 8005a52:	428d      	cmp	r5, r1
 8005a54:	d807      	bhi.n	8005a66 <pvPortMalloc+0x42>
 8005a56:	429d      	cmp	r5, r3
 8005a58:	d905      	bls.n	8005a66 <pvPortMalloc+0x42>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8005a5a:	4907      	ldr	r1, [pc, #28]	; (8005a78 <pvPortMalloc+0x54>)
			xNextFreeByte += xWantedSize;
 8005a5c:	f8c2 5614 	str.w	r5, [r2, #1556]	; 0x614
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8005a60:	680c      	ldr	r4, [r1, #0]
 8005a62:	18e4      	adds	r4, r4, r3
 8005a64:	e000      	b.n	8005a68 <pvPortMalloc+0x44>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 8005a66:	2400      	movs	r4, #0
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
 8005a68:	f001 f86e 	bl	8006b48 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 8005a6c:	b90c      	cbnz	r4, 8005a72 <pvPortMalloc+0x4e>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 8005a6e:	f7fc fa2f 	bl	8001ed0 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
 8005a72:	4620      	mov	r0, r4
 8005a74:	bd38      	pop	{r3, r4, r5, pc}
 8005a76:	bf00      	nop
 8005a78:	200001bc 	.word	0x200001bc
 8005a7c:	200023ac 	.word	0x200023ac

08005a80 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8005a80:	b508      	push	{r3, lr}
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 8005a82:	b110      	cbz	r0, 8005a8a <vPortFree+0xa>
 8005a84:	f000 f844 	bl	8005b10 <ulPortSetInterruptMask>
 8005a88:	e7fe      	b.n	8005a88 <vPortFree+0x8>
 8005a8a:	bd08      	pop	{r3, pc}

08005a8c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
 8005a8c:	4b02      	ldr	r3, [pc, #8]	; (8005a98 <vPortInitialiseBlocks+0xc>)
 8005a8e:	2200      	movs	r2, #0
 8005a90:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614
 8005a94:	4770      	bx	lr
 8005a96:	bf00      	nop
 8005a98:	200023ac 	.word	0x200023ac

08005a9c <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 8005a9c:	4b03      	ldr	r3, [pc, #12]	; (8005aac <xPortGetFreeHeapSize+0x10>)
 8005a9e:	f8d3 0614 	ldr.w	r0, [r3, #1556]	; 0x614
 8005aa2:	f5c0 501f 	rsb	r0, r0, #10176	; 0x27c0
}
 8005aa6:	3038      	adds	r0, #56	; 0x38
 8005aa8:	4770      	bx	lr
 8005aaa:	bf00      	nop
 8005aac:	200023ac 	.word	0x200023ac

08005ab0 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8005ab0:	4852      	ldr	r0, [pc, #328]	; (8005bfc <xPortStartScheduler+0x30>)
 8005ab2:	6800      	ldr	r0, [r0, #0]
 8005ab4:	6800      	ldr	r0, [r0, #0]
 8005ab6:	f380 8808 	msr	MSP, r0
 8005aba:	b662      	cpsie	i
 8005abc:	df00      	svc	0
 8005abe:	bf00      	nop

08005ac0 <pxPortInitialiseStack>:
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8005ac0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8005ac4:	e900 000a 	stmdb	r0, {r1, r3}
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
 8005ac8:	2300      	movs	r3, #0
 8005aca:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8005ace:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 8005ad2:	3840      	subs	r0, #64	; 0x40
 8005ad4:	4770      	bx	lr

08005ad6 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8005ad6:	4b07      	ldr	r3, [pc, #28]	; (8005af4 <pxCurrentTCBConst2>)
 8005ad8:	6819      	ldr	r1, [r3, #0]
 8005ada:	6808      	ldr	r0, [r1, #0]
 8005adc:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005ae0:	f380 8809 	msr	PSP, r0
 8005ae4:	f04f 0000 	mov.w	r0, #0
 8005ae8:	f380 8811 	msr	BASEPRI, r0
 8005aec:	f04e 0e0d 	orr.w	lr, lr, #13
 8005af0:	4770      	bx	lr
 8005af2:	bf00      	nop

08005af4 <pxCurrentTCBConst2>:
 8005af4:	20002a44 	.word	0x20002a44

08005af8 <vPortEndScheduler>:
	return 0;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 8005af8:	4770      	bx	lr

08005afa <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005afa:	4b04      	ldr	r3, [pc, #16]	; (8005b0c <vPortYield+0x12>)
 8005afc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005b00:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 8005b02:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8005b06:	f3bf 8f6f 	isb	sy
 8005b0a:	4770      	bx	lr
 8005b0c:	e000ed04 	.word	0xe000ed04

08005b10 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
 8005b10:	f3ef 8011 	mrs	r0, BASEPRI
 8005b14:	f04f 0150 	mov.w	r1, #80	; 0x50
 8005b18:	f381 8811 	msr	BASEPRI, r1
 8005b1c:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 8005b1e:	2000      	movs	r0, #0

08005b20 <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8005b20:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 8005b22:	f7ff fff5 	bl	8005b10 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 8005b26:	4b04      	ldr	r3, [pc, #16]	; (8005b38 <vPortEnterCritical+0x18>)
 8005b28:	681a      	ldr	r2, [r3, #0]
 8005b2a:	3201      	adds	r2, #1
 8005b2c:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
 8005b2e:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8005b32:	f3bf 8f6f 	isb	sy
 8005b36:	bd08      	pop	{r3, pc}
 8005b38:	2000002c 	.word	0x2000002c

08005b3c <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
 8005b3c:	f380 8811 	msr	BASEPRI, r0
 8005b40:	4770      	bx	lr

08005b42 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 8005b42:	4b04      	ldr	r3, [pc, #16]	; (8005b54 <vPortExitCritical+0x12>)
 8005b44:	6818      	ldr	r0, [r3, #0]
 8005b46:	3801      	subs	r0, #1
 8005b48:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 8005b4a:	b908      	cbnz	r0, 8005b50 <vPortExitCritical+0xe>
	{
		portENABLE_INTERRUPTS();
 8005b4c:	f7ff bff6 	b.w	8005b3c <vPortClearInterruptMask>
 8005b50:	4770      	bx	lr
 8005b52:	bf00      	nop
 8005b54:	2000002c 	.word	0x2000002c

08005b58 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8005b58:	f3ef 8009 	mrs	r0, PSP
 8005b5c:	4b0c      	ldr	r3, [pc, #48]	; (8005b90 <pxCurrentTCBConst>)
 8005b5e:	681a      	ldr	r2, [r3, #0]
 8005b60:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005b64:	6010      	str	r0, [r2, #0]
 8005b66:	e92d 4008 	stmdb	sp!, {r3, lr}
 8005b6a:	f04f 0050 	mov.w	r0, #80	; 0x50
 8005b6e:	f380 8811 	msr	BASEPRI, r0
 8005b72:	f001 f8cf 	bl	8006d14 <vTaskSwitchContext>
 8005b76:	f04f 0000 	mov.w	r0, #0
 8005b7a:	f380 8811 	msr	BASEPRI, r0
 8005b7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8005b82:	6819      	ldr	r1, [r3, #0]
 8005b84:	6808      	ldr	r0, [r1, #0]
 8005b86:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005b8a:	f380 8809 	msr	PSP, r0
 8005b8e:	4770      	bx	lr

08005b90 <pxCurrentTCBConst>:
 8005b90:	20002a44 	.word	0x20002a44

08005b94 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8005b94:	b508      	push	{r3, lr}
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005b96:	4b06      	ldr	r3, [pc, #24]	; (8005bb0 <SysTick_Handler+0x1c>)
 8005b98:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005b9c:	601a      	str	r2, [r3, #0]
	to generate the tick interrupt. */
	#if configUSE_TICKLESS_IDLE == 1
		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
	#endif

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 8005b9e:	f7ff ffb7 	bl	8005b10 <ulPortSetInterruptMask>
	{
		vTaskIncrementTick();
 8005ba2:	f000 ff69 	bl	8006a78 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8005ba6:	2000      	movs	r0, #0
}
 8005ba8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		vTaskIncrementTick();
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8005bac:	f7ff bfc6 	b.w	8005b3c <vPortClearInterruptMask>
 8005bb0:	e000ed04 	.word	0xe000ed04

08005bb4 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = 45UL / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
 8005bb4:	4a03      	ldr	r2, [pc, #12]	; (8005bc4 <vPortSetupTimerInterrupt+0x10>)
 8005bb6:	4b04      	ldr	r3, [pc, #16]	; (8005bc8 <vPortSetupTimerInterrupt+0x14>)
 8005bb8:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 8005bba:	2207      	movs	r2, #7
 8005bbc:	f843 2c04 	str.w	r2, [r3, #-4]
 8005bc0:	4770      	bx	lr
 8005bc2:	bf00      	nop
 8005bc4:	0001193f 	.word	0x0001193f
 8005bc8:	e000e014 	.word	0xe000e014

08005bcc <xPortStartScheduler>:
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8005bcc:	4b09      	ldr	r3, [pc, #36]	; (8005bf4 <xPortStartScheduler+0x28>)

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8005bce:	b510      	push	{r4, lr}
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8005bd0:	681a      	ldr	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8005bd2:	2400      	movs	r4, #0
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8005bd4:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8005bd8:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8005bda:	681a      	ldr	r2, [r3, #0]
 8005bdc:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8005be0:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8005be2:	f7ff ffe7 	bl	8005bb4 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8005be6:	4b04      	ldr	r3, [pc, #16]	; (8005bf8 <xPortStartScheduler+0x2c>)
 8005be8:	601c      	str	r4, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8005bea:	f7ff ff61 	bl	8005ab0 <prvPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
 8005bee:	4620      	mov	r0, r4
 8005bf0:	bd10      	pop	{r4, pc}
 8005bf2:	bf00      	nop
 8005bf4:	e000ed20 	.word	0xe000ed20
 8005bf8:	2000002c 	.word	0x2000002c
 8005bfc:	e000ed08 	.word	0xe000ed08

08005c00 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
 8005c00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005c04:	4680      	mov	r8, r0
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
 8005c06:	2038      	movs	r0, #56	; 0x38
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
 8005c08:	468a      	mov	sl, r1
 8005c0a:	4691      	mov	r9, r2
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
 8005c0c:	f7ff ff0a 	bl	8005a24 <pvPortMalloc>
	if( pxCoRoutine )
 8005c10:	4604      	mov	r4, r0
 8005c12:	2800      	cmp	r0, #0
 8005c14:	d044      	beq.n	8005ca0 <xCoRoutineCreate+0xa0>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
 8005c16:	4d24      	ldr	r5, [pc, #144]	; (8005ca8 <xCoRoutineCreate+0xa8>)
 8005c18:	682b      	ldr	r3, [r5, #0]
 8005c1a:	b9c3      	cbnz	r3, 8005c4e <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
 8005c1c:	4628      	mov	r0, r5
 8005c1e:	f840 4b04 	str.w	r4, [r0], #4
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
 8005c22:	f000 f903 	bl	8005e2c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
 8005c26:	f105 062c 	add.w	r6, r5, #44	; 0x2c
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
 8005c2a:	f105 0018 	add.w	r0, r5, #24
 8005c2e:	f000 f8fd 	bl	8005e2c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
 8005c32:	f105 0740 	add.w	r7, r5, #64	; 0x40
	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
 8005c36:	4630      	mov	r0, r6
 8005c38:	f000 f8f8 	bl	8005e2c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
 8005c3c:	4638      	mov	r0, r7
 8005c3e:	f000 f8f5 	bl	8005e2c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
 8005c42:	f105 0054 	add.w	r0, r5, #84	; 0x54
 8005c46:	f000 f8f1 	bl	8005e2c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
 8005c4a:	66ae      	str	r6, [r5, #104]	; 0x68
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
 8005c4c:	66ef      	str	r7, [r5, #108]	; 0x6c

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
		pxCoRoutine->uxPriority = uxPriority;
		pxCoRoutine->uxIndex = uxIndex;
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
 8005c4e:	4625      	mov	r5, r4
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
 8005c50:	2300      	movs	r3, #0
 8005c52:	f1ba 0f01 	cmp.w	sl, #1
 8005c56:	bf34      	ite	cc
 8005c58:	4656      	movcc	r6, sl
 8005c5a:	2601      	movcs	r6, #1
		pxCoRoutine->uxPriority = uxPriority;
		pxCoRoutine->uxIndex = uxIndex;
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
 8005c5c:	f845 8b04 	str.w	r8, [r5], #4
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
 8005c60:	86a3      	strh	r3, [r4, #52]	; 0x34
		pxCoRoutine->uxPriority = uxPriority;
 8005c62:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxCoRoutine->uxIndex = uxIndex;
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
 8005c64:	4628      	mov	r0, r5
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
		pxCoRoutine->uxPriority = uxPriority;
		pxCoRoutine->uxIndex = uxIndex;
 8005c66:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
 8005c6a:	f000 f8ea 	bl	8005e42 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
 8005c6e:	f104 0018 	add.w	r0, r4, #24
 8005c72:	f000 f8e6 	bl	8005e42 <vListInitialiseItem>
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 8005c76:	4a0c      	ldr	r2, [pc, #48]	; (8005ca8 <xCoRoutineCreate+0xa8>)
 8005c78:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005c7a:	6f11      	ldr	r1, [r2, #112]	; 0x70
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8005c7c:	f1c6 0605 	rsb	r6, r6, #5

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 8005c80:	428b      	cmp	r3, r1
 8005c82:	bf88      	it	hi
 8005c84:	6713      	strhi	r3, [r2, #112]	; 0x70
 8005c86:	4a09      	ldr	r2, [pc, #36]	; (8005cac <xCoRoutineCreate+0xac>)
 8005c88:	2014      	movs	r0, #20
 8005c8a:	fb00 2003 	mla	r0, r0, r3, r2
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
 8005c8e:	6124      	str	r4, [r4, #16]
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
 8005c90:	6264      	str	r4, [r4, #36]	; 0x24

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8005c92:	61a6      	str	r6, [r4, #24]

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 8005c94:	4629      	mov	r1, r5
 8005c96:	f000 f8d7 	bl	8005e48 <vListInsertEnd>

		xReturn = pdPASS;
 8005c9a:	2001      	movs	r0, #1
 8005c9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8005ca0:	f04f 30ff 	mov.w	r0, #4294967295
	}

	return xReturn;
}
 8005ca4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005ca8:	200029c4 	.word	0x200029c4
 8005cac:	200029c8 	.word	0x200029c8

08005cb0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
 8005cb0:	b570      	push	{r4, r5, r6, lr}
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
 8005cb2:	4c0d      	ldr	r4, [pc, #52]	; (8005ce8 <vCoRoutineAddToDelayedList+0x38>)
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
 8005cb4:	460d      	mov	r5, r1
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
 8005cb6:	6f66      	ldr	r6, [r4, #116]	; 0x74
 8005cb8:	1986      	adds	r6, r0, r6

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005cba:	6820      	ldr	r0, [r4, #0]
 8005cbc:	3004      	adds	r0, #4
 8005cbe:	f000 f8e8 	bl	8005e92 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xCoRoutineTickCount )
 8005cc2:	6f63      	ldr	r3, [r4, #116]	; 0x74
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
 8005cc4:	6821      	ldr	r1, [r4, #0]

	if( xTimeToWake < xCoRoutineTickCount )
 8005cc6:	429e      	cmp	r6, r3
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005cc8:	bf34      	ite	cc
 8005cca:	6ee0      	ldrcc	r0, [r4, #108]	; 0x6c
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005ccc:	6ea0      	ldrcs	r0, [r4, #104]	; 0x68
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
 8005cce:	f841 6f04 	str.w	r6, [r1, #4]!
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005cd2:	f000 f8c6 	bl	8005e62 <vListInsert>
	}

	if( pxEventList )
 8005cd6:	b135      	cbz	r5, 8005ce6 <vCoRoutineAddToDelayedList+0x36>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
 8005cd8:	6821      	ldr	r1, [r4, #0]
 8005cda:	4628      	mov	r0, r5
 8005cdc:	3118      	adds	r1, #24
	}
}
 8005cde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
 8005ce2:	f000 b8be 	b.w	8005e62 <vListInsert>
 8005ce6:	bd70      	pop	{r4, r5, r6, pc}
 8005ce8:	200029c4 	.word	0x200029c4

08005cec <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
 8005cec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
 8005cf0:	4d41      	ldr	r5, [pc, #260]	; (8005df8 <vCoRoutineSchedule+0x10c>)
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
 8005cf2:	f04f 0814 	mov.w	r8, #20
 8005cf6:	1d2f      	adds	r7, r5, #4
 8005cf8:	e018      	b.n	8005d2c <vCoRoutineSchedule+0x40>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
 8005cfa:	f7ff ff09 	bl	8005b10 <ulPortSetInterruptMask>
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
 8005cfe:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 8005d00:	68dc      	ldr	r4, [r3, #12]
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
 8005d02:	f104 0018 	add.w	r0, r4, #24
 8005d06:	f000 f8c4 	bl	8005e92 <uxListRemove>
		}
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
 8005d0a:	1d26      	adds	r6, r4, #4
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();
 8005d0c:	2000      	movs	r0, #0
 8005d0e:	f7ff ff15 	bl	8005b3c <vPortClearInterruptMask>

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
 8005d12:	4630      	mov	r0, r6
 8005d14:	f000 f8bd 	bl	8005e92 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
 8005d18:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005d1a:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8005d1c:	4631      	mov	r1, r6
 8005d1e:	4290      	cmp	r0, r2
 8005d20:	bf88      	it	hi
 8005d22:	6728      	strhi	r0, [r5, #112]	; 0x70
 8005d24:	fb08 7000 	mla	r0, r8, r0, r7
 8005d28:	f000 f88e 	bl	8005e48 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
 8005d2c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8005d2e:	4c32      	ldr	r4, [pc, #200]	; (8005df8 <vCoRoutineSchedule+0x10c>)
 8005d30:	2b00      	cmp	r3, #0
 8005d32:	d1e2      	bne.n	8005cfa <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
 8005d34:	f000 fe82 	bl	8006a3c <xTaskGetTickCount>
 8005d38:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
					uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
 8005d3a:	1d27      	adds	r7, r4, #4

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
 8005d3c:	1ac0      	subs	r0, r0, r3
 8005d3e:	67a0      	str	r0, [r4, #120]	; 0x78
 8005d40:	e030      	b.n	8005da4 <vCoRoutineSchedule+0xb8>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
 8005d42:	6f62      	ldr	r2, [r4, #116]	; 0x74
		xPassedTicks--;
 8005d44:	3b01      	subs	r3, #1
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
 8005d46:	3201      	adds	r2, #1
 8005d48:	6762      	str	r2, [r4, #116]	; 0x74
		xPassedTicks--;
 8005d4a:	67a3      	str	r3, [r4, #120]	; 0x78

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
 8005d4c:	bb22      	cbnz	r2, 8005d98 <vCoRoutineSchedule+0xac>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
 8005d4e:	6ea2      	ldr	r2, [r4, #104]	; 0x68
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
 8005d50:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
			pxOverflowDelayedCoRoutineList = pxTemp;
 8005d52:	66e2      	str	r2, [r4, #108]	; 0x6c
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
 8005d54:	66a3      	str	r3, [r4, #104]	; 0x68
 8005d56:	e01f      	b.n	8005d98 <vCoRoutineSchedule+0xac>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
 8005d58:	68db      	ldr	r3, [r3, #12]

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
 8005d5a:	6f62      	ldr	r2, [r4, #116]	; 0x74
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
 8005d5c:	68dd      	ldr	r5, [r3, #12]

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
 8005d5e:	686b      	ldr	r3, [r5, #4]
 8005d60:	429a      	cmp	r2, r3
 8005d62:	d31f      	bcc.n	8005da4 <vCoRoutineSchedule+0xb8>
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
 8005d64:	1d2e      	adds	r6, r5, #4
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
 8005d66:	f7ff fed3 	bl	8005b10 <ulPortSetInterruptMask>
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
 8005d6a:	4630      	mov	r0, r6
 8005d6c:	f000 f891 	bl	8005e92 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
 8005d70:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8005d72:	b11b      	cbz	r3, 8005d7c <vCoRoutineSchedule+0x90>
				{
					uxListRemove( &( pxCRCB->xEventListItem ) );
 8005d74:	f105 0018 	add.w	r0, r5, #24
 8005d78:	f000 f88b 	bl	8005e92 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
 8005d7c:	2000      	movs	r0, #0
 8005d7e:	f7ff fedd 	bl	8005b3c <vPortClearInterruptMask>

			prvAddCoRoutineToReadyQueue( pxCRCB );
 8005d82:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8005d84:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8005d86:	4631      	mov	r1, r6
 8005d88:	4290      	cmp	r0, r2
 8005d8a:	bf88      	it	hi
 8005d8c:	6720      	strhi	r0, [r4, #112]	; 0x70
 8005d8e:	fb08 7000 	mla	r0, r8, r0, r7
 8005d92:	f000 f859 	bl	8005e48 <vListInsertEnd>
 8005d96:	e001      	b.n	8005d9c <vCoRoutineSchedule+0xb0>
 8005d98:	f04f 0814 	mov.w	r8, #20
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
 8005d9c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8005d9e:	681a      	ldr	r2, [r3, #0]
 8005da0:	2a00      	cmp	r2, #0
 8005da2:	d1d9      	bne.n	8005d58 <vCoRoutineSchedule+0x6c>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
 8005da4:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005da6:	4a14      	ldr	r2, [pc, #80]	; (8005df8 <vCoRoutineSchedule+0x10c>)
 8005da8:	2b00      	cmp	r3, #0
 8005daa:	d1ca      	bne.n	8005d42 <vCoRoutineSchedule+0x56>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
 8005dac:	6f53      	ldr	r3, [r2, #116]	; 0x74

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
 8005dae:	2514      	movs	r5, #20

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
 8005db0:	67d3      	str	r3, [r2, #124]	; 0x7c
 8005db2:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8005db4:	e004      	b.n	8005dc0 <vCoRoutineSchedule+0xd4>
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
 8005db6:	b913      	cbnz	r3, 8005dbe <vCoRoutineSchedule+0xd2>
 8005db8:	670b      	str	r3, [r1, #112]	; 0x70
 8005dba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
 8005dbe:	3b01      	subs	r3, #1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
 8005dc0:	fb05 f003 	mul.w	r0, r5, r3
 8005dc4:	1814      	adds	r4, r2, r0
 8005dc6:	6864      	ldr	r4, [r4, #4]
 8005dc8:	490b      	ldr	r1, [pc, #44]	; (8005df8 <vCoRoutineSchedule+0x10c>)
 8005dca:	2c00      	cmp	r4, #0
 8005dcc:	d0f3      	beq.n	8005db6 <vCoRoutineSchedule+0xca>
 8005dce:	670b      	str	r3, [r1, #112]	; 0x70
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
 8005dd0:	1d0b      	adds	r3, r1, #4
 8005dd2:	181b      	adds	r3, r3, r0
 8005dd4:	685a      	ldr	r2, [r3, #4]
 8005dd6:	f103 0108 	add.w	r1, r3, #8
 8005dda:	6852      	ldr	r2, [r2, #4]
 8005ddc:	428a      	cmp	r2, r1
 8005dde:	605a      	str	r2, [r3, #4]
 8005de0:	bf04      	itt	eq
 8005de2:	6852      	ldreq	r2, [r2, #4]
 8005de4:	605a      	streq	r2, [r3, #4]
 8005de6:	685b      	ldr	r3, [r3, #4]
 8005de8:	68d8      	ldr	r0, [r3, #12]
 8005dea:	4b03      	ldr	r3, [pc, #12]	; (8005df8 <vCoRoutineSchedule+0x10c>)

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
 8005dec:	6b01      	ldr	r1, [r0, #48]	; 0x30
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
 8005dee:	6018      	str	r0, [r3, #0]

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
 8005df0:	6803      	ldr	r3, [r0, #0]
 8005df2:	4798      	blx	r3
 8005df4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005df8:	200029c4 	.word	0x200029c4

08005dfc <xCoRoutineRemoveFromEventList>:
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8005dfc:	68c3      	ldr	r3, [r0, #12]
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
 8005dfe:	b570      	push	{r4, r5, r6, lr}
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8005e00:	68dc      	ldr	r4, [r3, #12]
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
 8005e02:	4d09      	ldr	r5, [pc, #36]	; (8005e28 <xCoRoutineRemoveFromEventList+0x2c>)

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
 8005e04:	f104 0618 	add.w	r6, r4, #24
 8005e08:	4630      	mov	r0, r6
 8005e0a:	f000 f842 	bl	8005e92 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
 8005e0e:	f105 0054 	add.w	r0, r5, #84	; 0x54
 8005e12:	4631      	mov	r1, r6
 8005e14:	f000 f818 	bl	8005e48 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
 8005e18:	682b      	ldr	r3, [r5, #0]
 8005e1a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005e1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8005e1e:	4298      	cmp	r0, r3
 8005e20:	bf34      	ite	cc
 8005e22:	2000      	movcc	r0, #0
 8005e24:	2001      	movcs	r0, #1
 8005e26:	bd70      	pop	{r4, r5, r6, pc}
 8005e28:	200029c4 	.word	0x200029c4

08005e2c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8005e2c:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005e30:	f04f 32ff 	mov.w	r2, #4294967295
 8005e34:	6082      	str	r2, [r0, #8]
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8005e36:	6043      	str	r3, [r0, #4]
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8005e38:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8005e3a:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8005e3c:	2300      	movs	r3, #0
 8005e3e:	6003      	str	r3, [r0, #0]
 8005e40:	4770      	bx	lr

08005e42 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8005e42:	2300      	movs	r3, #0
 8005e44:	6103      	str	r3, [r0, #16]
 8005e46:	4770      	bx	lr

08005e48 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8005e48:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8005e4a:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8005e4c:	608b      	str	r3, [r1, #8]
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex->pxNext;
 8005e4e:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8005e50:	685a      	ldr	r2, [r3, #4]
 8005e52:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8005e54:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005e56:	6803      	ldr	r3, [r0, #0]

	pxNewListItem->pxNext = pxIndex->pxNext;
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8005e58:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005e5a:	3301      	adds	r3, #1
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8005e5c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8005e5e:	6003      	str	r3, [r0, #0]
 8005e60:	4770      	bx	lr

08005e62 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8005e62:	680a      	ldr	r2, [r1, #0]
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 8005e64:	b510      	push	{r4, lr}
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8005e66:	1c53      	adds	r3, r2, #1
 8005e68:	d101      	bne.n	8005e6e <vListInsert+0xc>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8005e6a:	6903      	ldr	r3, [r0, #16]
 8005e6c:	e007      	b.n	8005e7e <vListInsert+0x1c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8005e6e:	f100 0308 	add.w	r3, r0, #8
 8005e72:	e000      	b.n	8005e76 <vListInsert+0x14>
 8005e74:	685b      	ldr	r3, [r3, #4]
 8005e76:	685c      	ldr	r4, [r3, #4]
 8005e78:	6824      	ldr	r4, [r4, #0]
 8005e7a:	4294      	cmp	r4, r2
 8005e7c:	d9fa      	bls.n	8005e74 <vListInsert+0x12>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8005e7e:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8005e80:	6108      	str	r0, [r1, #16]
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8005e82:	6091      	str	r1, [r2, #8]
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8005e84:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8005e86:	6059      	str	r1, [r3, #4]
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
 8005e88:	608b      	str	r3, [r1, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005e8a:	6803      	ldr	r3, [r0, #0]
 8005e8c:	3301      	adds	r3, #1
 8005e8e:	6003      	str	r3, [r0, #0]
 8005e90:	bd10      	pop	{r4, pc}

08005e92 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8005e92:	6843      	ldr	r3, [r0, #4]
 8005e94:	6882      	ldr	r2, [r0, #8]
 8005e96:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8005e98:	6882      	ldr	r2, [r0, #8]
 8005e9a:	6053      	str	r3, [r2, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8005e9c:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8005e9e:	6859      	ldr	r1, [r3, #4]
 8005ea0:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8005ea2:	bf08      	it	eq
 8005ea4:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8005ea6:	2200      	movs	r2, #0
 8005ea8:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8005eaa:	681a      	ldr	r2, [r3, #0]
 8005eac:	3a01      	subs	r2, #1
 8005eae:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8005eb0:	6818      	ldr	r0, [r3, #0]
}
 8005eb2:	4770      	bx	lr

08005eb4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
 8005eb4:	b538      	push	{r3, r4, r5, lr}
 8005eb6:	4604      	mov	r4, r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005eb8:	f104 0524 	add.w	r5, r4, #36	; 0x24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8005ebc:	f7ff fe30 	bl	8005b20 <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8005ec0:	e00a      	b.n	8005ed8 <prvUnlockQueue+0x24>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005ec2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005ec4:	b15b      	cbz	r3, 8005ede <prvUnlockQueue+0x2a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005ec6:	4628      	mov	r0, r5
 8005ec8:	f000 ffe6 	bl	8006e98 <xTaskRemoveFromEventList>
 8005ecc:	b108      	cbz	r0, 8005ed2 <prvUnlockQueue+0x1e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 8005ece:	f001 f855 	bl	8006f7c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8005ed2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005ed4:	3b01      	subs	r3, #1
 8005ed6:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8005ed8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005eda:	2b00      	cmp	r3, #0
 8005edc:	dcf1      	bgt.n	8005ec2 <prvUnlockQueue+0xe>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8005ede:	f04f 33ff 	mov.w	r3, #4294967295
 8005ee2:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8005ee4:	f7ff fe2d 	bl	8005b42 <vPortExitCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005ee8:	f104 0510 	add.w	r5, r4, #16
		pxQueue->xTxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8005eec:	f7ff fe18 	bl	8005b20 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8005ef0:	e00a      	b.n	8005f08 <prvUnlockQueue+0x54>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005ef2:	6923      	ldr	r3, [r4, #16]
 8005ef4:	b15b      	cbz	r3, 8005f0e <prvUnlockQueue+0x5a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005ef6:	4628      	mov	r0, r5
 8005ef8:	f000 ffce 	bl	8006e98 <xTaskRemoveFromEventList>
 8005efc:	b108      	cbz	r0, 8005f02 <prvUnlockQueue+0x4e>
				{
					vTaskMissedYield();
 8005efe:	f001 f83d 	bl	8006f7c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 8005f02:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005f04:	3b01      	subs	r3, #1
 8005f06:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8005f08:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005f0a:	2b00      	cmp	r3, #0
 8005f0c:	dcf1      	bgt.n	8005ef2 <prvUnlockQueue+0x3e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8005f0e:	f04f 33ff 	mov.w	r3, #4294967295
 8005f12:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8005f14:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 8005f18:	f7ff be13 	b.w	8005b42 <vPortExitCritical>

08005f1c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 8005f1c:	b570      	push	{r4, r5, r6, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8005f1e:	6804      	ldr	r4, [r0, #0]
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 8005f20:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8005f22:	b16c      	cbz	r4, 8005f40 <prvCopyDataFromQueue+0x24>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8005f24:	68c5      	ldr	r5, [r0, #12]
 8005f26:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 8005f28:	6846      	ldr	r6, [r0, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8005f2a:	18ad      	adds	r5, r5, r2
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 8005f2c:	42b5      	cmp	r5, r6

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8005f2e:	60c5      	str	r5, [r0, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
 8005f30:	bf28      	it	cs
 8005f32:	60c4      	strcs	r4, [r0, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8005f34:	4608      	mov	r0, r1
 8005f36:	68d9      	ldr	r1, [r3, #12]
	}
}
 8005f38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8005f3c:	f002 b84a 	b.w	8007fd4 <memcpy>
 8005f40:	bd70      	pop	{r4, r5, r6, pc}

08005f42 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8005f42:	b538      	push	{r3, r4, r5, lr}
 8005f44:	4613      	mov	r3, r2
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8005f46:	6c02      	ldr	r2, [r0, #64]	; 0x40

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8005f48:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8005f4a:	b932      	cbnz	r2, 8005f5a <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005f4c:	6805      	ldr	r5, [r0, #0]
 8005f4e:	bb05      	cbnz	r5, 8005f92 <prvCopyDataToQueue+0x50>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8005f50:	6840      	ldr	r0, [r0, #4]
 8005f52:	f001 f865 	bl	8007020 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8005f56:	6065      	str	r5, [r4, #4]
 8005f58:	e01b      	b.n	8005f92 <prvCopyDataToQueue+0x50>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
 8005f5a:	b963      	cbnz	r3, 8005f76 <prvCopyDataToQueue+0x34>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8005f5c:	6880      	ldr	r0, [r0, #8]
 8005f5e:	f002 f839 	bl	8007fd4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005f62:	68a2      	ldr	r2, [r4, #8]
 8005f64:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005f66:	18d3      	adds	r3, r2, r3
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8005f68:	6862      	ldr	r2, [r4, #4]
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005f6a:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8005f6c:	4293      	cmp	r3, r2
 8005f6e:	d310      	bcc.n	8005f92 <prvCopyDataToQueue+0x50>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8005f70:	6823      	ldr	r3, [r4, #0]
 8005f72:	60a3      	str	r3, [r4, #8]
 8005f74:	e00d      	b.n	8005f92 <prvCopyDataToQueue+0x50>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8005f76:	68c0      	ldr	r0, [r0, #12]
 8005f78:	f002 f82c 	bl	8007fd4 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8005f7c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005f7e:	68e2      	ldr	r2, [r4, #12]
 8005f80:	425b      	negs	r3, r3
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8005f82:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8005f84:	18d2      	adds	r2, r2, r3
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8005f86:	428a      	cmp	r2, r1
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8005f88:	60e2      	str	r2, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8005f8a:	d202      	bcs.n	8005f92 <prvCopyDataToQueue+0x50>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8005f8c:	6862      	ldr	r2, [r4, #4]
 8005f8e:	18d3      	adds	r3, r2, r3
 8005f90:	60e3      	str	r3, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8005f92:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005f94:	3301      	adds	r3, #1
 8005f96:	63a3      	str	r3, [r4, #56]	; 0x38
 8005f98:	bd38      	pop	{r3, r4, r5, pc}

08005f9a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
 8005f9a:	b538      	push	{r3, r4, r5, lr}
 8005f9c:	460d      	mov	r5, r1
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 8005f9e:	4604      	mov	r4, r0
 8005fa0:	b910      	cbnz	r0, 8005fa8 <xQueueGenericReset+0xe>
 8005fa2:	f7ff fdb5 	bl	8005b10 <ulPortSetInterruptMask>
 8005fa6:	e7fe      	b.n	8005fa6 <xQueueGenericReset+0xc>

	taskENTER_CRITICAL();
 8005fa8:	f7ff fdba 	bl	8005b20 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005fac:	6823      	ldr	r3, [r4, #0]
 8005fae:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8005fb0:	6c22      	ldr	r2, [r4, #64]	; 0x40
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8005fb2:	60a3      	str	r3, [r4, #8]
	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005fb4:	fb00 3102 	mla	r1, r0, r2, r3
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005fb8:	3801      	subs	r0, #1
 8005fba:	fb02 3300 	mla	r3, r2, r0, r3
	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005fbe:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005fc0:	60e3      	str	r3, [r4, #12]
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8005fc2:	2100      	movs	r1, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8005fc4:	f04f 33ff 	mov.w	r3, #4294967295
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8005fc8:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8005fca:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 8005fcc:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 8005fce:	b955      	cbnz	r5, 8005fe6 <xQueueGenericReset+0x4c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005fd0:	6923      	ldr	r3, [r4, #16]
 8005fd2:	b183      	cbz	r3, 8005ff6 <xQueueGenericReset+0x5c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8005fd4:	f104 0010 	add.w	r0, r4, #16
 8005fd8:	f000 ff5e 	bl	8006e98 <xTaskRemoveFromEventList>
 8005fdc:	2801      	cmp	r0, #1
 8005fde:	d10a      	bne.n	8005ff6 <xQueueGenericReset+0x5c>
				{
					portYIELD_WITHIN_API();
 8005fe0:	f7ff fd8b 	bl	8005afa <vPortYield>
 8005fe4:	e007      	b.n	8005ff6 <xQueueGenericReset+0x5c>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8005fe6:	f104 0010 	add.w	r0, r4, #16
 8005fea:	f7ff ff1f 	bl	8005e2c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8005fee:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005ff2:	f7ff ff1b 	bl	8005e2c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8005ff6:	f7ff fda4 	bl	8005b42 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 8005ffa:	2001      	movs	r0, #1
 8005ffc:	bd38      	pop	{r3, r4, r5, pc}

08005ffe <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
 8005ffe:	b570      	push	{r4, r5, r6, lr}
 8006000:	460e      	mov	r6, r1
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 8006002:	4605      	mov	r5, r0
 8006004:	b180      	cbz	r0, 8006028 <xQueueGenericCreate+0x2a>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8006006:	204c      	movs	r0, #76	; 0x4c
 8006008:	f7ff fd0c 	bl	8005a24 <pvPortMalloc>
		if( pxNewQueue != NULL )
 800600c:	4604      	mov	r4, r0
 800600e:	b158      	cbz	r0, 8006028 <xQueueGenericCreate+0x2a>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 8006010:	fb05 f006 	mul.w	r0, r5, r6

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 8006014:	3001      	adds	r0, #1
 8006016:	f7ff fd05 	bl	8005a24 <pvPortMalloc>
 800601a:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
 800601c:	b938      	cbnz	r0, 800602e <xQueueGenericCreate+0x30>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
 800601e:	4620      	mov	r0, r4
 8006020:	f7ff fd2e 	bl	8005a80 <vPortFree>
 8006024:	e000      	b.n	8006028 <xQueueGenericCreate+0x2a>
 8006026:	e7fe      	b.n	8006026 <xQueueGenericCreate+0x28>
			}
		}
	}

	configASSERT( xReturn );
 8006028:	f7ff fd72 	bl	8005b10 <ulPortSetInterruptMask>
 800602c:	e7fb      	b.n	8006026 <xQueueGenericCreate+0x28>
			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
			if( pxNewQueue->pcHead != NULL )
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
 800602e:	63e5      	str	r5, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 8006030:	6426      	str	r6, [r4, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
 8006032:	4620      	mov	r0, r4
 8006034:	2101      	movs	r1, #1
 8006036:	f7ff ffb0 	bl	8005f9a <xQueueGenericReset>
	}

	configASSERT( xReturn );

	return xReturn;
}
 800603a:	4620      	mov	r0, r4
 800603c:	bd70      	pop	{r4, r5, r6, pc}

0800603e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 800603e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006042:	b085      	sub	sp, #20
 8006044:	460d      	mov	r5, r1
 8006046:	9201      	str	r2, [sp, #4]
 8006048:	4699      	mov	r9, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 800604a:	4604      	mov	r4, r0
 800604c:	b910      	cbnz	r0, 8006054 <xQueueGenericSend+0x16>
 800604e:	f7ff fd5f 	bl	8005b10 <ulPortSetInterruptMask>
 8006052:	e7fe      	b.n	8006052 <xQueueGenericSend+0x14>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8006054:	b929      	cbnz	r1, 8006062 <xQueueGenericSend+0x24>
 8006056:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006058:	b12b      	cbz	r3, 8006066 <xQueueGenericSend+0x28>
 800605a:	e065      	b.n	8006128 <xQueueGenericSend+0xea>
 800605c:	e7fe      	b.n	800605c <xQueueGenericSend+0x1e>
 800605e:	2601      	movs	r6, #1
 8006060:	e003      	b.n	800606a <xQueueGenericSend+0x2c>
 8006062:	2600      	movs	r6, #0
 8006064:	e000      	b.n	8006068 <xQueueGenericSend+0x2a>
 8006066:	460e      	mov	r6, r1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8006068:	2700      	movs	r7, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800606a:	f7ff fd59 	bl	8005b20 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800606e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8006070:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8006072:	429a      	cmp	r2, r3
 8006074:	d212      	bcs.n	800609c <xQueueGenericSend+0x5e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8006076:	4620      	mov	r0, r4
 8006078:	4629      	mov	r1, r5
 800607a:	464a      	mov	r2, r9
 800607c:	f7ff ff61 	bl	8005f42 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8006080:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006082:	b13b      	cbz	r3, 8006094 <xQueueGenericSend+0x56>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 8006084:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006088:	f000 ff06 	bl	8006e98 <xTaskRemoveFromEventList>
 800608c:	2801      	cmp	r0, #1
 800608e:	d101      	bne.n	8006094 <xQueueGenericSend+0x56>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
 8006090:	f7ff fd33 	bl	8005afa <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8006094:	f7ff fd55 	bl	8005b42 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 8006098:	2001      	movs	r0, #1
 800609a:	e048      	b.n	800612e <xQueueGenericSend+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 800609c:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80060a0:	f1b8 0f00 	cmp.w	r8, #0
 80060a4:	d102      	bne.n	80060ac <xQueueGenericSend+0x6e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 80060a6:	f7ff fd4c 	bl	8005b42 <vPortExitCritical>
 80060aa:	e03b      	b.n	8006124 <xQueueGenericSend+0xe6>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 80060ac:	b916      	cbnz	r6, 80060b4 <xQueueGenericSend+0x76>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 80060ae:	a802      	add	r0, sp, #8
 80060b0:	f000 ff24 	bl	8006efc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
 80060b4:	f7ff fd45 	bl	8005b42 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 80060b8:	f000 fcb6 	bl	8006a28 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80060bc:	f7ff fd30 	bl	8005b20 <vPortEnterCritical>
 80060c0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80060c2:	3301      	adds	r3, #1
 80060c4:	bf08      	it	eq
 80060c6:	6467      	streq	r7, [r4, #68]	; 0x44
 80060c8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80060ca:	3301      	adds	r3, #1
 80060cc:	bf08      	it	eq
 80060ce:	64a7      	streq	r7, [r4, #72]	; 0x48
 80060d0:	f7ff fd37 	bl	8005b42 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80060d4:	a802      	add	r0, sp, #8
 80060d6:	a901      	add	r1, sp, #4
 80060d8:	f000 ff1e 	bl	8006f18 <xTaskCheckForTimeOut>
 80060dc:	b9e8      	cbnz	r0, 800611a <xQueueGenericSend+0xdc>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 80060de:	f7ff fd1f 	bl	8005b20 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80060e2:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
 80060e6:	6be6      	ldr	r6, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80060e8:	f7ff fd2b 	bl	8005b42 <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 80060ec:	45b0      	cmp	r8, r6
 80060ee:	d10e      	bne.n	800610e <xQueueGenericSend+0xd0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80060f0:	f104 0010 	add.w	r0, r4, #16
 80060f4:	9901      	ldr	r1, [sp, #4]
 80060f6:	f000 fe95 	bl	8006e24 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 80060fa:	4620      	mov	r0, r4
 80060fc:	f7ff feda 	bl	8005eb4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 8006100:	f000 fd22 	bl	8006b48 <xTaskResumeAll>
 8006104:	2800      	cmp	r0, #0
 8006106:	d1aa      	bne.n	800605e <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
 8006108:	f7ff fcf7 	bl	8005afa <vPortYield>
 800610c:	e7a7      	b.n	800605e <xQueueGenericSend+0x20>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800610e:	4620      	mov	r0, r4
 8006110:	f7ff fed0 	bl	8005eb4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8006114:	f000 fd18 	bl	8006b48 <xTaskResumeAll>
 8006118:	e7a1      	b.n	800605e <xQueueGenericSend+0x20>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 800611a:	4620      	mov	r0, r4
 800611c:	f7ff feca 	bl	8005eb4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8006120:	f000 fd12 	bl	8006b48 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8006124:	2000      	movs	r0, #0
 8006126:	e002      	b.n	800612e <xQueueGenericSend+0xf0>
xTimeOutType xTimeOut;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8006128:	f7ff fcf2 	bl	8005b10 <ulPortSetInterruptMask>
 800612c:	e796      	b.n	800605c <xQueueGenericSend+0x1e>
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 800612e:	b005      	add	sp, #20
 8006130:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08006134 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
 8006134:	b538      	push	{r3, r4, r5, lr}
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8006136:	204c      	movs	r0, #76	; 0x4c
 8006138:	f7ff fc74 	bl	8005a24 <pvPortMalloc>
		if( pxNewQueue != NULL )
 800613c:	4604      	mov	r4, r0
 800613e:	b108      	cbz	r0, 8006144 <xQueueCreateMutex+0x10>
 8006140:	e003      	b.n	800614a <xQueueCreateMutex+0x16>
 8006142:	e7fe      	b.n	8006142 <xQueueCreateMutex+0xe>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
 8006144:	f7ff fce4 	bl	8005b10 <ulPortSetInterruptMask>
 8006148:	e7fb      	b.n	8006142 <xQueueCreateMutex+0xe>

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 800614a:	2301      	movs	r3, #1
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 800614c:	2500      	movs	r5, #0

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 800614e:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 8006150:	f04f 33ff 	mov.w	r3, #4294967295
			pxNewQueue->pcReadFrom = NULL;

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8006154:	6385      	str	r5, [r0, #56]	; 0x38
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8006156:	6045      	str	r5, [r0, #4]
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 8006158:	6443      	str	r3, [r0, #68]	; 0x44
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800615a:	6005      	str	r5, [r0, #0]
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
			pxNewQueue->xTxLock = queueUNLOCKED;
 800615c:	6483      	str	r3, [r0, #72]	; 0x48
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 800615e:	6085      	str	r5, [r0, #8]
			pxNewQueue->pcReadFrom = NULL;
 8006160:	60c5      	str	r5, [r0, #12]
			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 8006162:	6405      	str	r5, [r0, #64]	; 0x40
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 8006164:	3010      	adds	r0, #16
 8006166:	f7ff fe61 	bl	8005e2c <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 800616a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800616e:	f7ff fe5d 	bl	8005e2c <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 8006172:	4620      	mov	r0, r4
 8006174:	4629      	mov	r1, r5
 8006176:	462a      	mov	r2, r5
 8006178:	462b      	mov	r3, r5
 800617a:	f7ff ff60 	bl	800603e <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
 800617e:	4620      	mov	r0, r4
 8006180:	bd38      	pop	{r3, r4, r5, pc}

08006182 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 8006182:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006186:	460e      	mov	r6, r1
 8006188:	4615      	mov	r5, r2
 800618a:	4698      	mov	r8, r3
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 800618c:	4604      	mov	r4, r0
 800618e:	b910      	cbnz	r0, 8006196 <xQueueGenericSendFromISR+0x14>
 8006190:	f7ff fcbe 	bl	8005b10 <ulPortSetInterruptMask>
 8006194:	e7fe      	b.n	8006194 <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8006196:	b9f9      	cbnz	r1, 80061d8 <xQueueGenericSendFromISR+0x56>
 8006198:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800619a:	b1e9      	cbz	r1, 80061d8 <xQueueGenericSendFromISR+0x56>
 800619c:	e019      	b.n	80061d2 <xQueueGenericSendFromISR+0x50>
 800619e:	e7fe      	b.n	800619e <xQueueGenericSendFromISR+0x1c>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80061a0:	4620      	mov	r0, r4
 80061a2:	4631      	mov	r1, r6
 80061a4:	4642      	mov	r2, r8
 80061a6:	f7ff fecc 	bl	8005f42 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 80061aa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80061ac:	3301      	adds	r3, #1
 80061ae:	d10b      	bne.n	80061c8 <xQueueGenericSendFromISR+0x46>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80061b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80061b2:	b903      	cbnz	r3, 80061b6 <xQueueGenericSendFromISR+0x34>
 80061b4:	e00b      	b.n	80061ce <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80061b6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80061ba:	f000 fe6d 	bl	8006e98 <xTaskRemoveFromEventList>
 80061be:	b130      	cbz	r0, 80061ce <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 80061c0:	b12d      	cbz	r5, 80061ce <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 80061c2:	2401      	movs	r4, #1
 80061c4:	602c      	str	r4, [r5, #0]
 80061c6:	e00f      	b.n	80061e8 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 80061c8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80061ca:	3301      	adds	r3, #1
 80061cc:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 80061ce:	2401      	movs	r4, #1
 80061d0:	e00a      	b.n	80061e8 <xQueueGenericSendFromISR+0x66>
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 80061d2:	f7ff fc9d 	bl	8005b10 <ulPortSetInterruptMask>
 80061d6:	e7e2      	b.n	800619e <xQueueGenericSendFromISR+0x1c>
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80061d8:	f7ff fc9a 	bl	8005b10 <ulPortSetInterruptMask>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 80061dc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80061de:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80061e0:	4607      	mov	r7, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 80061e2:	428b      	cmp	r3, r1
 80061e4:	d3dc      	bcc.n	80061a0 <xQueueGenericSendFromISR+0x1e>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 80061e6:	2400      	movs	r4, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80061e8:	4638      	mov	r0, r7
 80061ea:	f7ff fca7 	bl	8005b3c <vPortClearInterruptMask>

	return xReturn;
}
 80061ee:	4620      	mov	r0, r4
 80061f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080061f4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 80061f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80061f8:	b085      	sub	sp, #20
 80061fa:	460d      	mov	r5, r1
 80061fc:	9201      	str	r2, [sp, #4]
 80061fe:	4699      	mov	r9, r3
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 8006200:	4604      	mov	r4, r0
 8006202:	b910      	cbnz	r0, 800620a <xQueueGenericReceive+0x16>
 8006204:	f7ff fc84 	bl	8005b10 <ulPortSetInterruptMask>
 8006208:	e7fe      	b.n	8006208 <xQueueGenericReceive+0x14>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800620a:	b929      	cbnz	r1, 8006218 <xQueueGenericReceive+0x24>
 800620c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800620e:	b12b      	cbz	r3, 800621c <xQueueGenericReceive+0x28>
 8006210:	e07e      	b.n	8006310 <xQueueGenericReceive+0x11c>
 8006212:	e7fe      	b.n	8006212 <xQueueGenericReceive+0x1e>
 8006214:	2601      	movs	r6, #1
 8006216:	e003      	b.n	8006220 <xQueueGenericReceive+0x2c>
 8006218:	2600      	movs	r6, #0
 800621a:	e000      	b.n	800621e <xQueueGenericReceive+0x2a>
 800621c:	460e      	mov	r6, r1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 800621e:	2700      	movs	r7, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8006220:	f7ff fc7e 	bl	8005b20 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006224:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006226:	b33b      	cbz	r3, 8006278 <xQueueGenericReceive+0x84>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8006228:	4620      	mov	r0, r4
 800622a:	4629      	mov	r1, r5
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
 800622c:	68e6      	ldr	r6, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800622e:	f7ff fe75 	bl	8005f1c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8006232:	f1b9 0f00 	cmp.w	r9, #0
 8006236:	d112      	bne.n	800625e <xQueueGenericReceive+0x6a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
 8006238:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800623a:	3b01      	subs	r3, #1
 800623c:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800623e:	6823      	ldr	r3, [r4, #0]
 8006240:	b913      	cbnz	r3, 8006248 <xQueueGenericReceive+0x54>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 8006242:	f000 fea3 	bl	8006f8c <xTaskGetCurrentTaskHandle>
 8006246:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8006248:	6923      	ldr	r3, [r4, #16]
 800624a:	b18b      	cbz	r3, 8006270 <xQueueGenericReceive+0x7c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 800624c:	f104 0010 	add.w	r0, r4, #16
 8006250:	f000 fe22 	bl	8006e98 <xTaskRemoveFromEventList>
 8006254:	2801      	cmp	r0, #1
 8006256:	d10b      	bne.n	8006270 <xQueueGenericReceive+0x7c>
						{
							portYIELD_WITHIN_API();
 8006258:	f7ff fc4f 	bl	8005afa <vPortYield>
 800625c:	e008      	b.n	8006270 <xQueueGenericReceive+0x7c>
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800625e:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
 8006260:	60e6      	str	r6, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8006262:	b12b      	cbz	r3, 8006270 <xQueueGenericReceive+0x7c>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8006264:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006268:	f000 fe16 	bl	8006e98 <xTaskRemoveFromEventList>
 800626c:	2800      	cmp	r0, #0
 800626e:	d1f3      	bne.n	8006258 <xQueueGenericReceive+0x64>
							portYIELD_WITHIN_API();
						}
					}
				}

				taskEXIT_CRITICAL();
 8006270:	f7ff fc67 	bl	8005b42 <vPortExitCritical>
				return pdPASS;
 8006274:	2001      	movs	r0, #1
 8006276:	e04e      	b.n	8006316 <xQueueGenericReceive+0x122>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8006278:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800627c:	f1b8 0f00 	cmp.w	r8, #0
 8006280:	d102      	bne.n	8006288 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8006282:	f7ff fc5e 	bl	8005b42 <vPortExitCritical>
 8006286:	e041      	b.n	800630c <xQueueGenericReceive+0x118>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 8006288:	b916      	cbnz	r6, 8006290 <xQueueGenericReceive+0x9c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800628a:	a802      	add	r0, sp, #8
 800628c:	f000 fe36 	bl	8006efc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
 8006290:	f7ff fc57 	bl	8005b42 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8006294:	f000 fbc8 	bl	8006a28 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8006298:	f7ff fc42 	bl	8005b20 <vPortEnterCritical>
 800629c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800629e:	3301      	adds	r3, #1
 80062a0:	bf08      	it	eq
 80062a2:	6467      	streq	r7, [r4, #68]	; 0x44
 80062a4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80062a6:	3301      	adds	r3, #1
 80062a8:	bf08      	it	eq
 80062aa:	64a7      	streq	r7, [r4, #72]	; 0x48
 80062ac:	f7ff fc49 	bl	8005b42 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80062b0:	a802      	add	r0, sp, #8
 80062b2:	a901      	add	r1, sp, #4
 80062b4:	f000 fe30 	bl	8006f18 <xTaskCheckForTimeOut>
 80062b8:	bb18      	cbnz	r0, 8006302 <xQueueGenericReceive+0x10e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 80062ba:	f7ff fc31 	bl	8005b20 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == 0 )
 80062be:	6ba6      	ldr	r6, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80062c0:	f7ff fc3f 	bl	8005b42 <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80062c4:	b9be      	cbnz	r6, 80062f6 <xQueueGenericReceive+0x102>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80062c6:	6823      	ldr	r3, [r4, #0]
 80062c8:	b933      	cbnz	r3, 80062d8 <xQueueGenericReceive+0xe4>
					{
						portENTER_CRITICAL();
 80062ca:	f7ff fc29 	bl	8005b20 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 80062ce:	6860      	ldr	r0, [r4, #4]
 80062d0:	f000 fe70 	bl	8006fb4 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 80062d4:	f7ff fc35 	bl	8005b42 <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80062d8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80062dc:	9901      	ldr	r1, [sp, #4]
 80062de:	f000 fda1 	bl	8006e24 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80062e2:	4620      	mov	r0, r4
 80062e4:	f7ff fde6 	bl	8005eb4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80062e8:	f000 fc2e 	bl	8006b48 <xTaskResumeAll>
 80062ec:	2800      	cmp	r0, #0
 80062ee:	d191      	bne.n	8006214 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
 80062f0:	f7ff fc03 	bl	8005afa <vPortYield>
 80062f4:	e78e      	b.n	8006214 <xQueueGenericReceive+0x20>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80062f6:	4620      	mov	r0, r4
 80062f8:	f7ff fddc 	bl	8005eb4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80062fc:	f000 fc24 	bl	8006b48 <xTaskResumeAll>
 8006300:	e788      	b.n	8006214 <xQueueGenericReceive+0x20>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8006302:	4620      	mov	r0, r4
 8006304:	f7ff fdd6 	bl	8005eb4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8006308:	f000 fc1e 	bl	8006b48 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 800630c:	2000      	movs	r0, #0
 800630e:	e002      	b.n	8006316 <xQueueGenericReceive+0x122>
signed char *pcOriginalReadPosition;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8006310:	f7ff fbfe 	bl	8005b10 <ulPortSetInterruptMask>
 8006314:	e77d      	b.n	8006212 <xQueueGenericReceive+0x1e>
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
 8006316:	b005      	add	sp, #20
 8006318:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800631c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
 800631c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800631e:	460e      	mov	r6, r1
 8006320:	4615      	mov	r5, r2
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 8006322:	4604      	mov	r4, r0
 8006324:	b910      	cbnz	r0, 800632c <xQueueReceiveFromISR+0x10>
 8006326:	f7ff fbf3 	bl	8005b10 <ulPortSetInterruptMask>
 800632a:	e7fe      	b.n	800632a <xQueueReceiveFromISR+0xe>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800632c:	bb09      	cbnz	r1, 8006372 <xQueueReceiveFromISR+0x56>
 800632e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006330:	b1fb      	cbz	r3, 8006372 <xQueueReceiveFromISR+0x56>
 8006332:	e01b      	b.n	800636c <xQueueReceiveFromISR+0x50>
 8006334:	e7fe      	b.n	8006334 <xQueueReceiveFromISR+0x18>
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8006336:	4620      	mov	r0, r4
 8006338:	4631      	mov	r1, r6
 800633a:	f7ff fdef 	bl	8005f1c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 800633e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006340:	3b01      	subs	r3, #1
 8006342:	63a3      	str	r3, [r4, #56]	; 0x38

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
 8006344:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006346:	3301      	adds	r3, #1
 8006348:	d10b      	bne.n	8006362 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800634a:	6923      	ldr	r3, [r4, #16]
 800634c:	b903      	cbnz	r3, 8006350 <xQueueReceiveFromISR+0x34>
 800634e:	e00b      	b.n	8006368 <xQueueReceiveFromISR+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8006350:	f104 0010 	add.w	r0, r4, #16
 8006354:	f000 fda0 	bl	8006e98 <xTaskRemoveFromEventList>
 8006358:	b130      	cbz	r0, 8006368 <xQueueReceiveFromISR+0x4c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 800635a:	b12d      	cbz	r5, 8006368 <xQueueReceiveFromISR+0x4c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 800635c:	2401      	movs	r4, #1
 800635e:	602c      	str	r4, [r5, #0]
 8006360:	e00e      	b.n	8006380 <xQueueReceiveFromISR+0x64>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 8006362:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006364:	3301      	adds	r3, #1
 8006366:	6463      	str	r3, [r4, #68]	; 0x44
			}

			xReturn = pdPASS;
 8006368:	2401      	movs	r4, #1
 800636a:	e009      	b.n	8006380 <xQueueReceiveFromISR+0x64>
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800636c:	f7ff fbd0 	bl	8005b10 <ulPortSetInterruptMask>
 8006370:	e7e0      	b.n	8006334 <xQueueReceiveFromISR+0x18>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006372:	f7ff fbcd 	bl	8005b10 <ulPortSetInterruptMask>
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006376:	6ba3      	ldr	r3, [r4, #56]	; 0x38

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006378:	4607      	mov	r7, r0
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800637a:	2b00      	cmp	r3, #0
 800637c:	d1db      	bne.n	8006336 <xQueueReceiveFromISR+0x1a>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
 800637e:	461c      	mov	r4, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8006380:	4638      	mov	r0, r7
 8006382:	f7ff fbdb 	bl	8005b3c <vPortClearInterruptMask>

	return xReturn;
}
 8006386:	4620      	mov	r0, r4
 8006388:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800638a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
{
 800638a:	b510      	push	{r4, lr}
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );
 800638c:	4604      	mov	r4, r0
 800638e:	b910      	cbnz	r0, 8006396 <uxQueueMessagesWaiting+0xc>
 8006390:	f7ff fbbe 	bl	8005b10 <ulPortSetInterruptMask>
 8006394:	e7fe      	b.n	8006394 <uxQueueMessagesWaiting+0xa>

	taskENTER_CRITICAL();
 8006396:	f7ff fbc3 	bl	8005b20 <vPortEnterCritical>
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 800639a:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 800639c:	f7ff fbd1 	bl	8005b42 <vPortExitCritical>

	return uxReturn;
}
 80063a0:	4620      	mov	r0, r4
 80063a2:	bd10      	pop	{r4, pc}

080063a4 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
{
 80063a4:	b508      	push	{r3, lr}
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );
 80063a6:	b910      	cbnz	r0, 80063ae <uxQueueMessagesWaitingFromISR+0xa>
 80063a8:	f7ff fbb2 	bl	8005b10 <ulPortSetInterruptMask>
 80063ac:	e7fe      	b.n	80063ac <uxQueueMessagesWaitingFromISR+0x8>

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 80063ae:	6b80      	ldr	r0, [r0, #56]	; 0x38

	return uxReturn;
}
 80063b0:	bd08      	pop	{r3, pc}

080063b2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
 80063b2:	b510      	push	{r4, lr}
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 80063b4:	4604      	mov	r4, r0
 80063b6:	b910      	cbnz	r0, 80063be <vQueueDelete+0xc>
 80063b8:	f7ff fbaa 	bl	8005b10 <ulPortSetInterruptMask>
 80063bc:	e7fe      	b.n	80063bc <vQueueDelete+0xa>
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
 80063be:	6800      	ldr	r0, [r0, #0]
 80063c0:	f7ff fb5e 	bl	8005a80 <vPortFree>
	vPortFree( pxQueue );
 80063c4:	4620      	mov	r0, r4
}
 80063c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
 80063ca:	f7ff bb59 	b.w	8005a80 <vPortFree>

080063ce <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
 80063ce:	b508      	push	{r3, lr}
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
 80063d0:	b910      	cbnz	r0, 80063d8 <xQueueIsQueueEmptyFromISR+0xa>
 80063d2:	f7ff fb9d 	bl	8005b10 <ulPortSetInterruptMask>
 80063d6:	e7fe      	b.n	80063d6 <xQueueIsQueueEmptyFromISR+0x8>
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
 80063d8:	6b80      	ldr	r0, [r0, #56]	; 0x38
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 80063da:	f1d0 0001 	rsbs	r0, r0, #1
 80063de:	bf38      	it	cc
 80063e0:	2000      	movcc	r0, #0
 80063e2:	bd08      	pop	{r3, pc}

080063e4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
 80063e4:	b508      	push	{r3, lr}
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
 80063e6:	b910      	cbnz	r0, 80063ee <xQueueIsQueueFullFromISR+0xa>
 80063e8:	f7ff fb92 	bl	8005b10 <ulPortSetInterruptMask>
 80063ec:	e7fe      	b.n	80063ec <xQueueIsQueueFullFromISR+0x8>
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
 80063ee:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80063f0:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 80063f2:	1a13      	subs	r3, r2, r0
 80063f4:	4258      	negs	r0, r3
 80063f6:	4158      	adcs	r0, r3
 80063f8:	bd08      	pop	{r3, pc}

080063fa <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
	{
 80063fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80063fe:	4604      	mov	r4, r0
 8006400:	460e      	mov	r6, r1
 8006402:	4615      	mov	r5, r2
		pxQueue = ( xQUEUE * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
 8006404:	f7ff fb84 	bl	8005b10 <ulPortSetInterruptMask>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8006408:	f7ff fb8a 	bl	8005b20 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800640c:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
 8006410:	6be7      	ldr	r7, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8006412:	f7ff fb96 	bl	8005b42 <vPortExitCritical>
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8006416:	45b8      	cmp	r8, r7
 8006418:	d10f      	bne.n	800643a <xQueueCRSend+0x40>
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 800641a:	4628      	mov	r0, r5
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
 800641c:	b14d      	cbz	r5, 8006432 <xQueueCRSend+0x38>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 800641e:	f104 0110 	add.w	r1, r4, #16
 8006422:	f7ff fc45 	bl	8005cb0 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
 8006426:	2000      	movs	r0, #0
 8006428:	f7ff fb88 	bl	8005b3c <vPortClearInterruptMask>
					return errQUEUE_BLOCKED;
 800642c:	f06f 0403 	mvn.w	r4, #3
 8006430:	e022      	b.n	8006478 <xQueueCRSend+0x7e>
				}
				else
				{
					portENABLE_INTERRUPTS();
 8006432:	f7ff fb83 	bl	8005b3c <vPortClearInterruptMask>
					return errQUEUE_FULL;
 8006436:	462c      	mov	r4, r5
 8006438:	e01e      	b.n	8006478 <xQueueCRSend+0x7e>
				}
			}
		}
		portENABLE_INTERRUPTS();
 800643a:	2000      	movs	r0, #0
 800643c:	f7ff fb7e 	bl	8005b3c <vPortClearInterruptMask>

		portDISABLE_INTERRUPTS();
 8006440:	f7ff fb66 	bl	8005b10 <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8006444:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8006446:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8006448:	429a      	cmp	r2, r3
 800644a:	d211      	bcs.n	8006470 <xQueueCRSend+0x76>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 800644c:	4620      	mov	r0, r4
 800644e:	4631      	mov	r1, r6
 8006450:	2200      	movs	r2, #0
 8006452:	f7ff fd76 	bl	8005f42 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8006456:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006458:	b90b      	cbnz	r3, 800645e <xQueueCRSend+0x64>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
 800645a:	2401      	movs	r4, #1
 800645c:	e009      	b.n	8006472 <xQueueCRSend+0x78>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800645e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006462:	f7ff fccb 	bl	8005dfc <xCoRoutineRemoveFromEventList>
 8006466:	2800      	cmp	r0, #0
 8006468:	d0f7      	beq.n	800645a <xQueueCRSend+0x60>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
 800646a:	f06f 0404 	mvn.w	r4, #4
 800646e:	e000      	b.n	8006472 <xQueueCRSend+0x78>
					}
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
 8006470:	2400      	movs	r4, #0
			}
		}
		portENABLE_INTERRUPTS();
 8006472:	2000      	movs	r0, #0
 8006474:	f7ff fb62 	bl	8005b3c <vPortClearInterruptMask>

		return xReturn;
	}
 8006478:	4620      	mov	r0, r4
 800647a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800647e <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
	{
 800647e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006480:	4604      	mov	r4, r0
 8006482:	460f      	mov	r7, r1
 8006484:	4615      	mov	r5, r2
		pxQueue = ( xQUEUE * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
 8006486:	f7ff fb43 	bl	8005b10 <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
 800648a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 800648c:	b97e      	cbnz	r6, 80064ae <xQueueCRReceive+0x30>
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 800648e:	4628      	mov	r0, r5
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
 8006490:	b14d      	cbz	r5, 80064a6 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 8006492:	f104 0124 	add.w	r1, r4, #36	; 0x24
 8006496:	f7ff fc0b 	bl	8005cb0 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
 800649a:	4630      	mov	r0, r6
 800649c:	f7ff fb4e 	bl	8005b3c <vPortClearInterruptMask>
					return errQUEUE_BLOCKED;
 80064a0:	f06f 0403 	mvn.w	r4, #3
 80064a4:	e02c      	b.n	8006500 <xQueueCRReceive+0x82>
				}
				else
				{
					portENABLE_INTERRUPTS();
 80064a6:	f7ff fb49 	bl	8005b3c <vPortClearInterruptMask>
					return errQUEUE_FULL;
 80064aa:	462c      	mov	r4, r5
 80064ac:	e028      	b.n	8006500 <xQueueCRReceive+0x82>
				}
			}
		}
		portENABLE_INTERRUPTS();
 80064ae:	2000      	movs	r0, #0
 80064b0:	f7ff fb44 	bl	8005b3c <vPortClearInterruptMask>

		portDISABLE_INTERRUPTS();
 80064b4:	f7ff fb2c 	bl	8005b10 <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 80064b8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80064ba:	b1eb      	cbz	r3, 80064f8 <xQueueCRReceive+0x7a>
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
 80064bc:	68e3      	ldr	r3, [r4, #12]
 80064be:	6c22      	ldr	r2, [r4, #64]	; 0x40
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 80064c0:	6861      	ldr	r1, [r4, #4]
		portDISABLE_INTERRUPTS();
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
 80064c2:	189b      	adds	r3, r3, r2
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 80064c4:	428b      	cmp	r3, r1
		portDISABLE_INTERRUPTS();
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
 80064c6:	60e3      	str	r3, [r4, #12]
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
				{
					pxQueue->pcReadFrom = pxQueue->pcHead;
 80064c8:	bf28      	it	cs
 80064ca:	6823      	ldrcs	r3, [r4, #0]
				}
				--( pxQueue->uxMessagesWaiting );
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 80064cc:	4638      	mov	r0, r7
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
				{
					pxQueue->pcReadFrom = pxQueue->pcHead;
 80064ce:	bf28      	it	cs
 80064d0:	60e3      	strcs	r3, [r4, #12]
				}
				--( pxQueue->uxMessagesWaiting );
 80064d2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 80064d4:	68e1      	ldr	r1, [r4, #12]
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
				{
					pxQueue->pcReadFrom = pxQueue->pcHead;
				}
				--( pxQueue->uxMessagesWaiting );
 80064d6:	3b01      	subs	r3, #1
 80064d8:	63a3      	str	r3, [r4, #56]	; 0x38
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 80064da:	f001 fd7b 	bl	8007fd4 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80064de:	6923      	ldr	r3, [r4, #16]
 80064e0:	b90b      	cbnz	r3, 80064e6 <xQueueCRReceive+0x68>
					pxQueue->pcReadFrom = pxQueue->pcHead;
				}
				--( pxQueue->uxMessagesWaiting );
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
 80064e2:	2401      	movs	r4, #1
 80064e4:	e009      	b.n	80064fa <xQueueCRReceive+0x7c>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80064e6:	f104 0010 	add.w	r0, r4, #16
 80064ea:	f7ff fc87 	bl	8005dfc <xCoRoutineRemoveFromEventList>
 80064ee:	2800      	cmp	r0, #0
 80064f0:	d0f7      	beq.n	80064e2 <xQueueCRReceive+0x64>
					{
						xReturn = errQUEUE_YIELD;
 80064f2:	f06f 0404 	mvn.w	r4, #4
 80064f6:	e000      	b.n	80064fa <xQueueCRReceive+0x7c>
					}
				}
			}
			else
			{
				xReturn = pdFAIL;
 80064f8:	461c      	mov	r4, r3
			}
		}
		portENABLE_INTERRUPTS();
 80064fa:	2000      	movs	r0, #0
 80064fc:	f7ff fb1e 	bl	8005b3c <vPortClearInterruptMask>

		return xReturn;
	}
 8006500:	4620      	mov	r0, r4
 8006502:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006504 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
 8006504:	b538      	push	{r3, r4, r5, lr}
 8006506:	4615      	mov	r5, r2

		pxQueue = ( xQUEUE * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8006508:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800650a:	6b82      	ldr	r2, [r0, #56]	; 0x38
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
 800650c:	4604      	mov	r4, r0

		pxQueue = ( xQUEUE * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800650e:	429a      	cmp	r2, r3
 8006510:	d20c      	bcs.n	800652c <xQueueCRSendFromISR+0x28>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 8006512:	2200      	movs	r2, #0
 8006514:	f7ff fd15 	bl	8005f42 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
 8006518:	b945      	cbnz	r5, 800652c <xQueueCRSendFromISR+0x28>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800651a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800651c:	b133      	cbz	r3, 800652c <xQueueCRSendFromISR+0x28>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800651e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006522:	f7ff fc6b 	bl	8005dfc <xCoRoutineRemoveFromEventList>
 8006526:	1c05      	adds	r5, r0, #0
 8006528:	bf18      	it	ne
 800652a:	2501      	movne	r5, #1
				}
			}
		}

		return xCoRoutinePreviouslyWoken;
	}
 800652c:	4628      	mov	r0, r5
 800652e:	bd38      	pop	{r3, r4, r5, pc}

08006530 <xQueueCRReceiveFromISR>:

		pxQueue = ( xQUEUE * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006530:	6b83      	ldr	r3, [r0, #56]	; 0x38
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
	{
 8006532:	b570      	push	{r4, r5, r6, lr}
 8006534:	4604      	mov	r4, r0
 8006536:	4615      	mov	r5, r2

		pxQueue = ( xQUEUE * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006538:	b1fb      	cbz	r3, 800657a <xQueueCRReceiveFromISR+0x4a>
		{
			/* Copy the data from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
 800653a:	68c3      	ldr	r3, [r0, #12]
 800653c:	6c02      	ldr	r2, [r0, #64]	; 0x40
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 800653e:	6846      	ldr	r6, [r0, #4]
		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			/* Copy the data from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8006540:	189b      	adds	r3, r3, r2
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 8006542:	42b3      	cmp	r3, r6
		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			/* Copy the data from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8006544:	60c3      	str	r3, [r0, #12]
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
 8006546:	bf24      	itt	cs
 8006548:	6803      	ldrcs	r3, [r0, #0]
 800654a:	60c3      	strcs	r3, [r0, #12]
			}
			--( pxQueue->uxMessagesWaiting );
 800654c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800654e:	3b01      	subs	r3, #1
 8006550:	6383      	str	r3, [r0, #56]	; 0x38
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8006552:	4608      	mov	r0, r1
 8006554:	68e1      	ldr	r1, [r4, #12]
 8006556:	f001 fd3d 	bl	8007fd4 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
 800655a:	682b      	ldr	r3, [r5, #0]
 800655c:	b10b      	cbz	r3, 8006562 <xQueueCRReceiveFromISR+0x32>
						*pxCoRoutineWoken = pdTRUE;
					}
				}
			}

			xReturn = pdPASS;
 800655e:	2001      	movs	r0, #1
 8006560:	bd70      	pop	{r4, r5, r6, pc}
			--( pxQueue->uxMessagesWaiting );
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8006562:	6923      	ldr	r3, [r4, #16]
 8006564:	2b00      	cmp	r3, #0
 8006566:	d0fa      	beq.n	800655e <xQueueCRReceiveFromISR+0x2e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8006568:	f104 0010 	add.w	r0, r4, #16
 800656c:	f7ff fc46 	bl	8005dfc <xCoRoutineRemoveFromEventList>
 8006570:	2800      	cmp	r0, #0
 8006572:	d0f4      	beq.n	800655e <xQueueCRReceiveFromISR+0x2e>
					{
						*pxCoRoutineWoken = pdTRUE;
 8006574:	2001      	movs	r0, #1
 8006576:	6028      	str	r0, [r5, #0]
 8006578:	bd70      	pop	{r4, r5, r6, pc}

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
 800657a:	4618      	mov	r0, r3
		}

		return xReturn;
	}
 800657c:	bd70      	pop	{r4, r5, r6, pc}

0800657e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
	{
 800657e:	b538      	push	{r3, r4, r5, lr}
 8006580:	4604      	mov	r4, r0
 8006582:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8006584:	f7ff facc 	bl	8005b20 <vPortEnterCritical>
 8006588:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800658a:	3301      	adds	r3, #1
 800658c:	d101      	bne.n	8006592 <vQueueWaitForMessageRestricted+0x14>
 800658e:	2300      	movs	r3, #0
 8006590:	6463      	str	r3, [r4, #68]	; 0x44
 8006592:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8006594:	3301      	adds	r3, #1
 8006596:	d101      	bne.n	800659c <vQueueWaitForMessageRestricted+0x1e>
 8006598:	2300      	movs	r3, #0
 800659a:	64a3      	str	r3, [r4, #72]	; 0x48
 800659c:	f7ff fad1 	bl	8005b42 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 80065a0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80065a2:	b923      	cbnz	r3, 80065ae <vQueueWaitForMessageRestricted+0x30>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80065a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80065a8:	4629      	mov	r1, r5
 80065aa:	f000 fc5d 	bl	8006e68 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
 80065ae:	4620      	mov	r0, r4
	}
 80065b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
		}
		prvUnlockQueue( pxQueue );
 80065b4:	f7ff bc7e 	b.w	8005eb4 <prvUnlockQueue>

080065b8 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80065b8:	4b0c      	ldr	r3, [pc, #48]	; (80065ec <prvAddCurrentTaskToDelayedList+0x34>)
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 80065ba:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80065bc:	681a      	ldr	r2, [r3, #0]
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 80065be:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80065c0:	6050      	str	r0, [r2, #4]

	if( xTimeToWake < xTickCount )
 80065c2:	685a      	ldr	r2, [r3, #4]
 80065c4:	4290      	cmp	r0, r2
 80065c6:	d206      	bcs.n	80065d6 <prvAddCurrentTaskToDelayedList+0x1e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 80065c8:	6898      	ldr	r0, [r3, #8]
 80065ca:	6819      	ldr	r1, [r3, #0]
 80065cc:	3104      	adds	r1, #4
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
 80065ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 80065d2:	f7ff bc46 	b.w	8005e62 <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 80065d6:	68d8      	ldr	r0, [r3, #12]
 80065d8:	6819      	ldr	r1, [r3, #0]
 80065da:	3104      	adds	r1, #4
 80065dc:	f7ff fc41 	bl	8005e62 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 80065e0:	4b03      	ldr	r3, [pc, #12]	; (80065f0 <prvAddCurrentTaskToDelayedList+0x38>)
 80065e2:	681a      	ldr	r2, [r3, #0]
 80065e4:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
 80065e6:	bf38      	it	cc
 80065e8:	601c      	strcc	r4, [r3, #0]
 80065ea:	bd10      	pop	{r4, pc}
 80065ec:	20002a44 	.word	0x20002a44
 80065f0:	20000030 	.word	0x20000030

080065f4 <xTaskGenericCreate>:
#endif

/*lint +e956 */

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80065f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80065f8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80065fa:	4688      	mov	r8, r1
 80065fc:	4617      	mov	r7, r2
 80065fe:	469b      	mov	fp, r3
 8006600:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8006604:	9d0c      	ldr	r5, [sp, #48]	; 0x30
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
 8006606:	4682      	mov	sl, r0
 8006608:	b910      	cbnz	r0, 8006610 <xTaskGenericCreate+0x1c>
 800660a:	f7ff fa81 	bl	8005b10 <ulPortSetInterruptMask>
 800660e:	e7fe      	b.n	800660e <xTaskGenericCreate+0x1a>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 8006610:	2e04      	cmp	r6, #4
 8006612:	d902      	bls.n	800661a <xTaskGenericCreate+0x26>
 8006614:	f7ff fa7c 	bl	8005b10 <ulPortSetInterruptMask>
 8006618:	e7fe      	b.n	8006618 <xTaskGenericCreate+0x24>
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 800661a:	2044      	movs	r0, #68	; 0x44
 800661c:	f7ff fa02 	bl	8005a24 <pvPortMalloc>

	if( pxNewTCB != NULL )
 8006620:	4604      	mov	r4, r0
 8006622:	2800      	cmp	r0, #0
 8006624:	f000 80a4 	beq.w	8006770 <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8006628:	b91d      	cbnz	r5, 8006632 <xTaskGenericCreate+0x3e>
 800662a:	00b8      	lsls	r0, r7, #2
 800662c:	f7ff f9fa 	bl	8005a24 <pvPortMalloc>
 8006630:	4605      	mov	r5, r0
 8006632:	6325      	str	r5, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8006634:	b91d      	cbnz	r5, 800663e <xTaskGenericCreate+0x4a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8006636:	4620      	mov	r0, r4
 8006638:	f7ff fa22 	bl	8005a80 <vPortFree>
 800663c:	e098      	b.n	8006770 <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 800663e:	00ba      	lsls	r2, r7, #2
 8006640:	21a5      	movs	r1, #165	; 0xa5
 8006642:	4628      	mov	r0, r5
 8006644:	f001 fd80 	bl	8008148 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 8006648:	6b23      	ldr	r3, [r4, #48]	; 0x30
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 800664a:	4641      	mov	r1, r8
 800664c:	220a      	movs	r2, #10
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 800664e:	3f01      	subs	r7, #1
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8006650:	f104 0034 	add.w	r0, r4, #52	; 0x34
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 8006654:	eb03 0787 	add.w	r7, r3, r7, lsl #2
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8006658:	f104 0804 	add.w	r8, r4, #4
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 800665c:	f001 fdda 	bl	8008214 <strncpy>
	}
	#endif /* configMAX_TASK_NAME_LEN */
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 8006660:	2300      	movs	r3, #0
 8006662:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8006666:	4640      	mov	r0, r8
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
 8006668:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 800666a:	6426      	str	r6, [r4, #64]	; 0x40
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800666c:	f7ff fbe9 	bl	8005e42 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8006670:	f104 0018 	add.w	r0, r4, #24
 8006674:	f7ff fbe5 	bl	8005e42 <vListInitialiseItem>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
 8006678:	f027 0707 	bic.w	r7, r7, #7
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 800667c:	f1c6 0305 	rsb	r3, r6, #5
 8006680:	61a3      	str	r3, [r4, #24]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8006682:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8006684:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8006686:	4638      	mov	r0, r7
 8006688:	4651      	mov	r1, sl
 800668a:	465a      	mov	r2, fp
 800668c:	f7ff fa18 	bl	8005ac0 <pxPortInitialiseStack>
		}
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 8006690:	0743      	lsls	r3, r0, #29
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8006692:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 8006694:	d002      	beq.n	800669c <xTaskGenericCreate+0xa8>
 8006696:	f7ff fa3b 	bl	8005b10 <ulPortSetInterruptMask>
 800669a:	e7fe      	b.n	800669a <xTaskGenericCreate+0xa6>

		if( ( void * ) pxCreatedTask != NULL )
 800669c:	f1b9 0f00 	cmp.w	r9, #0
 80066a0:	d001      	beq.n	80066a6 <xTaskGenericCreate+0xb2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 80066a2:	f8c9 4000 	str.w	r4, [r9]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 80066a6:	f7ff fa3b 	bl	8005b20 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 80066aa:	4b33      	ldr	r3, [pc, #204]	; (8006778 <xTaskGenericCreate+0x184>)
 80066ac:	691a      	ldr	r2, [r3, #16]
 80066ae:	3201      	adds	r2, #1
 80066b0:	611a      	str	r2, [r3, #16]
			if( pxCurrentTCB == NULL )
 80066b2:	681f      	ldr	r7, [r3, #0]
 80066b4:	bb4f      	cbnz	r7, 800670a <xTaskGenericCreate+0x116>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 80066b6:	601c      	str	r4, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 80066b8:	691a      	ldr	r2, [r3, #16]
 80066ba:	2a01      	cmp	r2, #1
 80066bc:	d12d      	bne.n	800671a <xTaskGenericCreate+0x126>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80066be:	f103 0914 	add.w	r9, r3, #20
 80066c2:	f04f 0a14 	mov.w	sl, #20
 80066c6:	fb0a 9007 	mla	r0, sl, r7, r9

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 80066ca:	3701      	adds	r7, #1
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80066cc:	f7ff fbae 	bl	8005e2c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 80066d0:	2f05      	cmp	r7, #5
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80066d2:	4d29      	ldr	r5, [pc, #164]	; (8006778 <xTaskGenericCreate+0x184>)

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 80066d4:	d1f7      	bne.n	80066c6 <xTaskGenericCreate+0xd2>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 80066d6:	f105 0978 	add.w	r9, r5, #120	; 0x78
 80066da:	4648      	mov	r0, r9
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 80066dc:	f105 078c 	add.w	r7, r5, #140	; 0x8c
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 80066e0:	f7ff fba4 	bl	8005e2c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 80066e4:	4638      	mov	r0, r7
 80066e6:	f7ff fba1 	bl	8005e2c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 80066ea:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 80066ee:	f7ff fb9d 	bl	8005e2c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 80066f2:	f105 00b4 	add.w	r0, r5, #180	; 0xb4
 80066f6:	f7ff fb99 	bl	8005e2c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 80066fa:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 80066fe:	f7ff fb95 	bl	8005e2c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8006702:	f8c5 900c 	str.w	r9, [r5, #12]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8006706:	60af      	str	r7, [r5, #8]
 8006708:	e007      	b.n	800671a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 800670a:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 800670e:	b922      	cbnz	r2, 800671a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8006710:	681a      	ldr	r2, [r3, #0]
 8006712:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006714:	42b2      	cmp	r2, r6
					{
						pxCurrentTCB = pxNewTCB;
 8006716:	bf98      	it	ls
 8006718:	601c      	strls	r4, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 800671a:	4a17      	ldr	r2, [pc, #92]	; (8006778 <xTaskGenericCreate+0x184>)
 800671c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800671e:	f8d2 10e0 	ldr.w	r1, [r2, #224]	; 0xe0
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
 8006722:	4c15      	ldr	r4, [pc, #84]	; (8006778 <xTaskGenericCreate+0x184>)
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8006724:	428b      	cmp	r3, r1
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
			}

			uxTaskNumber++;
 8006726:	f8d2 10e4 	ldr.w	r1, [r2, #228]	; 0xe4

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 800672a:	bf88      	it	hi
 800672c:	f8c2 30e0 	strhi.w	r3, [r2, #224]	; 0xe0
			}

			uxTaskNumber++;
 8006730:	3101      	adds	r1, #1
 8006732:	f8c2 10e4 	str.w	r1, [r2, #228]	; 0xe4
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
 8006736:	f8d2 20e8 	ldr.w	r2, [r2, #232]	; 0xe8
 800673a:	4641      	mov	r1, r8
 800673c:	4293      	cmp	r3, r2
 800673e:	bf84      	itt	hi
 8006740:	4a0d      	ldrhi	r2, [pc, #52]	; (8006778 <xTaskGenericCreate+0x184>)
 8006742:	f8c2 30e8 	strhi.w	r3, [r2, #232]	; 0xe8
 8006746:	f104 0214 	add.w	r2, r4, #20
 800674a:	2014      	movs	r0, #20
 800674c:	fb00 2003 	mla	r0, r0, r3, r2
 8006750:	f7ff fb7a 	bl	8005e48 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8006754:	f7ff f9f5 	bl	8005b42 <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8006758:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 800675c:	b12b      	cbz	r3, 800676a <xTaskGenericCreate+0x176>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 800675e:	6823      	ldr	r3, [r4, #0]
 8006760:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006762:	42b3      	cmp	r3, r6
 8006764:	d201      	bcs.n	800676a <xTaskGenericCreate+0x176>
			{
				portYIELD_WITHIN_API();
 8006766:	f7ff f9c8 	bl	8005afa <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
 800676a:	2001      	movs	r0, #1
 800676c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8006770:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
 8006774:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006778:	20002a44 	.word	0x20002a44

0800677c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
 800677c:	b570      	push	{r4, r5, r6, lr}
 800677e:	4605      	mov	r5, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 8006780:	f7ff f9ce 	bl	8005b20 <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
 8006784:	4b16      	ldr	r3, [pc, #88]	; (80067e0 <vTaskDelete+0x64>)
 8006786:	681a      	ldr	r2, [r3, #0]
 8006788:	4295      	cmp	r5, r2
 800678a:	d001      	beq.n	8006790 <vTaskDelete+0x14>
			{
				xTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 800678c:	462c      	mov	r4, r5
 800678e:	b915      	cbnz	r5, 8006796 <vTaskDelete+0x1a>
 8006790:	681c      	ldr	r4, [r3, #0]
 8006792:	2500      	movs	r5, #0
 8006794:	e7ff      	b.n	8006796 <vTaskDelete+0x1a>

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8006796:	1d26      	adds	r6, r4, #4
 8006798:	4630      	mov	r0, r6
 800679a:	f7ff fb7a 	bl	8005e92 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 800679e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80067a0:	b11b      	cbz	r3, 80067aa <vTaskDelete+0x2e>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
 80067a2:	f104 0018 	add.w	r0, r4, #24
 80067a6:	f7ff fb74 	bl	8005e92 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 80067aa:	4c0d      	ldr	r4, [pc, #52]	; (80067e0 <vTaskDelete+0x64>)
 80067ac:	4631      	mov	r1, r6
 80067ae:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
 80067b2:	f7ff fb49 	bl	8005e48 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 80067b6:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80067ba:	3301      	adds	r3, #1
 80067bc:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 80067c0:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 80067c4:	3301      	adds	r3, #1
 80067c6:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 80067ca:	f7ff f9ba 	bl	8005b42 <vPortExitCritical>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
 80067ce:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 80067d2:	b123      	cbz	r3, 80067de <vTaskDelete+0x62>
		{
			if( ( void * ) xTaskToDelete == NULL )
 80067d4:	b91d      	cbnz	r5, 80067de <vTaskDelete+0x62>
			{
				portYIELD_WITHIN_API();
			}
		}
	}
 80067d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
		{
			if( ( void * ) xTaskToDelete == NULL )
			{
				portYIELD_WITHIN_API();
 80067da:	f7ff b98e 	b.w	8005afa <vPortYield>
 80067de:	bd70      	pop	{r4, r5, r6, pc}
 80067e0:	20002a44 	.word	0x20002a44

080067e4 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
	{
 80067e4:	b510      	push	{r4, lr}
 80067e6:	4604      	mov	r4, r0
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
 80067e8:	f7ff f99a 	bl	8005b20 <vPortEnterCritical>
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
 80067ec:	b90c      	cbnz	r4, 80067f2 <uxTaskPriorityGet+0xe>
 80067ee:	4b03      	ldr	r3, [pc, #12]	; (80067fc <uxTaskPriorityGet+0x18>)
 80067f0:	681c      	ldr	r4, [r3, #0]
			uxReturn = pxTCB->uxPriority;
 80067f2:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		}
		taskEXIT_CRITICAL();
 80067f4:	f7ff f9a5 	bl	8005b42 <vPortExitCritical>

		return uxReturn;
	}
 80067f8:	4620      	mov	r0, r4
 80067fa:	bd10      	pop	{r4, pc}
 80067fc:	20002a44 	.word	0x20002a44

08006800 <vTaskPrioritySet>:
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 8006800:	2904      	cmp	r1, #4
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
	{
 8006802:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006806:	4605      	mov	r5, r0
 8006808:	460e      	mov	r6, r1
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 800680a:	d902      	bls.n	8006812 <vTaskPrioritySet+0x12>
 800680c:	f7ff f980 	bl	8005b10 <ulPortSetInterruptMask>
 8006810:	e7fe      	b.n	8006810 <vTaskPrioritySet+0x10>
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
 8006812:	f7ff f985 	bl	8005b20 <vPortEnterCritical>
		{
			if( xTask == ( xTaskHandle ) pxCurrentTCB )
 8006816:	4b20      	ldr	r3, [pc, #128]	; (8006898 <vTaskPrioritySet+0x98>)
 8006818:	681a      	ldr	r2, [r3, #0]
 800681a:	4295      	cmp	r5, r2
 800681c:	d000      	beq.n	8006820 <vTaskPrioritySet+0x20>
				xTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
 800681e:	b915      	cbnz	r5, 8006826 <vTaskPrioritySet+0x26>
 8006820:	681c      	ldr	r4, [r3, #0]
 8006822:	2500      	movs	r5, #0
 8006824:	e000      	b.n	8006828 <vTaskPrioritySet+0x28>
 8006826:	462c      	mov	r4, r5

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
 8006828:	6c23      	ldr	r3, [r4, #64]	; 0x40
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
 800682a:	42b3      	cmp	r3, r6
 800682c:	d02f      	beq.n	800688e <vTaskPrioritySet+0x8e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
 800682e:	429e      	cmp	r6, r3
 8006830:	d903      	bls.n	800683a <vTaskPrioritySet+0x3a>
				{
					if( xTask != NULL )
 8006832:	3500      	adds	r5, #0
 8006834:	bf18      	it	ne
 8006836:	2501      	movne	r5, #1
 8006838:	e003      	b.n	8006842 <vTaskPrioritySet+0x42>
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
					}
				}
				else if( xTask == NULL )
 800683a:	f1d5 0501 	rsbs	r5, r5, #1
 800683e:	bf38      	it	cc
 8006840:	2500      	movcc	r5, #0

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8006842:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
					{
						pxTCB->uxPriority = uxNewPriority;
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 8006844:	6426      	str	r6, [r4, #64]	; 0x40

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8006846:	4293      	cmp	r3, r2
					{
						pxTCB->uxPriority = uxNewPriority;
 8006848:	bf08      	it	eq
 800684a:	62e6      	streq	r6, [r4, #44]	; 0x2c
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
 800684c:	f1c6 0605 	rsb	r6, r6, #5
 8006850:	61a6      	str	r6, [r4, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
 8006852:	4e11      	ldr	r6, [pc, #68]	; (8006898 <vTaskPrioritySet+0x98>)
 8006854:	2214      	movs	r2, #20
 8006856:	f106 0014 	add.w	r0, r6, #20
 800685a:	fb02 0303 	mla	r3, r2, r3, r0
 800685e:	6962      	ldr	r2, [r4, #20]
 8006860:	4680      	mov	r8, r0
 8006862:	429a      	cmp	r2, r3
 8006864:	d110      	bne.n	8006888 <vTaskPrioritySet+0x88>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8006866:	1d27      	adds	r7, r4, #4
 8006868:	4638      	mov	r0, r7
 800686a:	f7ff fb12 	bl	8005e92 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
					}
					prvAddTaskToReadyQueue( pxTCB );
 800686e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006870:	f8d6 20e8 	ldr.w	r2, [r6, #232]	; 0xe8
 8006874:	4639      	mov	r1, r7
 8006876:	4293      	cmp	r3, r2
 8006878:	bf88      	it	hi
 800687a:	f8c6 30e8 	strhi.w	r3, [r6, #232]	; 0xe8
 800687e:	2014      	movs	r0, #20
 8006880:	fb00 8003 	mla	r0, r0, r3, r8
 8006884:	f7ff fae0 	bl	8005e48 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
 8006888:	b10d      	cbz	r5, 800688e <vTaskPrioritySet+0x8e>
				{
					portYIELD_WITHIN_API();
 800688a:	f7ff f936 	bl	8005afa <vPortYield>
		taskEXIT_CRITICAL();

		/* Remove compiler warning about unused parameter when the port
		optimised task selection is not being used. */
		( void ) uxPriorityUsedOnEntry;
	}
 800688e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				{
					portYIELD_WITHIN_API();
				}
			}
		}
		taskEXIT_CRITICAL();
 8006892:	f7ff b956 	b.w	8005b42 <vPortExitCritical>
 8006896:	bf00      	nop
 8006898:	20002a44 	.word	0x20002a44

0800689c <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
 800689c:	b508      	push	{r3, lr}
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
 800689e:	b910      	cbnz	r0, 80068a6 <xTaskIsTaskSuspended+0xa>
 80068a0:	f7ff f936 	bl	8005b10 <ulPortSetInterruptMask>
 80068a4:	e7fe      	b.n	80068a4 <xTaskIsTaskSuspended+0x8>

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80068a6:	6943      	ldr	r3, [r0, #20]
 80068a8:	4a07      	ldr	r2, [pc, #28]	; (80068c8 <xTaskIsTaskSuspended+0x2c>)
 80068aa:	4293      	cmp	r3, r2
 80068ac:	d109      	bne.n	80068c2 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 80068ae:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80068b0:	f1a2 0328 	sub.w	r3, r2, #40	; 0x28
 80068b4:	4298      	cmp	r0, r3
 80068b6:	d004      	beq.n	80068c2 <xTaskIsTaskSuspended+0x26>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 80068b8:	f1d0 0001 	rsbs	r0, r0, #1
 80068bc:	bf38      	it	cc
 80068be:	2000      	movcc	r0, #0
 80068c0:	bd08      	pop	{r3, pc}

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
 80068c2:	2000      	movs	r0, #0
				}
			}
		}

		return xReturn;
	}
 80068c4:	bd08      	pop	{r3, pc}
 80068c6:	bf00      	nop
 80068c8:	20002b0c 	.word	0x20002b0c

080068cc <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle xTaskToResume )
	{
 80068cc:	b570      	push	{r4, r5, r6, lr}
	tskTCB *pxTCB;

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
 80068ce:	4604      	mov	r4, r0
 80068d0:	b910      	cbnz	r0, 80068d8 <vTaskResume+0xc>
 80068d2:	f7ff f91d 	bl	8005b10 <ulPortSetInterruptMask>
 80068d6:	e7fe      	b.n	80068d6 <vTaskResume+0xa>
		it in the ready list. */
		pxTCB = ( tskTCB * ) xTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 80068d8:	4d15      	ldr	r5, [pc, #84]	; (8006930 <vTaskResume+0x64>)
 80068da:	682b      	ldr	r3, [r5, #0]
 80068dc:	4298      	cmp	r0, r3
 80068de:	d025      	beq.n	800692c <vTaskResume+0x60>
		{
			taskENTER_CRITICAL();
 80068e0:	f7ff f91e 	bl	8005b20 <vPortEnterCritical>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 80068e4:	4620      	mov	r0, r4
 80068e6:	f7ff ffd9 	bl	800689c <xTaskIsTaskSuspended>
 80068ea:	2801      	cmp	r0, #1
 80068ec:	d11a      	bne.n	8006924 <vTaskResume+0x58>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
 80068ee:	1d26      	adds	r6, r4, #4
 80068f0:	4630      	mov	r0, r6
 80068f2:	f7ff face 	bl	8005e92 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 80068f6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80068f8:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
 80068fc:	4631      	mov	r1, r6
 80068fe:	4293      	cmp	r3, r2
 8006900:	bf88      	it	hi
 8006902:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
 8006906:	4d0a      	ldr	r5, [pc, #40]	; (8006930 <vTaskResume+0x64>)
 8006908:	2014      	movs	r0, #20
 800690a:	f105 0214 	add.w	r2, r5, #20
 800690e:	fb00 2003 	mla	r0, r0, r3, r2
 8006912:	f7ff fa99 	bl	8005e48 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006916:	682b      	ldr	r3, [r5, #0]
 8006918:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800691a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800691c:	429a      	cmp	r2, r3
 800691e:	d301      	bcc.n	8006924 <vTaskResume+0x58>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
 8006920:	f7ff f8eb 	bl	8005afa <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
		}
	}
 8006924:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
					}
				}
			}
			taskEXIT_CRITICAL();
 8006928:	f7ff b90b 	b.w	8005b42 <vPortExitCritical>
 800692c:	bd70      	pop	{r4, r5, r6, pc}
 800692e:	bf00      	nop
 8006930:	20002a44 	.word	0x20002a44

08006934 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
	{
 8006934:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
 8006938:	4604      	mov	r4, r0
 800693a:	b910      	cbnz	r0, 8006942 <xTaskResumeFromISR+0xe>
 800693c:	f7ff f8e8 	bl	8005b10 <ulPortSetInterruptMask>
 8006940:	e7fe      	b.n	8006940 <xTaskResumeFromISR+0xc>

		pxTCB = ( tskTCB * ) xTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006942:	f7ff f8e5 	bl	8005b10 <ulPortSetInterruptMask>
 8006946:	4680      	mov	r8, r0
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 8006948:	4620      	mov	r0, r4
 800694a:	f7ff ffa7 	bl	800689c <xTaskIsTaskSuspended>
 800694e:	2801      	cmp	r0, #1
 8006950:	d123      	bne.n	800699a <xTaskResumeFromISR+0x66>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006952:	4d15      	ldr	r5, [pc, #84]	; (80069a8 <xTaskResumeFromISR+0x74>)
 8006954:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 8006958:	b9cb      	cbnz	r3, 800698e <xTaskResumeFromISR+0x5a>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 800695a:	682a      	ldr	r2, [r5, #0]
 800695c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800695e:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
 8006960:	42b3      	cmp	r3, r6
 8006962:	bf34      	ite	cc
 8006964:	2600      	movcc	r6, #0
 8006966:	2601      	movcs	r6, #1
					uxListRemove(  &( pxTCB->xGenericListItem ) );
 8006968:	1d27      	adds	r7, r4, #4
 800696a:	4638      	mov	r0, r7
 800696c:	f7ff fa91 	bl	8005e92 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8006970:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006972:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
 8006976:	4639      	mov	r1, r7
 8006978:	4293      	cmp	r3, r2
 800697a:	4a0c      	ldr	r2, [pc, #48]	; (80069ac <xTaskResumeFromISR+0x78>)
 800697c:	bf88      	it	hi
 800697e:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
 8006982:	2014      	movs	r0, #20
 8006984:	fb00 2003 	mla	r0, r0, r3, r2
 8006988:	f7ff fa5e 	bl	8005e48 <vListInsertEnd>
 800698c:	e006      	b.n	800699c <xTaskResumeFromISR+0x68>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 800698e:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 8006992:	f104 0118 	add.w	r1, r4, #24
 8006996:	f7ff fa57 	bl	8005e48 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
 800699a:	2600      	movs	r6, #0
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800699c:	4640      	mov	r0, r8
 800699e:	f7ff f8cd 	bl	8005b3c <vPortClearInterruptMask>

		return xYieldRequired;
	}
 80069a2:	4630      	mov	r0, r6
 80069a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80069a8:	20002a44 	.word	0x20002a44
 80069ac:	20002a58 	.word	0x20002a58

080069b0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 80069b0:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 80069b2:	2400      	movs	r4, #0

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 80069b4:	b085      	sub	sp, #20
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 80069b6:	9400      	str	r4, [sp, #0]
 80069b8:	9401      	str	r4, [sp, #4]
 80069ba:	9402      	str	r4, [sp, #8]
 80069bc:	9403      	str	r4, [sp, #12]
 80069be:	4810      	ldr	r0, [pc, #64]	; (8006a00 <vTaskStartScheduler+0x50>)
 80069c0:	4910      	ldr	r1, [pc, #64]	; (8006a04 <vTaskStartScheduler+0x54>)
 80069c2:	f44f 72a0 	mov.w	r2, #320	; 0x140
 80069c6:	4623      	mov	r3, r4
 80069c8:	f7ff fe14 	bl	80065f4 <xTaskGenericCreate>
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 80069cc:	2801      	cmp	r0, #1
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 80069ce:	4605      	mov	r5, r0
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 80069d0:	d10f      	bne.n	80069f2 <vTaskStartScheduler+0x42>
		{
			xReturn = xTimerCreateTimerTask();
 80069d2:	f000 fb85 	bl	80070e0 <xTimerCreateTimerTask>
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80069d6:	2801      	cmp	r0, #1

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 80069d8:	4605      	mov	r5, r0
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80069da:	d10a      	bne.n	80069f2 <vTaskStartScheduler+0x42>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 80069dc:	f7ff f898 	bl	8005b10 <ulPortSetInterruptMask>

		xSchedulerRunning = pdTRUE;
 80069e0:	4b09      	ldr	r3, [pc, #36]	; (8006a08 <vTaskStartScheduler+0x58>)
 80069e2:	f8c3 50dc 	str.w	r5, [r3, #220]	; 0xdc
		xTickCount = ( portTickType ) 0U;
 80069e6:	605c      	str	r4, [r3, #4]
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 80069e8:	b005      	add	sp, #20
 80069ea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 80069ee:	f7ff b8ed 	b.w	8005bcc <xPortStartScheduler>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 80069f2:	b915      	cbnz	r5, 80069fa <vTaskStartScheduler+0x4a>
 80069f4:	f7ff f88c 	bl	8005b10 <ulPortSetInterruptMask>
 80069f8:	e7fe      	b.n	80069f8 <vTaskStartScheduler+0x48>
	}
}
 80069fa:	b005      	add	sp, #20
 80069fc:	bd30      	pop	{r4, r5, pc}
 80069fe:	bf00      	nop
 8006a00:	08006c15 	.word	0x08006c15
 8006a04:	0800acfc 	.word	0x0800acfc
 8006a08:	20002a44 	.word	0x20002a44

08006a0c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 8006a0c:	b508      	push	{r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 8006a0e:	f7ff f87f 	bl	8005b10 <ulPortSetInterruptMask>
	xSchedulerRunning = pdFALSE;
 8006a12:	4b04      	ldr	r3, [pc, #16]	; (8006a24 <vTaskEndScheduler+0x18>)
 8006a14:	2200      	movs	r2, #0
 8006a16:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
	vPortEndScheduler();
}
 8006a1a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
	vPortEndScheduler();
 8006a1e:	f7ff b86b 	b.w	8005af8 <vPortEndScheduler>
 8006a22:	bf00      	nop
 8006a24:	20002a44 	.word	0x20002a44

08006a28 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8006a28:	4b03      	ldr	r3, [pc, #12]	; (8006a38 <vTaskSuspendAll+0x10>)
 8006a2a:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 8006a2e:	3201      	adds	r2, #1
 8006a30:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
 8006a34:	4770      	bx	lr
 8006a36:	bf00      	nop
 8006a38:	20002a44 	.word	0x20002a44

08006a3c <xTaskGetTickCount>:
	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCount( void )
{
 8006a3c:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 8006a3e:	f7ff f86f 	bl	8005b20 <vPortEnterCritical>
	{
		xTicks = xTickCount;
 8006a42:	4b03      	ldr	r3, [pc, #12]	; (8006a50 <xTaskGetTickCount+0x14>)
 8006a44:	685c      	ldr	r4, [r3, #4]
	}
	taskEXIT_CRITICAL();
 8006a46:	f7ff f87c 	bl	8005b42 <vPortExitCritical>

	return xTicks;
}
 8006a4a:	4620      	mov	r0, r4
 8006a4c:	bd10      	pop	{r4, pc}
 8006a4e:	bf00      	nop
 8006a50:	20002a44 	.word	0x20002a44

08006a54 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
 8006a54:	b510      	push	{r4, lr}
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006a56:	f7ff f85b 	bl	8005b10 <ulPortSetInterruptMask>
	xReturn = xTickCount;
 8006a5a:	4b03      	ldr	r3, [pc, #12]	; (8006a68 <xTaskGetTickCountFromISR+0x14>)
 8006a5c:	685c      	ldr	r4, [r3, #4]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8006a5e:	f7ff f86d 	bl	8005b3c <vPortClearInterruptMask>

	return xReturn;
}
 8006a62:	4620      	mov	r0, r4
 8006a64:	bd10      	pop	{r4, pc}
 8006a66:	bf00      	nop
 8006a68:	20002a44 	.word	0x20002a44

08006a6c <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
 8006a6c:	4b01      	ldr	r3, [pc, #4]	; (8006a74 <uxTaskGetNumberOfTasks+0x8>)
 8006a6e:	6918      	ldr	r0, [r3, #16]
}
 8006a70:	4770      	bx	lr
 8006a72:	bf00      	nop
 8006a74:	20002a44 	.word	0x20002a44

08006a78 <vTaskIncrementTick>:

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006a78:	4b31      	ldr	r3, [pc, #196]	; (8006b40 <vTaskIncrementTick+0xc8>)

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 8006a7a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006a7e:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 8006a82:	2a00      	cmp	r2, #0
 8006a84:	d154      	bne.n	8006b30 <vTaskIncrementTick+0xb8>
	{
		++xTickCount;
 8006a86:	685a      	ldr	r2, [r3, #4]
 8006a88:	3201      	adds	r2, #1
 8006a8a:	605a      	str	r2, [r3, #4]
		if( xTickCount == ( portTickType ) 0U )
 8006a8c:	685a      	ldr	r2, [r3, #4]
 8006a8e:	b9d2      	cbnz	r2, 8006ac6 <vTaskIncrementTick+0x4e>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 8006a90:	68da      	ldr	r2, [r3, #12]
 8006a92:	6812      	ldr	r2, [r2, #0]
 8006a94:	b112      	cbz	r2, 8006a9c <vTaskIncrementTick+0x24>
 8006a96:	f7ff f83b 	bl	8005b10 <ulPortSetInterruptMask>
 8006a9a:	e7fe      	b.n	8006a9a <vTaskIncrementTick+0x22>

			pxTemp = pxDelayedTaskList;
 8006a9c:	68da      	ldr	r2, [r3, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8006a9e:	6899      	ldr	r1, [r3, #8]
 8006aa0:	60d9      	str	r1, [r3, #12]
			pxOverflowDelayedTaskList = pxTemp;
 8006aa2:	609a      	str	r2, [r3, #8]
			xNumOfOverflows++;
 8006aa4:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 8006aa8:	3201      	adds	r2, #1
 8006aaa:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8006aae:	68da      	ldr	r2, [r3, #12]
 8006ab0:	6811      	ldr	r1, [r2, #0]
 8006ab2:	4a24      	ldr	r2, [pc, #144]	; (8006b44 <vTaskIncrementTick+0xcc>)
 8006ab4:	b911      	cbnz	r1, 8006abc <vTaskIncrementTick+0x44>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 8006ab6:	f04f 33ff 	mov.w	r3, #4294967295
 8006aba:	e003      	b.n	8006ac4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8006abc:	68db      	ldr	r3, [r3, #12]
 8006abe:	68db      	ldr	r3, [r3, #12]
 8006ac0:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8006ac2:	685b      	ldr	r3, [r3, #4]
 8006ac4:	6013      	str	r3, [r2, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8006ac6:	4c1e      	ldr	r4, [pc, #120]	; (8006b40 <vTaskIncrementTick+0xc8>)
 8006ac8:	4b1e      	ldr	r3, [pc, #120]	; (8006b44 <vTaskIncrementTick+0xcc>)
 8006aca:	6862      	ldr	r2, [r4, #4]
 8006acc:	681b      	ldr	r3, [r3, #0]
 8006ace:	429a      	cmp	r2, r3
 8006ad0:	d333      	bcc.n	8006b3a <vTaskIncrementTick+0xc2>
 8006ad2:	f104 0714 	add.w	r7, r4, #20
 8006ad6:	f04f 0814 	mov.w	r8, #20
 8006ada:	68e3      	ldr	r3, [r4, #12]
 8006adc:	681b      	ldr	r3, [r3, #0]
 8006ade:	b92b      	cbnz	r3, 8006aec <vTaskIncrementTick+0x74>
 8006ae0:	4b18      	ldr	r3, [pc, #96]	; (8006b44 <vTaskIncrementTick+0xcc>)
 8006ae2:	f04f 32ff 	mov.w	r2, #4294967295
 8006ae6:	601a      	str	r2, [r3, #0]
 8006ae8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006aec:	68e3      	ldr	r3, [r4, #12]
 8006aee:	68db      	ldr	r3, [r3, #12]
 8006af0:	68dd      	ldr	r5, [r3, #12]
 8006af2:	6862      	ldr	r2, [r4, #4]
 8006af4:	686b      	ldr	r3, [r5, #4]
 8006af6:	429a      	cmp	r2, r3
 8006af8:	d203      	bcs.n	8006b02 <vTaskIncrementTick+0x8a>
 8006afa:	4a12      	ldr	r2, [pc, #72]	; (8006b44 <vTaskIncrementTick+0xcc>)
 8006afc:	6013      	str	r3, [r2, #0]
 8006afe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006b02:	1d2e      	adds	r6, r5, #4
 8006b04:	4630      	mov	r0, r6
 8006b06:	f7ff f9c4 	bl	8005e92 <uxListRemove>
 8006b0a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8006b0c:	b11b      	cbz	r3, 8006b16 <vTaskIncrementTick+0x9e>
 8006b0e:	f105 0018 	add.w	r0, r5, #24
 8006b12:	f7ff f9be 	bl	8005e92 <uxListRemove>
 8006b16:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8006b18:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 8006b1c:	4631      	mov	r1, r6
 8006b1e:	4290      	cmp	r0, r2
 8006b20:	bf88      	it	hi
 8006b22:	f8c4 00e8 	strhi.w	r0, [r4, #232]	; 0xe8
 8006b26:	fb08 7000 	mla	r0, r8, r0, r7
 8006b2a:	f7ff f98d 	bl	8005e48 <vListInsertEnd>
 8006b2e:	e7d4      	b.n	8006ada <vTaskIncrementTick+0x62>
	}
	else
	{
		++uxMissedTicks;
 8006b30:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8006b34:	3201      	adds	r2, #1
 8006b36:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
 8006b3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006b3e:	bf00      	nop
 8006b40:	20002a44 	.word	0x20002a44
 8006b44:	20000030 	.word	0x20000030

08006b48 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8006b48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 8006b4c:	4c30      	ldr	r4, [pc, #192]	; (8006c10 <xTaskResumeAll+0xc8>)
 8006b4e:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 8006b52:	b913      	cbnz	r3, 8006b5a <xTaskResumeAll+0x12>
 8006b54:	f7fe ffdc 	bl	8005b10 <ulPortSetInterruptMask>
 8006b58:	e7fe      	b.n	8006b58 <xTaskResumeAll+0x10>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8006b5a:	f7fe ffe1 	bl	8005b20 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8006b5e:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 8006b62:	3b01      	subs	r3, #1
 8006b64:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006b68:	f8d4 60f0 	ldr.w	r6, [r4, #240]	; 0xf0
 8006b6c:	b10e      	cbz	r6, 8006b72 <xTaskResumeAll+0x2a>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8006b6e:	2400      	movs	r4, #0
 8006b70:	e049      	b.n	8006c06 <xTaskResumeAll+0xbe>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 8006b72:	6923      	ldr	r3, [r4, #16]
 8006b74:	b9f3      	cbnz	r3, 8006bb4 <xTaskResumeAll+0x6c>
 8006b76:	e7fa      	b.n	8006b6e <xTaskResumeAll+0x26>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 8006b78:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8006b7c:	68dd      	ldr	r5, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
					uxListRemove( &( pxTCB->xGenericListItem ) );
 8006b7e:	1d2f      	adds	r7, r5, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
 8006b80:	f105 0018 	add.w	r0, r5, #24
 8006b84:	f7ff f985 	bl	8005e92 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
 8006b88:	4638      	mov	r0, r7
 8006b8a:	f7ff f982 	bl	8005e92 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8006b8e:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8006b90:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 8006b94:	4639      	mov	r1, r7
 8006b96:	4290      	cmp	r0, r2
 8006b98:	bf88      	it	hi
 8006b9a:	f8c4 00e8 	strhi.w	r0, [r4, #232]	; 0xe8
 8006b9e:	fb09 8000 	mla	r0, r9, r0, r8
 8006ba2:	f7ff f951 	bl	8005e48 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006ba6:	6823      	ldr	r3, [r4, #0]
 8006ba8:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8006baa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
 8006bac:	429a      	cmp	r2, r3
 8006bae:	bf28      	it	cs
 8006bb0:	2601      	movcs	r6, #1
 8006bb2:	e003      	b.n	8006bbc <xTaskResumeAll+0x74>
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
					uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
 8006bb4:	f104 0814 	add.w	r8, r4, #20
 8006bb8:	f04f 0914 	mov.w	r9, #20
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 8006bbc:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 8006bc0:	4b13      	ldr	r3, [pc, #76]	; (8006c10 <xTaskResumeAll+0xc8>)
 8006bc2:	2a00      	cmp	r2, #0
 8006bc4:	d1d8      	bne.n	8006b78 <xTaskResumeAll+0x30>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 8006bc6:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8006bca:	b942      	cbnz	r2, 8006bde <xTaskResumeAll+0x96>
 8006bcc:	e014      	b.n	8006bf8 <xTaskResumeAll+0xb0>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
 8006bce:	f7ff ff53 	bl	8006a78 <vTaskIncrementTick>
						--uxMissedTicks;
 8006bd2:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8006bd6:	3b01      	subs	r3, #1
 8006bd8:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
 8006bdc:	e000      	b.n	8006be0 <xTaskResumeAll+0x98>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 8006bde:	461c      	mov	r4, r3
 8006be0:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8006be4:	2b00      	cmp	r3, #0
 8006be6:	d1f2      	bne.n	8006bce <xTaskResumeAll+0x86>
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 8006be8:	4b09      	ldr	r3, [pc, #36]	; (8006c10 <xTaskResumeAll+0xc8>)
 8006bea:	2200      	movs	r2, #0
 8006bec:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 8006bf0:	2401      	movs	r4, #1
					xMissedYield = pdFALSE;
					portYIELD_WITHIN_API();
 8006bf2:	f7fe ff82 	bl	8005afa <vPortYield>
 8006bf6:	e006      	b.n	8006c06 <xTaskResumeAll+0xbe>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8006bf8:	2e01      	cmp	r6, #1
 8006bfa:	d0f5      	beq.n	8006be8 <xTaskResumeAll+0xa0>
 8006bfc:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8006c00:	2b01      	cmp	r3, #1
 8006c02:	d1b4      	bne.n	8006b6e <xTaskResumeAll+0x26>
 8006c04:	e7f0      	b.n	8006be8 <xTaskResumeAll+0xa0>
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 8006c06:	f7fe ff9c 	bl	8005b42 <vPortExitCritical>

	return xAlreadyYielded;
}
 8006c0a:	4620      	mov	r0, r4
 8006c0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006c10:	20002a44 	.word	0x20002a44

08006c14 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8006c14:	b538      	push	{r3, r4, r5, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 8006c16:	4c16      	ldr	r4, [pc, #88]	; (8006c70 <prvIdleTask+0x5c>)
 8006c18:	e01e      	b.n	8006c58 <prvIdleTask+0x44>
		{
			vTaskSuspendAll();
 8006c1a:	f7ff ff05 	bl	8006a28 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8006c1e:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
			xTaskResumeAll();
 8006c22:	f7ff ff91 	bl	8006b48 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8006c26:	b1bd      	cbz	r5, 8006c58 <prvIdleTask+0x44>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 8006c28:	f7fe ff7a 	bl	8005b20 <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8006c2c:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8006c30:	68dd      	ldr	r5, [r3, #12]
					uxListRemove( &( pxTCB->xGenericListItem ) );
 8006c32:	1d28      	adds	r0, r5, #4
 8006c34:	f7ff f92d 	bl	8005e92 <uxListRemove>
					--uxCurrentNumberOfTasks;
 8006c38:	6923      	ldr	r3, [r4, #16]
 8006c3a:	3b01      	subs	r3, #1
 8006c3c:	6123      	str	r3, [r4, #16]
					--uxTasksDeleted;
 8006c3e:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8006c42:	3b01      	subs	r3, #1
 8006c44:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
				}
				taskEXIT_CRITICAL();
 8006c48:	f7fe ff7b 	bl	8005b42 <vPortExitCritical>
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8006c4c:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8006c4e:	f7fe ff17 	bl	8005a80 <vPortFree>
		vPortFree( pxTCB );
 8006c52:	4628      	mov	r0, r5
 8006c54:	f7fe ff14 	bl	8005a80 <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 8006c58:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8006c5c:	2b00      	cmp	r3, #0
 8006c5e:	d1dc      	bne.n	8006c1a <prvIdleTask+0x6>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8006c60:	6963      	ldr	r3, [r4, #20]
 8006c62:	2b01      	cmp	r3, #1
 8006c64:	d901      	bls.n	8006c6a <prvIdleTask+0x56>
			{
				taskYIELD();
 8006c66:	f7fe ff48 	bl	8005afa <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8006c6a:	f7fb f933 	bl	8001ed4 <vApplicationIdleHook>
				}
				xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 8006c6e:	e7f3      	b.n	8006c58 <prvIdleTask+0x44>
 8006c70:	20002a44 	.word	0x20002a44

08006c74 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8006c74:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 8006c76:	4604      	mov	r4, r0
 8006c78:	b918      	cbnz	r0, 8006c82 <vTaskDelay+0xe>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 8006c7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8006c7e:	f7fe bf3c 	b.w	8005afa <vPortYield>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
		{
			vTaskSuspendAll();
 8006c82:	f7ff fed1 	bl	8006a28 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8006c86:	4b07      	ldr	r3, [pc, #28]	; (8006ca4 <vTaskDelay+0x30>)
 8006c88:	685a      	ldr	r2, [r3, #4]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8006c8a:	6818      	ldr	r0, [r3, #0]
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8006c8c:	18a4      	adds	r4, r4, r2

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8006c8e:	3004      	adds	r0, #4
 8006c90:	f7ff f8ff 	bl	8005e92 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006c94:	4620      	mov	r0, r4
 8006c96:	f7ff fc8f 	bl	80065b8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8006c9a:	f7ff ff55 	bl	8006b48 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8006c9e:	2800      	cmp	r0, #0
 8006ca0:	d0eb      	beq.n	8006c7a <vTaskDelay+0x6>
		{
			portYIELD_WITHIN_API();
		}
	}
 8006ca2:	bd10      	pop	{r4, pc}
 8006ca4:	20002a44 	.word	0x20002a44

08006ca8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 8006ca8:	b538      	push	{r3, r4, r5, lr}
 8006caa:	460c      	mov	r4, r1
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
 8006cac:	4605      	mov	r5, r0
 8006cae:	b910      	cbnz	r0, 8006cb6 <vTaskDelayUntil+0xe>
 8006cb0:	f7fe ff2e 	bl	8005b10 <ulPortSetInterruptMask>
 8006cb4:	e7fe      	b.n	8006cb4 <vTaskDelayUntil+0xc>
		configASSERT( ( xTimeIncrement > 0U ) );
 8006cb6:	b911      	cbnz	r1, 8006cbe <vTaskDelayUntil+0x16>
 8006cb8:	f7fe ff2a 	bl	8005b10 <ulPortSetInterruptMask>
 8006cbc:	e7fe      	b.n	8006cbc <vTaskDelayUntil+0x14>

		vTaskSuspendAll();
 8006cbe:	f7ff feb3 	bl	8006a28 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xTickCount < *pxPreviousWakeTime )
 8006cc2:	4a13      	ldr	r2, [pc, #76]	; (8006d10 <vTaskDelayUntil+0x68>)
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8006cc4:	682b      	ldr	r3, [r5, #0]

			if( xTickCount < *pxPreviousWakeTime )
 8006cc6:	6851      	ldr	r1, [r2, #4]
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8006cc8:	191c      	adds	r4, r3, r4

			if( xTickCount < *pxPreviousWakeTime )
 8006cca:	4299      	cmp	r1, r3
 8006ccc:	d202      	bcs.n	8006cd4 <vTaskDelayUntil+0x2c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 8006cce:	429c      	cmp	r4, r3
 8006cd0:	d208      	bcs.n	8006ce4 <vTaskDelayUntil+0x3c>
 8006cd2:	e001      	b.n	8006cd8 <vTaskDelayUntil+0x30>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 8006cd4:	429c      	cmp	r4, r3
 8006cd6:	d307      	bcc.n	8006ce8 <vTaskDelayUntil+0x40>
 8006cd8:	6853      	ldr	r3, [r2, #4]
 8006cda:	429c      	cmp	r4, r3
 8006cdc:	bf94      	ite	ls
 8006cde:	2300      	movls	r3, #0
 8006ce0:	2301      	movhi	r3, #1
 8006ce2:	e002      	b.n	8006cea <vTaskDelayUntil+0x42>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 8006ce4:	2300      	movs	r3, #0
 8006ce6:	e000      	b.n	8006cea <vTaskDelayUntil+0x42>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
 8006ce8:	2301      	movs	r3, #1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8006cea:	602c      	str	r4, [r5, #0]

			if( xShouldDelay != pdFALSE )
 8006cec:	b13b      	cbz	r3, 8006cfe <vTaskDelayUntil+0x56>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8006cee:	4b08      	ldr	r3, [pc, #32]	; (8006d10 <vTaskDelayUntil+0x68>)
 8006cf0:	6818      	ldr	r0, [r3, #0]
 8006cf2:	3004      	adds	r0, #4
 8006cf4:	f7ff f8cd 	bl	8005e92 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006cf8:	4620      	mov	r0, r4
 8006cfa:	f7ff fc5d 	bl	80065b8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 8006cfe:	f7ff ff23 	bl	8006b48 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8006d02:	b918      	cbnz	r0, 8006d0c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
		}
	}
 8006d04:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8006d08:	f7fe bef7 	b.w	8005afa <vPortYield>
 8006d0c:	bd38      	pop	{r3, r4, r5, pc}
 8006d0e:	bf00      	nop
 8006d10:	20002a44 	.word	0x20002a44

08006d14 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8006d14:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8006d16:	4b26      	ldr	r3, [pc, #152]	; (8006db0 <vTaskSwitchContext+0x9c>)
 8006d18:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 8006d1c:	461c      	mov	r4, r3
 8006d1e:	b11a      	cbz	r2, 8006d28 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 8006d20:	2201      	movs	r2, #1
 8006d22:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
 8006d26:	bd38      	pop	{r3, r4, r5, pc}
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 8006d28:	681a      	ldr	r2, [r3, #0]
 8006d2a:	681b      	ldr	r3, [r3, #0]
 8006d2c:	6812      	ldr	r2, [r2, #0]
 8006d2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006d30:	429a      	cmp	r2, r3
 8006d32:	d804      	bhi.n	8006d3e <vTaskSwitchContext+0x2a>
 8006d34:	6820      	ldr	r0, [r4, #0]
 8006d36:	6821      	ldr	r1, [r4, #0]
 8006d38:	3134      	adds	r1, #52	; 0x34
 8006d3a:	f7fb f8ca 	bl	8001ed2 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 8006d3e:	6823      	ldr	r3, [r4, #0]
 8006d40:	491c      	ldr	r1, [pc, #112]	; (8006db4 <vTaskSwitchContext+0xa0>)
 8006d42:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006d44:	2214      	movs	r2, #20
 8006d46:	4d1a      	ldr	r5, [pc, #104]	; (8006db0 <vTaskSwitchContext+0x9c>)
 8006d48:	f001 f912 	bl	8007f70 <memcmp>
 8006d4c:	b188      	cbz	r0, 8006d72 <vTaskSwitchContext+0x5e>
 8006d4e:	6828      	ldr	r0, [r5, #0]
 8006d50:	6829      	ldr	r1, [r5, #0]
 8006d52:	3134      	adds	r1, #52	; 0x34
 8006d54:	f7fb f8bd 	bl	8001ed2 <vApplicationStackOverflowHook>
 8006d58:	e00b      	b.n	8006d72 <vTaskSwitchContext+0x5e>

		taskSELECT_HIGHEST_PRIORITY_TASK();
 8006d5a:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 8006d5e:	b913      	cbnz	r3, 8006d66 <vTaskSwitchContext+0x52>
 8006d60:	f7fe fed6 	bl	8005b10 <ulPortSetInterruptMask>
 8006d64:	e7fe      	b.n	8006d64 <vTaskSwitchContext+0x50>
 8006d66:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 8006d6a:	3b01      	subs	r3, #1
 8006d6c:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8006d70:	e001      	b.n	8006d76 <vTaskSwitchContext+0x62>
 8006d72:	4a0f      	ldr	r2, [pc, #60]	; (8006db0 <vTaskSwitchContext+0x9c>)
 8006d74:	2014      	movs	r0, #20
 8006d76:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 8006d7a:	490d      	ldr	r1, [pc, #52]	; (8006db0 <vTaskSwitchContext+0x9c>)
 8006d7c:	fb00 2303 	mla	r3, r0, r3, r2
 8006d80:	695b      	ldr	r3, [r3, #20]
 8006d82:	2b00      	cmp	r3, #0
 8006d84:	d0e9      	beq.n	8006d5a <vTaskSwitchContext+0x46>
 8006d86:	f8d1 30e8 	ldr.w	r3, [r1, #232]	; 0xe8
 8006d8a:	2214      	movs	r2, #20
 8006d8c:	3114      	adds	r1, #20
 8006d8e:	fb02 1303 	mla	r3, r2, r3, r1
 8006d92:	685a      	ldr	r2, [r3, #4]
 8006d94:	f103 0108 	add.w	r1, r3, #8
 8006d98:	6852      	ldr	r2, [r2, #4]
 8006d9a:	428a      	cmp	r2, r1
 8006d9c:	605a      	str	r2, [r3, #4]
 8006d9e:	bf04      	itt	eq
 8006da0:	6852      	ldreq	r2, [r2, #4]
 8006da2:	605a      	streq	r2, [r3, #4]
 8006da4:	685b      	ldr	r3, [r3, #4]
 8006da6:	68da      	ldr	r2, [r3, #12]
 8006da8:	4b01      	ldr	r3, [pc, #4]	; (8006db0 <vTaskSwitchContext+0x9c>)
 8006daa:	601a      	str	r2, [r3, #0]
 8006dac:	bd38      	pop	{r3, r4, r5, pc}
 8006dae:	bf00      	nop
 8006db0:	20002a44 	.word	0x20002a44
 8006db4:	0800a858 	.word	0x0800a858

08006db8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle xTaskToSuspend )
	{
 8006db8:	b570      	push	{r4, r5, r6, lr}
 8006dba:	4604      	mov	r4, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 8006dbc:	f7fe feb0 	bl	8005b20 <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( xTaskToSuspend == ( xTaskHandle ) pxCurrentTCB )
 8006dc0:	4b17      	ldr	r3, [pc, #92]	; (8006e20 <vTaskSuspend+0x68>)
 8006dc2:	681a      	ldr	r2, [r3, #0]
 8006dc4:	4294      	cmp	r4, r2
 8006dc6:	d001      	beq.n	8006dcc <vTaskSuspend+0x14>
			{
				xTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8006dc8:	4625      	mov	r5, r4
 8006dca:	b914      	cbnz	r4, 8006dd2 <vTaskSuspend+0x1a>
 8006dcc:	681d      	ldr	r5, [r3, #0]
 8006dce:	2400      	movs	r4, #0
 8006dd0:	e7ff      	b.n	8006dd2 <vTaskSuspend+0x1a>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8006dd2:	1d2e      	adds	r6, r5, #4
 8006dd4:	4630      	mov	r0, r6
 8006dd6:	f7ff f85c 	bl	8005e92 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 8006dda:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8006ddc:	b11b      	cbz	r3, 8006de6 <vTaskSuspend+0x2e>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
 8006dde:	f105 0018 	add.w	r0, r5, #24
 8006de2:	f7ff f856 	bl	8005e92 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 8006de6:	4d0e      	ldr	r5, [pc, #56]	; (8006e20 <vTaskSuspend+0x68>)
 8006de8:	4631      	mov	r1, r6
 8006dea:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 8006dee:	f7ff f82b 	bl	8005e48 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 8006df2:	f7fe fea6 	bl	8005b42 <vPortExitCritical>

		if( ( void * ) xTaskToSuspend == NULL )
 8006df6:	2c00      	cmp	r4, #0
 8006df8:	d111      	bne.n	8006e1e <vTaskSuspend+0x66>
		{
			if( xSchedulerRunning != pdFALSE )
 8006dfa:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 8006dfe:	b11b      	cbz	r3, 8006e08 <vTaskSuspend+0x50>
				{
					vTaskSwitchContext();
				}
			}
		}
	}
 8006e00:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if( ( void * ) xTaskToSuspend == NULL )
		{
			if( xSchedulerRunning != pdFALSE )
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
 8006e04:	f7fe be79 	b.w	8005afa <vPortYield>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 8006e08:	f8d5 20c8 	ldr.w	r2, [r5, #200]	; 0xc8
 8006e0c:	692b      	ldr	r3, [r5, #16]
 8006e0e:	429a      	cmp	r2, r3
 8006e10:	d101      	bne.n	8006e16 <vTaskSuspend+0x5e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 8006e12:	602c      	str	r4, [r5, #0]
 8006e14:	bd70      	pop	{r4, r5, r6, pc}
				{
					vTaskSwitchContext();
				}
			}
		}
	}
 8006e16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 8006e1a:	f7ff bf7b 	b.w	8006d14 <vTaskSwitchContext>
 8006e1e:	bd70      	pop	{r4, r5, r6, pc}
 8006e20:	20002a44 	.word	0x20002a44

08006e24 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
 8006e24:	b538      	push	{r3, r4, r5, lr}
 8006e26:	460d      	mov	r5, r1
portTickType xTimeToWake;

	configASSERT( pxEventList );
 8006e28:	b910      	cbnz	r0, 8006e30 <vTaskPlaceOnEventList+0xc>
 8006e2a:	f7fe fe71 	bl	8005b10 <ulPortSetInterruptMask>
 8006e2e:	e7fe      	b.n	8006e2e <vTaskPlaceOnEventList+0xa>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 8006e30:	4c0c      	ldr	r4, [pc, #48]	; (8006e64 <vTaskPlaceOnEventList+0x40>)
 8006e32:	6821      	ldr	r1, [r4, #0]
 8006e34:	3118      	adds	r1, #24
 8006e36:	f7ff f814 	bl	8005e62 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8006e3a:	6820      	ldr	r0, [r4, #0]
 8006e3c:	3004      	adds	r0, #4
 8006e3e:	f7ff f828 	bl	8005e92 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 8006e42:	1c6a      	adds	r2, r5, #1
 8006e44:	d107      	bne.n	8006e56 <vTaskPlaceOnEventList+0x32>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8006e46:	4620      	mov	r0, r4
 8006e48:	f850 1bc8 	ldr.w	r1, [r0], #200
 8006e4c:	3104      	adds	r1, #4
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8006e4e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8006e52:	f7fe bff9 	b.w	8005e48 <vListInsertEnd>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 8006e56:	6860      	ldr	r0, [r4, #4]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006e58:	1828      	adds	r0, r5, r0
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8006e5a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006e5e:	f7ff bbab 	b.w	80065b8 <prvAddCurrentTaskToDelayedList>
 8006e62:	bf00      	nop
 8006e64:	20002a44 	.word	0x20002a44

08006e68 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
 8006e68:	b538      	push	{r3, r4, r5, lr}
 8006e6a:	460d      	mov	r5, r1
	portTickType xTimeToWake;

		configASSERT( pxEventList );
 8006e6c:	b910      	cbnz	r0, 8006e74 <vTaskPlaceOnEventListRestricted+0xc>
 8006e6e:	f7fe fe4f 	bl	8005b10 <ulPortSetInterruptMask>
 8006e72:	e7fe      	b.n	8006e72 <vTaskPlaceOnEventListRestricted+0xa>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 8006e74:	4c07      	ldr	r4, [pc, #28]	; (8006e94 <vTaskPlaceOnEventListRestricted+0x2c>)
 8006e76:	6821      	ldr	r1, [r4, #0]
 8006e78:	3118      	adds	r1, #24
 8006e7a:	f7fe ffe5 	bl	8005e48 <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8006e7e:	6820      	ldr	r0, [r4, #0]
 8006e80:	3004      	adds	r0, #4
 8006e82:	f7ff f806 	bl	8005e92 <uxListRemove>
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
 8006e86:	6860      	ldr	r0, [r4, #4]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006e88:	1828      	adds	r0, r5, r0
	}
 8006e8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006e8e:	f7ff bb93 	b.w	80065b8 <prvAddCurrentTaskToDelayedList>
 8006e92:	bf00      	nop
 8006e94:	20002a44 	.word	0x20002a44

08006e98 <xTaskRemoveFromEventList>:
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8006e98:	68c3      	ldr	r3, [r0, #12]

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 8006e9a:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8006e9c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8006e9e:	b914      	cbnz	r4, 8006ea6 <xTaskRemoveFromEventList+0xe>
 8006ea0:	f7fe fe36 	bl	8005b10 <ulPortSetInterruptMask>
 8006ea4:	e7fe      	b.n	8006ea4 <xTaskRemoveFromEventList+0xc>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8006ea6:	f104 0618 	add.w	r6, r4, #24

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006eaa:	4d12      	ldr	r5, [pc, #72]	; (8006ef4 <xTaskRemoveFromEventList+0x5c>)

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8006eac:	4630      	mov	r0, r6
 8006eae:	f7fe fff0 	bl	8005e92 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006eb2:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 8006eb6:	b97b      	cbnz	r3, 8006ed8 <xTaskRemoveFromEventList+0x40>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 8006eb8:	1d26      	adds	r6, r4, #4
 8006eba:	4630      	mov	r0, r6
 8006ebc:	f7fe ffe9 	bl	8005e92 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
 8006ec0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006ec2:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
 8006ec6:	4293      	cmp	r3, r2
 8006ec8:	4a0b      	ldr	r2, [pc, #44]	; (8006ef8 <xTaskRemoveFromEventList+0x60>)
 8006eca:	bf88      	it	hi
 8006ecc:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
 8006ed0:	2014      	movs	r0, #20
 8006ed2:	fb00 2003 	mla	r0, r0, r3, r2
 8006ed6:	e001      	b.n	8006edc <xTaskRemoveFromEventList+0x44>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8006ed8:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 8006edc:	4631      	mov	r1, r6
 8006ede:	f7fe ffb3 	bl	8005e48 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006ee2:	4b04      	ldr	r3, [pc, #16]	; (8006ef4 <xTaskRemoveFromEventList+0x5c>)
 8006ee4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8006ee6:	681b      	ldr	r3, [r3, #0]
 8006ee8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8006eea:	4298      	cmp	r0, r3
 8006eec:	bf34      	ite	cc
 8006eee:	2000      	movcc	r0, #0
 8006ef0:	2001      	movcs	r0, #1
 8006ef2:	bd70      	pop	{r4, r5, r6, pc}
 8006ef4:	20002a44 	.word	0x20002a44
 8006ef8:	20002a58 	.word	0x20002a58

08006efc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 8006efc:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 8006efe:	b910      	cbnz	r0, 8006f06 <vTaskSetTimeOutState+0xa>
 8006f00:	f7fe fe06 	bl	8005b10 <ulPortSetInterruptMask>
 8006f04:	e7fe      	b.n	8006f04 <vTaskSetTimeOutState+0x8>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8006f06:	4b03      	ldr	r3, [pc, #12]	; (8006f14 <vTaskSetTimeOutState+0x18>)
 8006f08:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
	pxTimeOut->xTimeOnEntering = xTickCount;
 8006f0c:	685b      	ldr	r3, [r3, #4]
 8006f0e:	e880 000c 	stmia.w	r0, {r2, r3}
 8006f12:	bd08      	pop	{r3, pc}
 8006f14:	20002a44 	.word	0x20002a44

08006f18 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 8006f18:	b538      	push	{r3, r4, r5, lr}
 8006f1a:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
 8006f1c:	4604      	mov	r4, r0
 8006f1e:	b910      	cbnz	r0, 8006f26 <xTaskCheckForTimeOut+0xe>
 8006f20:	f7fe fdf6 	bl	8005b10 <ulPortSetInterruptMask>
 8006f24:	e7fe      	b.n	8006f24 <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 8006f26:	b911      	cbnz	r1, 8006f2e <xTaskCheckForTimeOut+0x16>
 8006f28:	f7fe fdf2 	bl	8005b10 <ulPortSetInterruptMask>
 8006f2c:	e7fe      	b.n	8006f2c <xTaskCheckForTimeOut+0x14>

	taskENTER_CRITICAL();
 8006f2e:	f7fe fdf7 	bl	8005b20 <vPortEnterCritical>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8006f32:	682b      	ldr	r3, [r5, #0]
 8006f34:	1c59      	adds	r1, r3, #1
 8006f36:	d017      	beq.n	8006f68 <xTaskCheckForTimeOut+0x50>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
 8006f38:	4a0f      	ldr	r2, [pc, #60]	; (8006f78 <xTaskCheckForTimeOut+0x60>)
 8006f3a:	6821      	ldr	r1, [r4, #0]
 8006f3c:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
 8006f40:	4288      	cmp	r0, r1
 8006f42:	4611      	mov	r1, r2
 8006f44:	d003      	beq.n	8006f4e <xTaskCheckForTimeOut+0x36>
 8006f46:	6850      	ldr	r0, [r2, #4]
 8006f48:	6862      	ldr	r2, [r4, #4]
 8006f4a:	4290      	cmp	r0, r2
 8006f4c:	d20e      	bcs.n	8006f6c <xTaskCheckForTimeOut+0x54>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
 8006f4e:	6849      	ldr	r1, [r1, #4]
 8006f50:	6862      	ldr	r2, [r4, #4]
 8006f52:	1a89      	subs	r1, r1, r2
 8006f54:	4299      	cmp	r1, r3
 8006f56:	d209      	bcs.n	8006f6c <xTaskCheckForTimeOut+0x54>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 8006f58:	4907      	ldr	r1, [pc, #28]	; (8006f78 <xTaskCheckForTimeOut+0x60>)
			vTaskSetTimeOutState( pxTimeOut );
 8006f5a:	4620      	mov	r0, r4
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 8006f5c:	6849      	ldr	r1, [r1, #4]
 8006f5e:	1a52      	subs	r2, r2, r1
 8006f60:	18d3      	adds	r3, r2, r3
 8006f62:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8006f64:	f7ff ffca 	bl	8006efc <vTaskSetTimeOutState>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
 8006f68:	2400      	movs	r4, #0
 8006f6a:	e000      	b.n	8006f6e <xTaskCheckForTimeOut+0x56>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8006f6c:	2401      	movs	r4, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 8006f6e:	f7fe fde8 	bl	8005b42 <vPortExitCritical>

	return xReturn;
}
 8006f72:	4620      	mov	r0, r4
 8006f74:	bd38      	pop	{r3, r4, r5, pc}
 8006f76:	bf00      	nop
 8006f78:	20002a44 	.word	0x20002a44

08006f7c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
 8006f7c:	4b02      	ldr	r3, [pc, #8]	; (8006f88 <vTaskMissedYield+0xc>)
 8006f7e:	2201      	movs	r2, #1
 8006f80:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
 8006f84:	4770      	bx	lr
 8006f86:	bf00      	nop
 8006f88:	20002a44 	.word	0x20002a44

08006f8c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8006f8c:	4b01      	ldr	r3, [pc, #4]	; (8006f94 <xTaskGetCurrentTaskHandle+0x8>)
 8006f8e:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
 8006f90:	4770      	bx	lr
 8006f92:	bf00      	nop
 8006f94:	20002a44 	.word	0x20002a44

08006f98 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
 8006f98:	4b05      	ldr	r3, [pc, #20]	; (8006fb0 <xTaskGetSchedulerState+0x18>)
 8006f9a:	f8d3 00dc 	ldr.w	r0, [r3, #220]	; 0xdc
 8006f9e:	b128      	cbz	r0, 8006fac <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006fa0:	f8d3 00f0 	ldr.w	r0, [r3, #240]	; 0xf0
			{
				xReturn = taskSCHEDULER_RUNNING;
 8006fa4:	2800      	cmp	r0, #0
 8006fa6:	bf14      	ite	ne
 8006fa8:	2002      	movne	r0, #2
 8006faa:	2001      	moveq	r0, #1
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
 8006fac:	4770      	bx	lr
 8006fae:	bf00      	nop
 8006fb0:	20002a44 	.word	0x20002a44

08006fb4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
 8006fb4:	b570      	push	{r4, r5, r6, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 8006fb6:	4604      	mov	r4, r0
 8006fb8:	2800      	cmp	r0, #0
 8006fba:	d02b      	beq.n	8007014 <vTaskPriorityInherit+0x60>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8006fbc:	4d16      	ldr	r5, [pc, #88]	; (8007018 <vTaskPriorityInherit+0x64>)
 8006fbe:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8006fc0:	682b      	ldr	r3, [r5, #0]
 8006fc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006fc4:	429a      	cmp	r2, r3
 8006fc6:	d225      	bcs.n	8007014 <vTaskPriorityInherit+0x60>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
 8006fc8:	462b      	mov	r3, r5
 8006fca:	f853 1b14 	ldr.w	r1, [r3], #20
 8006fce:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8006fd0:	f1c1 0105 	rsb	r1, r1, #5
 8006fd4:	6181      	str	r1, [r0, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8006fd6:	2114      	movs	r1, #20
 8006fd8:	fb01 3302 	mla	r3, r1, r2, r3
 8006fdc:	6941      	ldr	r1, [r0, #20]
 8006fde:	4299      	cmp	r1, r3
 8006fe0:	d115      	bne.n	800700e <vTaskPriorityInherit+0x5a>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8006fe2:	1d06      	adds	r6, r0, #4
 8006fe4:	4630      	mov	r0, r6
 8006fe6:	f7fe ff54 	bl	8005e92 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006fea:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyQueue( pxTCB );
 8006fec:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006ff0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
 8006ff2:	4631      	mov	r1, r6
 8006ff4:	4293      	cmp	r3, r2
 8006ff6:	4a09      	ldr	r2, [pc, #36]	; (800701c <vTaskPriorityInherit+0x68>)
 8006ff8:	bf88      	it	hi
 8006ffa:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
 8006ffe:	2014      	movs	r0, #20
 8007000:	fb00 2003 	mla	r0, r0, r3, r2
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8007004:	62e3      	str	r3, [r4, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
 8007006:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyQueue( pxTCB );
 800700a:	f7fe bf1d 	b.w	8005e48 <vListInsertEnd>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800700e:	682b      	ldr	r3, [r5, #0]
 8007010:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007012:	62c3      	str	r3, [r0, #44]	; 0x2c
 8007014:	bd70      	pop	{r4, r5, r6, pc}
 8007016:	bf00      	nop
 8007018:	20002a44 	.word	0x20002a44
 800701c:	20002a58 	.word	0x20002a58

08007020 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
 8007020:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
 8007022:	4604      	mov	r4, r0
 8007024:	b1e0      	cbz	r0, 8007060 <vTaskPriorityDisinherit+0x40>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8007026:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8007028:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800702a:	429a      	cmp	r2, r3
 800702c:	d018      	beq.n	8007060 <vTaskPriorityDisinherit+0x40>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 800702e:	1d05      	adds	r5, r0, #4
 8007030:	4628      	mov	r0, r5
 8007032:	f7fe ff2e 	bl	8005e92 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8007036:	6c23      	ldr	r3, [r4, #64]	; 0x40
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 8007038:	f1c3 0205 	rsb	r2, r3, #5
 800703c:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
 800703e:	4a09      	ldr	r2, [pc, #36]	; (8007064 <vTaskPriorityDisinherit+0x44>)
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8007040:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
 8007042:	f8d2 10e8 	ldr.w	r1, [r2, #232]	; 0xe8
 8007046:	428b      	cmp	r3, r1
 8007048:	bf88      	it	hi
 800704a:	f8c2 30e8 	strhi.w	r3, [r2, #232]	; 0xe8
 800704e:	4a06      	ldr	r2, [pc, #24]	; (8007068 <vTaskPriorityDisinherit+0x48>)
 8007050:	2014      	movs	r0, #20
 8007052:	fb00 2003 	mla	r0, r0, r3, r2
 8007056:	4629      	mov	r1, r5
			}
		}
	}
 8007058:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
 800705c:	f7fe bef4 	b.w	8005e48 <vListInsertEnd>
 8007060:	bd38      	pop	{r3, r4, r5, pc}
 8007062:	bf00      	nop
 8007064:	20002a44 	.word	0x20002a44
 8007068:	20002a58 	.word	0x20002a58

0800706c <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 800706c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 800706e:	4c0d      	ldr	r4, [pc, #52]	; (80070a4 <prvCheckForValidListAndQueue+0x38>)
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8007070:	f7fe fd56 	bl	8005b20 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8007074:	6825      	ldr	r5, [r4, #0]
 8007076:	b985      	cbnz	r5, 800709a <prvCheckForValidListAndQueue+0x2e>
		{
			vListInitialise( &xActiveTimerList1 );
 8007078:	1d27      	adds	r7, r4, #4
 800707a:	4638      	mov	r0, r7
			vListInitialise( &xActiveTimerList2 );
 800707c:	f104 0618 	add.w	r6, r4, #24
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8007080:	f7fe fed4 	bl	8005e2c <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8007084:	4630      	mov	r0, r6
 8007086:	f7fe fed1 	bl	8005e2c <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 800708a:	2005      	movs	r0, #5
 800708c:	210c      	movs	r1, #12
 800708e:	462a      	mov	r2, r5
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8007090:	62e7      	str	r7, [r4, #44]	; 0x2c
			pxOverflowTimerList = &xActiveTimerList2;
 8007092:	6326      	str	r6, [r4, #48]	; 0x30
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 8007094:	f7fe ffb3 	bl	8005ffe <xQueueGenericCreate>
 8007098:	6020      	str	r0, [r4, #0]
		}
	}
	taskEXIT_CRITICAL();
}
 800709a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
		}
	}
	taskEXIT_CRITICAL();
 800709e:	f7fe bd50 	b.w	8005b42 <vPortExitCritical>
 80070a2:	bf00      	nop
 80070a4:	20002b44 	.word	0x20002b44

080070a8 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 80070a8:	b510      	push	{r4, lr}
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 80070aa:	4291      	cmp	r1, r2
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 80070ac:	4604      	mov	r4, r0
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 80070ae:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80070b0:	6120      	str	r0, [r4, #16]

	if( xNextExpiryTime <= xTimeNow )
 80070b2:	d806      	bhi.n	80070c2 <prvInsertTimerInActiveList+0x1a>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 80070b4:	6981      	ldr	r1, [r0, #24]
 80070b6:	1ad2      	subs	r2, r2, r3
 80070b8:	428a      	cmp	r2, r1
 80070ba:	d20d      	bcs.n	80070d8 <prvInsertTimerInActiveList+0x30>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 80070bc:	4b07      	ldr	r3, [pc, #28]	; (80070dc <prvInsertTimerInActiveList+0x34>)
 80070be:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80070c0:	e005      	b.n	80070ce <prvInsertTimerInActiveList+0x26>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80070c2:	429a      	cmp	r2, r3
 80070c4:	d201      	bcs.n	80070ca <prvInsertTimerInActiveList+0x22>
 80070c6:	4299      	cmp	r1, r3
 80070c8:	d206      	bcs.n	80070d8 <prvInsertTimerInActiveList+0x30>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80070ca:	4b04      	ldr	r3, [pc, #16]	; (80070dc <prvInsertTimerInActiveList+0x34>)
 80070cc:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80070ce:	1d21      	adds	r1, r4, #4
 80070d0:	f7fe fec7 	bl	8005e62 <vListInsert>
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
 80070d4:	2000      	movs	r0, #0
 80070d6:	bd10      	pop	{r4, pc}
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 80070d8:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 80070da:	bd10      	pop	{r4, pc}
 80070dc:	20002b44 	.word	0x20002b44

080070e0 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
 80070e0:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 80070e2:	f7ff ffc3 	bl	800706c <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 80070e6:	4b0b      	ldr	r3, [pc, #44]	; (8007114 <xTimerCreateTimerTask+0x34>)
 80070e8:	681b      	ldr	r3, [r3, #0]
 80070ea:	b913      	cbnz	r3, 80070f2 <xTimerCreateTimerTask+0x12>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
		}
		#endif
	}

	configASSERT( xReturn );
 80070ec:	f7fe fd10 	bl	8005b10 <ulPortSetInterruptMask>
 80070f0:	e00d      	b.n	800710e <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 80070f2:	2303      	movs	r3, #3
 80070f4:	9300      	str	r3, [sp, #0]
 80070f6:	2300      	movs	r3, #0
 80070f8:	9301      	str	r3, [sp, #4]
 80070fa:	9302      	str	r3, [sp, #8]
 80070fc:	9303      	str	r3, [sp, #12]
 80070fe:	4806      	ldr	r0, [pc, #24]	; (8007118 <xTimerCreateTimerTask+0x38>)
 8007100:	4906      	ldr	r1, [pc, #24]	; (800711c <xTimerCreateTimerTask+0x3c>)
 8007102:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8007106:	f7ff fa75 	bl	80065f4 <xTaskGenericCreate>
		}
		#endif
	}

	configASSERT( xReturn );
 800710a:	b908      	cbnz	r0, 8007110 <xTimerCreateTimerTask+0x30>
 800710c:	e7ee      	b.n	80070ec <xTimerCreateTimerTask+0xc>
 800710e:	e7fe      	b.n	800710e <xTimerCreateTimerTask+0x2e>
	return xReturn;
}
 8007110:	b005      	add	sp, #20
 8007112:	bd00      	pop	{pc}
 8007114:	20002b44 	.word	0x20002b44
 8007118:	08007211 	.word	0x08007211
 800711c:	0800ad01 	.word	0x0800ad01

08007120 <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
 8007120:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007124:	4680      	mov	r8, r0
 8007126:	4617      	mov	r7, r2
 8007128:	461e      	mov	r6, r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 800712a:	460d      	mov	r5, r1
 800712c:	b911      	cbnz	r1, 8007134 <xTimerCreate+0x14>
	{
		pxNewTimer = NULL;
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
 800712e:	f7fe fcef 	bl	8005b10 <ulPortSetInterruptMask>
 8007132:	e7fe      	b.n	8007132 <xTimerCreate+0x12>
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 8007134:	2028      	movs	r0, #40	; 0x28
 8007136:	f7fe fc75 	bl	8005a24 <pvPortMalloc>
		if( pxNewTimer != NULL )
 800713a:	4604      	mov	r4, r0
 800713c:	b158      	cbz	r0, 8007156 <xTimerCreate+0x36>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
 800713e:	f7ff ff95 	bl	800706c <prvCheckForValidListAndQueue>
			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
			pxNewTimer->uxAutoReload = uxAutoReload;
			pxNewTimer->pvTimerID = pvTimerID;
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8007142:	9b06      	ldr	r3, [sp, #24]
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
 8007144:	f8c4 8000 	str.w	r8, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8007148:	61a5      	str	r5, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
 800714a:	61e7      	str	r7, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
 800714c:	6226      	str	r6, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 800714e:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8007150:	1d20      	adds	r0, r4, #4
 8007152:	f7fe fe76 	bl	8005e42 <vListInitialiseItem>
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
}
 8007156:	4620      	mov	r0, r4
 8007158:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800715c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 800715c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800715e:	4d0f      	ldr	r5, [pc, #60]	; (800719c <xTimerGenericCommand+0x40>)
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 8007160:	4606      	mov	r6, r0
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8007162:	6828      	ldr	r0, [r5, #0]
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 8007164:	461c      	mov	r4, r3
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8007166:	b1b0      	cbz	r0, 8007196 <xTimerGenericCommand+0x3a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8007168:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
 800716a:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
 800716c:	9603      	str	r6, [sp, #12]

		if( pxHigherPriorityTaskWoken == NULL )
 800716e:	b96b      	cbnz	r3, 800718c <xTimerGenericCommand+0x30>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8007170:	f7ff ff12 	bl	8006f98 <xTaskGetSchedulerState>
 8007174:	2801      	cmp	r0, #1
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8007176:	bf18      	it	ne
 8007178:	4622      	movne	r2, r4

		if( pxHigherPriorityTaskWoken == NULL )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 800717a:	6828      	ldr	r0, [r5, #0]
 800717c:	a901      	add	r1, sp, #4
 800717e:	bf06      	itte	eq
 8007180:	9a08      	ldreq	r2, [sp, #32]
 8007182:	4623      	moveq	r3, r4
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8007184:	4613      	movne	r3, r2
 8007186:	f7fe ff5a 	bl	800603e <xQueueGenericSend>
 800718a:	e004      	b.n	8007196 <xTimerGenericCommand+0x3a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800718c:	461a      	mov	r2, r3
 800718e:	a901      	add	r1, sp, #4
 8007190:	2300      	movs	r3, #0
 8007192:	f7fe fff6 	bl	8006182 <xQueueGenericSendFromISR>

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
 8007196:	b004      	add	sp, #16
 8007198:	bd70      	pop	{r4, r5, r6, pc}
 800719a:	bf00      	nop
 800719c:	20002b44 	.word	0x20002b44

080071a0 <prvSwitchTimerLists.isra.1>:
		}
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
 80071a0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80071a4:	4e19      	ldr	r6, [pc, #100]	; (800720c <prvSwitchTimerLists.isra.1+0x6c>)
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 80071a6:	f04f 0800 	mov.w	r8, #0
 80071aa:	e024      	b.n	80071f6 <prvSwitchTimerLists.isra.1+0x56>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80071ac:	68da      	ldr	r2, [r3, #12]
 80071ae:	6815      	ldr	r5, [r2, #0]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 80071b0:	68db      	ldr	r3, [r3, #12]
 80071b2:	68dc      	ldr	r4, [r3, #12]
		uxListRemove( &( pxTimer->xTimerListItem ) );
 80071b4:	1d27      	adds	r7, r4, #4
 80071b6:	4638      	mov	r0, r7
 80071b8:	f7fe fe6b 	bl	8005e92 <uxListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 80071bc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80071be:	4620      	mov	r0, r4
 80071c0:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 80071c2:	69e3      	ldr	r3, [r4, #28]
 80071c4:	2b01      	cmp	r3, #1
 80071c6:	d116      	bne.n	80071f6 <prvSwitchTimerLists.isra.1+0x56>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80071c8:	69a3      	ldr	r3, [r4, #24]
 80071ca:	18eb      	adds	r3, r5, r3
			if( xReloadTime > xNextExpireTime )
 80071cc:	42ab      	cmp	r3, r5
 80071ce:	d906      	bls.n	80071de <prvSwitchTimerLists.isra.1+0x3e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80071d0:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80071d2:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80071d4:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80071d6:	4639      	mov	r1, r7
 80071d8:	f7fe fe43 	bl	8005e62 <vListInsert>
 80071dc:	e00b      	b.n	80071f6 <prvSwitchTimerLists.isra.1+0x56>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 80071de:	2100      	movs	r1, #0
 80071e0:	f8cd 8000 	str.w	r8, [sp]
 80071e4:	4620      	mov	r0, r4
 80071e6:	462a      	mov	r2, r5
 80071e8:	460b      	mov	r3, r1
 80071ea:	f7ff ffb7 	bl	800715c <xTimerGenericCommand>
				configASSERT( xResult );
 80071ee:	b910      	cbnz	r0, 80071f6 <prvSwitchTimerLists.isra.1+0x56>
 80071f0:	f7fe fc8e 	bl	8005b10 <ulPortSetInterruptMask>
 80071f4:	e7fe      	b.n	80071f4 <prvSwitchTimerLists.isra.1+0x54>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80071f6:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80071f8:	4a04      	ldr	r2, [pc, #16]	; (800720c <prvSwitchTimerLists.isra.1+0x6c>)
 80071fa:	6819      	ldr	r1, [r3, #0]
 80071fc:	2900      	cmp	r1, #0
 80071fe:	d1d5      	bne.n	80071ac <prvSwitchTimerLists.isra.1+0xc>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8007200:	6b11      	ldr	r1, [r2, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
 8007202:	6313      	str	r3, [r2, #48]	; 0x30
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8007204:	62d1      	str	r1, [r2, #44]	; 0x2c
	pxOverflowTimerList = pxTemp;
}
 8007206:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
 800720a:	bf00      	nop
 800720c:	20002b44 	.word	0x20002b44

08007210 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 8007210:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8007214:	4d52      	ldr	r5, [pc, #328]	; (8007360 <prvTimerTask+0x150>)
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 8007216:	b087      	sub	sp, #28
 8007218:	46a8      	mov	r8, r5
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800721a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800721c:	681a      	ldr	r2, [r3, #0]
 800721e:	f1d2 0901 	rsbs	r9, r2, #1
 8007222:	bf38      	it	cc
 8007224:	f04f 0900 	movcc.w	r9, #0
	if( *pxListWasEmpty == pdFALSE )
 8007228:	f1b9 0f00 	cmp.w	r9, #0
 800722c:	d102      	bne.n	8007234 <prvTimerTask+0x24>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800722e:	68db      	ldr	r3, [r3, #12]
 8007230:	681e      	ldr	r6, [r3, #0]
 8007232:	e000      	b.n	8007236 <prvTimerTask+0x26>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
 8007234:	2600      	movs	r6, #0
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
 8007236:	f7ff fbf7 	bl	8006a28 <vTaskSuspendAll>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 800723a:	f7ff fbff 	bl	8006a3c <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 800723e:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 8007242:	4607      	mov	r7, r0

	if( xTimeNow < xLastTime )
 8007244:	4298      	cmp	r0, r3
 8007246:	d203      	bcs.n	8007250 <prvTimerTask+0x40>
	{
		prvSwitchTimerLists( xLastTime );
 8007248:	f7ff ffaa 	bl	80071a0 <prvSwitchTimerLists.isra.1>
		*pxTimerListsWereSwitched = pdTRUE;
 800724c:	2301      	movs	r3, #1
 800724e:	e000      	b.n	8007252 <prvTimerTask+0x42>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 8007250:	2300      	movs	r3, #0
	}

	xLastTime = xTimeNow;
 8007252:	636f      	str	r7, [r5, #52]	; 0x34
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
 8007254:	2b00      	cmp	r3, #0
 8007256:	d134      	bne.n	80072c2 <prvTimerTask+0xb2>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8007258:	f1b9 0f00 	cmp.w	r9, #0
 800725c:	d125      	bne.n	80072aa <prvTimerTask+0x9a>
 800725e:	42be      	cmp	r6, r7
 8007260:	d823      	bhi.n	80072aa <prvTimerTask+0x9a>
			{
				xTaskResumeAll();
 8007262:	f7ff fc71 	bl	8006b48 <xTaskResumeAll>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8007266:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8007268:	68db      	ldr	r3, [r3, #12]
 800726a:	68dc      	ldr	r4, [r3, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
 800726c:	1d20      	adds	r0, r4, #4
 800726e:	f7fe fe10 	bl	8005e92 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 8007272:	69e3      	ldr	r3, [r4, #28]
 8007274:	2b01      	cmp	r3, #1
 8007276:	d114      	bne.n	80072a2 <prvTimerTask+0x92>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 8007278:	69a1      	ldr	r1, [r4, #24]
 800727a:	4620      	mov	r0, r4
 800727c:	1871      	adds	r1, r6, r1
 800727e:	463a      	mov	r2, r7
 8007280:	4633      	mov	r3, r6
 8007282:	f7ff ff11 	bl	80070a8 <prvInsertTimerInActiveList>
 8007286:	2801      	cmp	r0, #1
 8007288:	d10b      	bne.n	80072a2 <prvTimerTask+0x92>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 800728a:	f8cd 9000 	str.w	r9, [sp]
 800728e:	4620      	mov	r0, r4
 8007290:	4649      	mov	r1, r9
 8007292:	4632      	mov	r2, r6
 8007294:	464b      	mov	r3, r9
 8007296:	f7ff ff61 	bl	800715c <xTimerGenericCommand>
			configASSERT( xResult );
 800729a:	b910      	cbnz	r0, 80072a2 <prvTimerTask+0x92>
 800729c:	f7fe fc38 	bl	8005b10 <ulPortSetInterruptMask>
 80072a0:	e7fe      	b.n	80072a0 <prvTimerTask+0x90>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 80072a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80072a4:	4620      	mov	r0, r4
 80072a6:	4798      	blx	r3
 80072a8:	e050      	b.n	800734c <prvTimerTask+0x13c>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 80072aa:	f8d8 0000 	ldr.w	r0, [r8]
 80072ae:	1bf1      	subs	r1, r6, r7
 80072b0:	f7ff f965 	bl	800657e <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 80072b4:	f7ff fc48 	bl	8006b48 <xTaskResumeAll>
 80072b8:	2800      	cmp	r0, #0
 80072ba:	d147      	bne.n	800734c <prvTimerTask+0x13c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 80072bc:	f7fe fc1d 	bl	8005afa <vPortYield>
 80072c0:	e044      	b.n	800734c <prvTimerTask+0x13c>
				}
			}
		}
		else
		{
			xTaskResumeAll();
 80072c2:	f7ff fc41 	bl	8006b48 <xTaskResumeAll>
 80072c6:	e041      	b.n	800734c <prvTimerTask+0x13c>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
 80072c8:	9c05      	ldr	r4, [sp, #20]

		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 80072ca:	6963      	ldr	r3, [r4, #20]
 80072cc:	b113      	cbz	r3, 80072d4 <prvTimerTask+0xc4>
		{
			/* The timer is in a list, remove it. */
			uxListRemove( &( pxTimer->xTimerListItem ) );
 80072ce:	1d20      	adds	r0, r4, #4
 80072d0:	f7fe fddf 	bl	8005e92 <uxListRemove>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 80072d4:	f7ff fbb2 	bl	8006a3c <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 80072d8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 80072da:	4607      	mov	r7, r0

	if( xTimeNow < xLastTime )
 80072dc:	4298      	cmp	r0, r3
 80072de:	d201      	bcs.n	80072e4 <prvTimerTask+0xd4>
	{
		prvSwitchTimerLists( xLastTime );
 80072e0:	f7ff ff5e 	bl	80071a0 <prvSwitchTimerLists.isra.1>
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

		switch( xMessage.xMessageID )
 80072e4:	9e03      	ldr	r6, [sp, #12]
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 80072e6:	f8c8 7034 	str.w	r7, [r8, #52]	; 0x34
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

		switch( xMessage.xMessageID )
 80072ea:	2e02      	cmp	r6, #2
 80072ec:	d01e      	beq.n	800732c <prvTimerTask+0x11c>
 80072ee:	2e03      	cmp	r6, #3
 80072f0:	d029      	beq.n	8007346 <prvTimerTask+0x136>
 80072f2:	bb5e      	cbnz	r6, 800734c <prvTimerTask+0x13c>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
 80072f4:	9b04      	ldr	r3, [sp, #16]
 80072f6:	69a1      	ldr	r1, [r4, #24]
 80072f8:	4620      	mov	r0, r4
 80072fa:	1859      	adds	r1, r3, r1
 80072fc:	463a      	mov	r2, r7
 80072fe:	f7ff fed3 	bl	80070a8 <prvInsertTimerInActiveList>
 8007302:	2801      	cmp	r0, #1
 8007304:	d122      	bne.n	800734c <prvTimerTask+0x13c>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 8007306:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007308:	4620      	mov	r0, r4
 800730a:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 800730c:	69e3      	ldr	r3, [r4, #28]
 800730e:	2b01      	cmp	r3, #1
 8007310:	d11c      	bne.n	800734c <prvTimerTask+0x13c>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8007312:	69a2      	ldr	r2, [r4, #24]
 8007314:	9b04      	ldr	r3, [sp, #16]
 8007316:	9600      	str	r6, [sp, #0]
 8007318:	18d2      	adds	r2, r2, r3
 800731a:	4620      	mov	r0, r4
 800731c:	4631      	mov	r1, r6
 800731e:	4633      	mov	r3, r6
 8007320:	f7ff ff1c 	bl	800715c <xTimerGenericCommand>
						configASSERT( xResult );
 8007324:	b990      	cbnz	r0, 800734c <prvTimerTask+0x13c>
 8007326:	f7fe fbf3 	bl	8005b10 <ulPortSetInterruptMask>
 800732a:	e7fe      	b.n	800732a <prvTimerTask+0x11a>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 800732c:	9904      	ldr	r1, [sp, #16]
 800732e:	61a1      	str	r1, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8007330:	b911      	cbnz	r1, 8007338 <prvTimerTask+0x128>
 8007332:	f7fe fbed 	bl	8005b10 <ulPortSetInterruptMask>
 8007336:	e7fe      	b.n	8007336 <prvTimerTask+0x126>
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8007338:	4620      	mov	r0, r4
 800733a:	1879      	adds	r1, r7, r1
 800733c:	463a      	mov	r2, r7
 800733e:	463b      	mov	r3, r7
 8007340:	f7ff feb2 	bl	80070a8 <prvInsertTimerInActiveList>
 8007344:	e002      	b.n	800734c <prvTimerTask+0x13c>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
 8007346:	4620      	mov	r0, r4
 8007348:	f7fe fb9a 	bl	8005a80 <vPortFree>
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 800734c:	2200      	movs	r2, #0
 800734e:	6828      	ldr	r0, [r5, #0]
 8007350:	a903      	add	r1, sp, #12
 8007352:	4613      	mov	r3, r2
 8007354:	f7fe ff4e 	bl	80061f4 <xQueueGenericReceive>
 8007358:	2800      	cmp	r0, #0
 800735a:	d1b5      	bne.n	80072c8 <prvTimerTask+0xb8>
 800735c:	e75d      	b.n	800721a <prvTimerTask+0xa>
 800735e:	bf00      	nop
 8007360:	20002b44 	.word	0x20002b44

08007364 <xTimerIsTimerActive>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
{
 8007364:	b510      	push	{r4, lr}
 8007366:	4604      	mov	r4, r0
portBASE_TYPE xTimerIsInActiveList;
xTIMER *pxTimer = ( xTIMER * ) xTimer;

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 8007368:	f7fe fbda 	bl	8005b20 <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 800736c:	6964      	ldr	r4, [r4, #20]
 800736e:	3400      	adds	r4, #0
 8007370:	bf18      	it	ne
 8007372:	2401      	movne	r4, #1
	}
	taskEXIT_CRITICAL();
 8007374:	f7fe fbe5 	bl	8005b42 <vPortExitCritical>

	return xTimerIsInActiveList;
}
 8007378:	4620      	mov	r0, r4
 800737a:	bd10      	pop	{r4, pc}

0800737c <pvTimerGetTimerID>:
void *pvTimerGetTimerID( xTimerHandle xTimer )
{
xTIMER *pxTimer = ( xTIMER * ) xTimer;

	return pxTimer->pvTimerID;
}
 800737c:	6a00      	ldr	r0, [r0, #32]
 800737e:	4770      	bx	lr

08007380 <SystemInit>:
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8007380:	4b38      	ldr	r3, [pc, #224]	; (8007464 <SystemInit+0xe4>)
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8007382:	b082      	sub	sp, #8
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8007384:	681a      	ldr	r2, [r3, #0]
 8007386:	f042 0201 	orr.w	r2, r2, #1
 800738a:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR &= 0xF87FC00C;
 800738c:	6859      	ldr	r1, [r3, #4]
 800738e:	4a36      	ldr	r2, [pc, #216]	; (8007468 <SystemInit+0xe8>)
 8007390:	400a      	ands	r2, r1
 8007392:	605a      	str	r2, [r3, #4]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8007394:	681a      	ldr	r2, [r3, #0]
 8007396:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800739a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800739e:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80073a0:	681a      	ldr	r2, [r3, #0]
 80073a2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80073a6:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80073a8:	685a      	ldr	r2, [r3, #4]
 80073aa:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80073ae:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 80073b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80073b2:	f022 020f 	bic.w	r2, r2, #15
 80073b6:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW and TIMs bits */
  RCC->CFGR3 &= (uint32_t)0xFF00FCCC;
 80073b8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80073ba:	4a2c      	ldr	r2, [pc, #176]	; (800746c <SystemInit+0xec>)
 80073bc:	400a      	ands	r2, r1
 80073be:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80073c0:	2200      	movs	r2, #0
 80073c2:	609a      	str	r2, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80073c4:	9200      	str	r2, [sp, #0]
 80073c6:	9201      	str	r2, [sp, #4]
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/

  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------*/
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 80073c8:	681a      	ldr	r2, [r3, #0]
 80073ca:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80073ce:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80073d0:	681a      	ldr	r2, [r3, #0]
 80073d2:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 80073d6:	9201      	str	r2, [sp, #4]
    StartUpCounter++;
 80073d8:	9a00      	ldr	r2, [sp, #0]
 80073da:	3201      	adds	r2, #1
 80073dc:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80073de:	9a01      	ldr	r2, [sp, #4]
 80073e0:	b91a      	cbnz	r2, 80073ea <SystemInit+0x6a>
 80073e2:	9a00      	ldr	r2, [sp, #0]
 80073e4:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 80073e8:	d1f2      	bne.n	80073d0 <SystemInit+0x50>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80073ea:	4b1e      	ldr	r3, [pc, #120]	; (8007464 <SystemInit+0xe4>)
 80073ec:	681b      	ldr	r3, [r3, #0]
 80073ee:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 80073f2:	bf18      	it	ne
 80073f4:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80073f6:	9301      	str	r3, [sp, #4]
  }

  if (HSEStatus == (uint32_t)0x01)
 80073f8:	9b01      	ldr	r3, [sp, #4]
 80073fa:	2b01      	cmp	r3, #1
 80073fc:	d004      	beq.n	8007408 <SystemInit+0x88>
  SetSysClock();
  
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 80073fe:	4b1c      	ldr	r3, [pc, #112]	; (8007470 <SystemInit+0xf0>)
 8007400:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8007404:	609a      	str	r2, [r3, #8]
 8007406:	e02a      	b.n	800745e <SystemInit+0xde>
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | (uint32_t)FLASH_ACR_LATENCY_1;
 8007408:	4b1a      	ldr	r3, [pc, #104]	; (8007474 <SystemInit+0xf4>)
 800740a:	2212      	movs	r2, #18
 800740c:	601a      	str	r2, [r3, #0]
 
     /* HCLK = SYSCLK / 1 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 800740e:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
 8007412:	685a      	ldr	r2, [r3, #4]
 8007414:	605a      	str	r2, [r3, #4]
       
     /* PCLK2 = HCLK / 1 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8007416:	685a      	ldr	r2, [r3, #4]
 8007418:	605a      	str	r2, [r3, #4]
     
     /* PCLK1 = HCLK / 2 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 800741a:	685a      	ldr	r2, [r3, #4]
 800741c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8007420:	605a      	str	r2, [r3, #4]

    /* PLL configuration */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
 8007422:	685a      	ldr	r2, [r3, #4]
 8007424:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 8007428:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL9);
 800742a:	685a      	ldr	r2, [r3, #4]
 800742c:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 8007430:	605a      	str	r2, [r3, #4]

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8007432:	681a      	ldr	r2, [r3, #0]
 8007434:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8007438:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800743a:	6819      	ldr	r1, [r3, #0]
 800743c:	4a09      	ldr	r2, [pc, #36]	; (8007464 <SystemInit+0xe4>)
 800743e:	0189      	lsls	r1, r1, #6
 8007440:	d5fb      	bpl.n	800743a <SystemInit+0xba>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8007442:	6853      	ldr	r3, [r2, #4]
 8007444:	f023 0303 	bic.w	r3, r3, #3
 8007448:	6053      	str	r3, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
 800744a:	6853      	ldr	r3, [r2, #4]
 800744c:	f043 0302 	orr.w	r3, r3, #2
 8007450:	6053      	str	r3, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
 8007452:	6853      	ldr	r3, [r2, #4]
 8007454:	f003 030c 	and.w	r3, r3, #12
 8007458:	2b08      	cmp	r3, #8
 800745a:	d1fa      	bne.n	8007452 <SystemInit+0xd2>
 800745c:	e7cf      	b.n	80073fe <SystemInit+0x7e>
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
#endif  
}
 800745e:	b002      	add	sp, #8
 8007460:	4770      	bx	lr
 8007462:	bf00      	nop
 8007464:	40021000 	.word	0x40021000
 8007468:	f87fc00c 	.word	0xf87fc00c
 800746c:	ff00fccc 	.word	0xff00fccc
 8007470:	e000ed00 	.word	0xe000ed00
 8007474:	40022000 	.word	0x40022000

08007478 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate (void)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8007478:	4a14      	ldr	r2, [pc, #80]	; (80074cc <SystemCoreClockUpdate+0x54>)
 800747a:	4b15      	ldr	r3, [pc, #84]	; (80074d0 <SystemCoreClockUpdate+0x58>)
 800747c:	6851      	ldr	r1, [r2, #4]
 800747e:	f001 010c 	and.w	r1, r1, #12
  
  switch (tmp)
 8007482:	2904      	cmp	r1, #4
 8007484:	d001      	beq.n	800748a <SystemCoreClockUpdate+0x12>
 8007486:	2908      	cmp	r1, #8
 8007488:	d002      	beq.n	8007490 <SystemCoreClockUpdate+0x18>
  {
    case 0x00:  /* HSI used as system clock */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
 800748a:	4a12      	ldr	r2, [pc, #72]	; (80074d4 <SystemCoreClockUpdate+0x5c>)
 800748c:	601a      	str	r2, [r3, #0]
      break;
 800748e:	e011      	b.n	80074b4 <SystemCoreClockUpdate+0x3c>
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 8007490:	6851      	ldr	r1, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8007492:	6850      	ldr	r0, [r2, #4]
      pllmull = ( pllmull >> 18) + 2;
 8007494:	f3c1 4183 	ubfx	r1, r1, #18, #4
 8007498:	3102      	adds	r1, #2
      
      if (pllsource == 0x00)
 800749a:	03c0      	lsls	r0, r0, #15
 800749c:	d401      	bmi.n	80074a2 <SystemCoreClockUpdate+0x2a>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
 800749e:	4a0e      	ldr	r2, [pc, #56]	; (80074d8 <SystemCoreClockUpdate+0x60>)
 80074a0:	e006      	b.n	80074b0 <SystemCoreClockUpdate+0x38>
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80074a2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 80074a4:	480b      	ldr	r0, [pc, #44]	; (80074d4 <SystemCoreClockUpdate+0x5c>)
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80074a6:	f002 020f 	and.w	r2, r2, #15
 80074aa:	3201      	adds	r2, #1
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 80074ac:	fbb0 f2f2 	udiv	r2, r0, r2
 80074b0:	4351      	muls	r1, r2
 80074b2:	6019      	str	r1, [r3, #0]
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80074b4:	4b05      	ldr	r3, [pc, #20]	; (80074cc <SystemCoreClockUpdate+0x54>)
 80074b6:	685a      	ldr	r2, [r3, #4]
 80074b8:	4b05      	ldr	r3, [pc, #20]	; (80074d0 <SystemCoreClockUpdate+0x58>)
 80074ba:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80074be:	189a      	adds	r2, r3, r2
 80074c0:	7911      	ldrb	r1, [r2, #4]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
 80074c2:	681a      	ldr	r2, [r3, #0]
 80074c4:	fa22 f201 	lsr.w	r2, r2, r1
 80074c8:	601a      	str	r2, [r3, #0]
 80074ca:	4770      	bx	lr
 80074cc:	40021000 	.word	0x40021000
 80074d0:	20000034 	.word	0x20000034
 80074d4:	007a1200 	.word	0x007a1200
 80074d8:	003d0900 	.word	0x003d0900

080074dc <__aeabi_drsub>:
 80074dc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80074e0:	e002      	b.n	80074e8 <__adddf3>
 80074e2:	bf00      	nop

080074e4 <__aeabi_dsub>:
 80074e4:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080074e8 <__adddf3>:
 80074e8:	b530      	push	{r4, r5, lr}
 80074ea:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80074ee:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80074f2:	ea94 0f05 	teq	r4, r5
 80074f6:	bf08      	it	eq
 80074f8:	ea90 0f02 	teqeq	r0, r2
 80074fc:	bf1f      	itttt	ne
 80074fe:	ea54 0c00 	orrsne.w	ip, r4, r0
 8007502:	ea55 0c02 	orrsne.w	ip, r5, r2
 8007506:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800750a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800750e:	f000 80e2 	beq.w	80076d6 <__adddf3+0x1ee>
 8007512:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8007516:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800751a:	bfb8      	it	lt
 800751c:	426d      	neglt	r5, r5
 800751e:	dd0c      	ble.n	800753a <__adddf3+0x52>
 8007520:	442c      	add	r4, r5
 8007522:	ea80 0202 	eor.w	r2, r0, r2
 8007526:	ea81 0303 	eor.w	r3, r1, r3
 800752a:	ea82 0000 	eor.w	r0, r2, r0
 800752e:	ea83 0101 	eor.w	r1, r3, r1
 8007532:	ea80 0202 	eor.w	r2, r0, r2
 8007536:	ea81 0303 	eor.w	r3, r1, r3
 800753a:	2d36      	cmp	r5, #54	; 0x36
 800753c:	bf88      	it	hi
 800753e:	bd30      	pophi	{r4, r5, pc}
 8007540:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8007544:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8007548:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800754c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8007550:	d002      	beq.n	8007558 <__adddf3+0x70>
 8007552:	4240      	negs	r0, r0
 8007554:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007558:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800755c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8007560:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8007564:	d002      	beq.n	800756c <__adddf3+0x84>
 8007566:	4252      	negs	r2, r2
 8007568:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800756c:	ea94 0f05 	teq	r4, r5
 8007570:	f000 80a7 	beq.w	80076c2 <__adddf3+0x1da>
 8007574:	f1a4 0401 	sub.w	r4, r4, #1
 8007578:	f1d5 0e20 	rsbs	lr, r5, #32
 800757c:	db0d      	blt.n	800759a <__adddf3+0xb2>
 800757e:	fa02 fc0e 	lsl.w	ip, r2, lr
 8007582:	fa22 f205 	lsr.w	r2, r2, r5
 8007586:	1880      	adds	r0, r0, r2
 8007588:	f141 0100 	adc.w	r1, r1, #0
 800758c:	fa03 f20e 	lsl.w	r2, r3, lr
 8007590:	1880      	adds	r0, r0, r2
 8007592:	fa43 f305 	asr.w	r3, r3, r5
 8007596:	4159      	adcs	r1, r3
 8007598:	e00e      	b.n	80075b8 <__adddf3+0xd0>
 800759a:	f1a5 0520 	sub.w	r5, r5, #32
 800759e:	f10e 0e20 	add.w	lr, lr, #32
 80075a2:	2a01      	cmp	r2, #1
 80075a4:	fa03 fc0e 	lsl.w	ip, r3, lr
 80075a8:	bf28      	it	cs
 80075aa:	f04c 0c02 	orrcs.w	ip, ip, #2
 80075ae:	fa43 f305 	asr.w	r3, r3, r5
 80075b2:	18c0      	adds	r0, r0, r3
 80075b4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80075b8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80075bc:	d507      	bpl.n	80075ce <__adddf3+0xe6>
 80075be:	f04f 0e00 	mov.w	lr, #0
 80075c2:	f1dc 0c00 	rsbs	ip, ip, #0
 80075c6:	eb7e 0000 	sbcs.w	r0, lr, r0
 80075ca:	eb6e 0101 	sbc.w	r1, lr, r1
 80075ce:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80075d2:	d31b      	bcc.n	800760c <__adddf3+0x124>
 80075d4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80075d8:	d30c      	bcc.n	80075f4 <__adddf3+0x10c>
 80075da:	0849      	lsrs	r1, r1, #1
 80075dc:	ea5f 0030 	movs.w	r0, r0, rrx
 80075e0:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80075e4:	f104 0401 	add.w	r4, r4, #1
 80075e8:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80075ec:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80075f0:	f080 809a 	bcs.w	8007728 <__adddf3+0x240>
 80075f4:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80075f8:	bf08      	it	eq
 80075fa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80075fe:	f150 0000 	adcs.w	r0, r0, #0
 8007602:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8007606:	ea41 0105 	orr.w	r1, r1, r5
 800760a:	bd30      	pop	{r4, r5, pc}
 800760c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8007610:	4140      	adcs	r0, r0
 8007612:	eb41 0101 	adc.w	r1, r1, r1
 8007616:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800761a:	f1a4 0401 	sub.w	r4, r4, #1
 800761e:	d1e9      	bne.n	80075f4 <__adddf3+0x10c>
 8007620:	f091 0f00 	teq	r1, #0
 8007624:	bf04      	itt	eq
 8007626:	4601      	moveq	r1, r0
 8007628:	2000      	moveq	r0, #0
 800762a:	fab1 f381 	clz	r3, r1
 800762e:	bf08      	it	eq
 8007630:	3320      	addeq	r3, #32
 8007632:	f1a3 030b 	sub.w	r3, r3, #11
 8007636:	f1b3 0220 	subs.w	r2, r3, #32
 800763a:	da0c      	bge.n	8007656 <__adddf3+0x16e>
 800763c:	320c      	adds	r2, #12
 800763e:	dd08      	ble.n	8007652 <__adddf3+0x16a>
 8007640:	f102 0c14 	add.w	ip, r2, #20
 8007644:	f1c2 020c 	rsb	r2, r2, #12
 8007648:	fa01 f00c 	lsl.w	r0, r1, ip
 800764c:	fa21 f102 	lsr.w	r1, r1, r2
 8007650:	e00c      	b.n	800766c <__adddf3+0x184>
 8007652:	f102 0214 	add.w	r2, r2, #20
 8007656:	bfd8      	it	le
 8007658:	f1c2 0c20 	rsble	ip, r2, #32
 800765c:	fa01 f102 	lsl.w	r1, r1, r2
 8007660:	fa20 fc0c 	lsr.w	ip, r0, ip
 8007664:	bfdc      	itt	le
 8007666:	ea41 010c 	orrle.w	r1, r1, ip
 800766a:	4090      	lslle	r0, r2
 800766c:	1ae4      	subs	r4, r4, r3
 800766e:	bfa2      	ittt	ge
 8007670:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8007674:	4329      	orrge	r1, r5
 8007676:	bd30      	popge	{r4, r5, pc}
 8007678:	ea6f 0404 	mvn.w	r4, r4
 800767c:	3c1f      	subs	r4, #31
 800767e:	da1c      	bge.n	80076ba <__adddf3+0x1d2>
 8007680:	340c      	adds	r4, #12
 8007682:	dc0e      	bgt.n	80076a2 <__adddf3+0x1ba>
 8007684:	f104 0414 	add.w	r4, r4, #20
 8007688:	f1c4 0220 	rsb	r2, r4, #32
 800768c:	fa20 f004 	lsr.w	r0, r0, r4
 8007690:	fa01 f302 	lsl.w	r3, r1, r2
 8007694:	ea40 0003 	orr.w	r0, r0, r3
 8007698:	fa21 f304 	lsr.w	r3, r1, r4
 800769c:	ea45 0103 	orr.w	r1, r5, r3
 80076a0:	bd30      	pop	{r4, r5, pc}
 80076a2:	f1c4 040c 	rsb	r4, r4, #12
 80076a6:	f1c4 0220 	rsb	r2, r4, #32
 80076aa:	fa20 f002 	lsr.w	r0, r0, r2
 80076ae:	fa01 f304 	lsl.w	r3, r1, r4
 80076b2:	ea40 0003 	orr.w	r0, r0, r3
 80076b6:	4629      	mov	r1, r5
 80076b8:	bd30      	pop	{r4, r5, pc}
 80076ba:	fa21 f004 	lsr.w	r0, r1, r4
 80076be:	4629      	mov	r1, r5
 80076c0:	bd30      	pop	{r4, r5, pc}
 80076c2:	f094 0f00 	teq	r4, #0
 80076c6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80076ca:	bf06      	itte	eq
 80076cc:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80076d0:	3401      	addeq	r4, #1
 80076d2:	3d01      	subne	r5, #1
 80076d4:	e74e      	b.n	8007574 <__adddf3+0x8c>
 80076d6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80076da:	bf18      	it	ne
 80076dc:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80076e0:	d029      	beq.n	8007736 <__adddf3+0x24e>
 80076e2:	ea94 0f05 	teq	r4, r5
 80076e6:	bf08      	it	eq
 80076e8:	ea90 0f02 	teqeq	r0, r2
 80076ec:	d005      	beq.n	80076fa <__adddf3+0x212>
 80076ee:	ea54 0c00 	orrs.w	ip, r4, r0
 80076f2:	bf04      	itt	eq
 80076f4:	4619      	moveq	r1, r3
 80076f6:	4610      	moveq	r0, r2
 80076f8:	bd30      	pop	{r4, r5, pc}
 80076fa:	ea91 0f03 	teq	r1, r3
 80076fe:	bf1e      	ittt	ne
 8007700:	2100      	movne	r1, #0
 8007702:	2000      	movne	r0, #0
 8007704:	bd30      	popne	{r4, r5, pc}
 8007706:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800770a:	d105      	bne.n	8007718 <__adddf3+0x230>
 800770c:	0040      	lsls	r0, r0, #1
 800770e:	4149      	adcs	r1, r1
 8007710:	bf28      	it	cs
 8007712:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8007716:	bd30      	pop	{r4, r5, pc}
 8007718:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800771c:	bf3c      	itt	cc
 800771e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8007722:	bd30      	popcc	{r4, r5, pc}
 8007724:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007728:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800772c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8007730:	f04f 0000 	mov.w	r0, #0
 8007734:	bd30      	pop	{r4, r5, pc}
 8007736:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800773a:	bf1a      	itte	ne
 800773c:	4619      	movne	r1, r3
 800773e:	4610      	movne	r0, r2
 8007740:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8007744:	bf1c      	itt	ne
 8007746:	460b      	movne	r3, r1
 8007748:	4602      	movne	r2, r0
 800774a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800774e:	bf06      	itte	eq
 8007750:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8007754:	ea91 0f03 	teqeq	r1, r3
 8007758:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800775c:	bd30      	pop	{r4, r5, pc}
 800775e:	bf00      	nop

08007760 <__aeabi_ui2d>:
 8007760:	f090 0f00 	teq	r0, #0
 8007764:	bf04      	itt	eq
 8007766:	2100      	moveq	r1, #0
 8007768:	4770      	bxeq	lr
 800776a:	b530      	push	{r4, r5, lr}
 800776c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007770:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8007774:	f04f 0500 	mov.w	r5, #0
 8007778:	f04f 0100 	mov.w	r1, #0
 800777c:	e750      	b.n	8007620 <__adddf3+0x138>
 800777e:	bf00      	nop

08007780 <__aeabi_i2d>:
 8007780:	f090 0f00 	teq	r0, #0
 8007784:	bf04      	itt	eq
 8007786:	2100      	moveq	r1, #0
 8007788:	4770      	bxeq	lr
 800778a:	b530      	push	{r4, r5, lr}
 800778c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007790:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8007794:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8007798:	bf48      	it	mi
 800779a:	4240      	negmi	r0, r0
 800779c:	f04f 0100 	mov.w	r1, #0
 80077a0:	e73e      	b.n	8007620 <__adddf3+0x138>
 80077a2:	bf00      	nop

080077a4 <__aeabi_f2d>:
 80077a4:	0042      	lsls	r2, r0, #1
 80077a6:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80077aa:	ea4f 0131 	mov.w	r1, r1, rrx
 80077ae:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80077b2:	bf1f      	itttt	ne
 80077b4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80077b8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80077bc:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80077c0:	4770      	bxne	lr
 80077c2:	f092 0f00 	teq	r2, #0
 80077c6:	bf14      	ite	ne
 80077c8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80077cc:	4770      	bxeq	lr
 80077ce:	b530      	push	{r4, r5, lr}
 80077d0:	f44f 7460 	mov.w	r4, #896	; 0x380
 80077d4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80077d8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80077dc:	e720      	b.n	8007620 <__adddf3+0x138>
 80077de:	bf00      	nop

080077e0 <__aeabi_ul2d>:
 80077e0:	ea50 0201 	orrs.w	r2, r0, r1
 80077e4:	bf08      	it	eq
 80077e6:	4770      	bxeq	lr
 80077e8:	b530      	push	{r4, r5, lr}
 80077ea:	f04f 0500 	mov.w	r5, #0
 80077ee:	e00a      	b.n	8007806 <__aeabi_l2d+0x16>

080077f0 <__aeabi_l2d>:
 80077f0:	ea50 0201 	orrs.w	r2, r0, r1
 80077f4:	bf08      	it	eq
 80077f6:	4770      	bxeq	lr
 80077f8:	b530      	push	{r4, r5, lr}
 80077fa:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80077fe:	d502      	bpl.n	8007806 <__aeabi_l2d+0x16>
 8007800:	4240      	negs	r0, r0
 8007802:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007806:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800780a:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800780e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8007812:	f43f aedc 	beq.w	80075ce <__adddf3+0xe6>
 8007816:	f04f 0203 	mov.w	r2, #3
 800781a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800781e:	bf18      	it	ne
 8007820:	3203      	addne	r2, #3
 8007822:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8007826:	bf18      	it	ne
 8007828:	3203      	addne	r2, #3
 800782a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800782e:	f1c2 0320 	rsb	r3, r2, #32
 8007832:	fa00 fc03 	lsl.w	ip, r0, r3
 8007836:	fa20 f002 	lsr.w	r0, r0, r2
 800783a:	fa01 fe03 	lsl.w	lr, r1, r3
 800783e:	ea40 000e 	orr.w	r0, r0, lr
 8007842:	fa21 f102 	lsr.w	r1, r1, r2
 8007846:	4414      	add	r4, r2
 8007848:	e6c1      	b.n	80075ce <__adddf3+0xe6>
 800784a:	bf00      	nop

0800784c <__aeabi_d2iz>:
 800784c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8007850:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8007854:	d215      	bcs.n	8007882 <__aeabi_d2iz+0x36>
 8007856:	d511      	bpl.n	800787c <__aeabi_d2iz+0x30>
 8007858:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800785c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8007860:	d912      	bls.n	8007888 <__aeabi_d2iz+0x3c>
 8007862:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8007866:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800786a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800786e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8007872:	fa23 f002 	lsr.w	r0, r3, r2
 8007876:	bf18      	it	ne
 8007878:	4240      	negne	r0, r0
 800787a:	4770      	bx	lr
 800787c:	f04f 0000 	mov.w	r0, #0
 8007880:	4770      	bx	lr
 8007882:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8007886:	d105      	bne.n	8007894 <__aeabi_d2iz+0x48>
 8007888:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800788c:	bf08      	it	eq
 800788e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8007892:	4770      	bx	lr
 8007894:	f04f 0000 	mov.w	r0, #0
 8007898:	4770      	bx	lr
 800789a:	bf00      	nop

0800789c <__aeabi_d2f>:
 800789c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80078a0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80078a4:	bf24      	itt	cs
 80078a6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80078aa:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80078ae:	d90d      	bls.n	80078cc <__aeabi_d2f+0x30>
 80078b0:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80078b4:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80078b8:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80078bc:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80078c0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80078c4:	bf08      	it	eq
 80078c6:	f020 0001 	biceq.w	r0, r0, #1
 80078ca:	4770      	bx	lr
 80078cc:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80078d0:	d121      	bne.n	8007916 <__aeabi_d2f+0x7a>
 80078d2:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80078d6:	bfbc      	itt	lt
 80078d8:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80078dc:	4770      	bxlt	lr
 80078de:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80078e2:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80078e6:	f1c2 0218 	rsb	r2, r2, #24
 80078ea:	f1c2 0c20 	rsb	ip, r2, #32
 80078ee:	fa10 f30c 	lsls.w	r3, r0, ip
 80078f2:	fa20 f002 	lsr.w	r0, r0, r2
 80078f6:	bf18      	it	ne
 80078f8:	f040 0001 	orrne.w	r0, r0, #1
 80078fc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8007900:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8007904:	fa03 fc0c 	lsl.w	ip, r3, ip
 8007908:	ea40 000c 	orr.w	r0, r0, ip
 800790c:	fa23 f302 	lsr.w	r3, r3, r2
 8007910:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8007914:	e7cc      	b.n	80078b0 <__aeabi_d2f+0x14>
 8007916:	ea7f 5362 	mvns.w	r3, r2, asr #21
 800791a:	d107      	bne.n	800792c <__aeabi_d2f+0x90>
 800791c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8007920:	bf1e      	ittt	ne
 8007922:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8007926:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 800792a:	4770      	bxne	lr
 800792c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8007930:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8007934:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007938:	4770      	bx	lr
 800793a:	bf00      	nop

0800793c <__aeabi_frsub>:
 800793c:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8007940:	e002      	b.n	8007948 <__addsf3>
 8007942:	bf00      	nop

08007944 <__aeabi_fsub>:
 8007944:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08007948 <__addsf3>:
 8007948:	0042      	lsls	r2, r0, #1
 800794a:	bf1f      	itttt	ne
 800794c:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8007950:	ea92 0f03 	teqne	r2, r3
 8007954:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8007958:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800795c:	d06a      	beq.n	8007a34 <__addsf3+0xec>
 800795e:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8007962:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8007966:	bfc1      	itttt	gt
 8007968:	18d2      	addgt	r2, r2, r3
 800796a:	4041      	eorgt	r1, r0
 800796c:	4048      	eorgt	r0, r1
 800796e:	4041      	eorgt	r1, r0
 8007970:	bfb8      	it	lt
 8007972:	425b      	neglt	r3, r3
 8007974:	2b19      	cmp	r3, #25
 8007976:	bf88      	it	hi
 8007978:	4770      	bxhi	lr
 800797a:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 800797e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007982:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8007986:	bf18      	it	ne
 8007988:	4240      	negne	r0, r0
 800798a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800798e:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8007992:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8007996:	bf18      	it	ne
 8007998:	4249      	negne	r1, r1
 800799a:	ea92 0f03 	teq	r2, r3
 800799e:	d03f      	beq.n	8007a20 <__addsf3+0xd8>
 80079a0:	f1a2 0201 	sub.w	r2, r2, #1
 80079a4:	fa41 fc03 	asr.w	ip, r1, r3
 80079a8:	eb10 000c 	adds.w	r0, r0, ip
 80079ac:	f1c3 0320 	rsb	r3, r3, #32
 80079b0:	fa01 f103 	lsl.w	r1, r1, r3
 80079b4:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80079b8:	d502      	bpl.n	80079c0 <__addsf3+0x78>
 80079ba:	4249      	negs	r1, r1
 80079bc:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80079c0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80079c4:	d313      	bcc.n	80079ee <__addsf3+0xa6>
 80079c6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80079ca:	d306      	bcc.n	80079da <__addsf3+0x92>
 80079cc:	0840      	lsrs	r0, r0, #1
 80079ce:	ea4f 0131 	mov.w	r1, r1, rrx
 80079d2:	f102 0201 	add.w	r2, r2, #1
 80079d6:	2afe      	cmp	r2, #254	; 0xfe
 80079d8:	d251      	bcs.n	8007a7e <__addsf3+0x136>
 80079da:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80079de:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80079e2:	bf08      	it	eq
 80079e4:	f020 0001 	biceq.w	r0, r0, #1
 80079e8:	ea40 0003 	orr.w	r0, r0, r3
 80079ec:	4770      	bx	lr
 80079ee:	0049      	lsls	r1, r1, #1
 80079f0:	eb40 0000 	adc.w	r0, r0, r0
 80079f4:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 80079f8:	f1a2 0201 	sub.w	r2, r2, #1
 80079fc:	d1ed      	bne.n	80079da <__addsf3+0x92>
 80079fe:	fab0 fc80 	clz	ip, r0
 8007a02:	f1ac 0c08 	sub.w	ip, ip, #8
 8007a06:	ebb2 020c 	subs.w	r2, r2, ip
 8007a0a:	fa00 f00c 	lsl.w	r0, r0, ip
 8007a0e:	bfaa      	itet	ge
 8007a10:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8007a14:	4252      	neglt	r2, r2
 8007a16:	4318      	orrge	r0, r3
 8007a18:	bfbc      	itt	lt
 8007a1a:	40d0      	lsrlt	r0, r2
 8007a1c:	4318      	orrlt	r0, r3
 8007a1e:	4770      	bx	lr
 8007a20:	f092 0f00 	teq	r2, #0
 8007a24:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8007a28:	bf06      	itte	eq
 8007a2a:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8007a2e:	3201      	addeq	r2, #1
 8007a30:	3b01      	subne	r3, #1
 8007a32:	e7b5      	b.n	80079a0 <__addsf3+0x58>
 8007a34:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8007a38:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8007a3c:	bf18      	it	ne
 8007a3e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8007a42:	d021      	beq.n	8007a88 <__addsf3+0x140>
 8007a44:	ea92 0f03 	teq	r2, r3
 8007a48:	d004      	beq.n	8007a54 <__addsf3+0x10c>
 8007a4a:	f092 0f00 	teq	r2, #0
 8007a4e:	bf08      	it	eq
 8007a50:	4608      	moveq	r0, r1
 8007a52:	4770      	bx	lr
 8007a54:	ea90 0f01 	teq	r0, r1
 8007a58:	bf1c      	itt	ne
 8007a5a:	2000      	movne	r0, #0
 8007a5c:	4770      	bxne	lr
 8007a5e:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8007a62:	d104      	bne.n	8007a6e <__addsf3+0x126>
 8007a64:	0040      	lsls	r0, r0, #1
 8007a66:	bf28      	it	cs
 8007a68:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8007a6c:	4770      	bx	lr
 8007a6e:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8007a72:	bf3c      	itt	cc
 8007a74:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8007a78:	4770      	bxcc	lr
 8007a7a:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8007a7e:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8007a82:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007a86:	4770      	bx	lr
 8007a88:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8007a8c:	bf16      	itet	ne
 8007a8e:	4608      	movne	r0, r1
 8007a90:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8007a94:	4601      	movne	r1, r0
 8007a96:	0242      	lsls	r2, r0, #9
 8007a98:	bf06      	itte	eq
 8007a9a:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8007a9e:	ea90 0f01 	teqeq	r0, r1
 8007aa2:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8007aa6:	4770      	bx	lr

08007aa8 <__aeabi_ui2f>:
 8007aa8:	f04f 0300 	mov.w	r3, #0
 8007aac:	e004      	b.n	8007ab8 <__aeabi_i2f+0x8>
 8007aae:	bf00      	nop

08007ab0 <__aeabi_i2f>:
 8007ab0:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8007ab4:	bf48      	it	mi
 8007ab6:	4240      	negmi	r0, r0
 8007ab8:	ea5f 0c00 	movs.w	ip, r0
 8007abc:	bf08      	it	eq
 8007abe:	4770      	bxeq	lr
 8007ac0:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8007ac4:	4601      	mov	r1, r0
 8007ac6:	f04f 0000 	mov.w	r0, #0
 8007aca:	e01c      	b.n	8007b06 <__aeabi_l2f+0x2a>

08007acc <__aeabi_ul2f>:
 8007acc:	ea50 0201 	orrs.w	r2, r0, r1
 8007ad0:	bf08      	it	eq
 8007ad2:	4770      	bxeq	lr
 8007ad4:	f04f 0300 	mov.w	r3, #0
 8007ad8:	e00a      	b.n	8007af0 <__aeabi_l2f+0x14>
 8007ada:	bf00      	nop

08007adc <__aeabi_l2f>:
 8007adc:	ea50 0201 	orrs.w	r2, r0, r1
 8007ae0:	bf08      	it	eq
 8007ae2:	4770      	bxeq	lr
 8007ae4:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8007ae8:	d502      	bpl.n	8007af0 <__aeabi_l2f+0x14>
 8007aea:	4240      	negs	r0, r0
 8007aec:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007af0:	ea5f 0c01 	movs.w	ip, r1
 8007af4:	bf02      	ittt	eq
 8007af6:	4684      	moveq	ip, r0
 8007af8:	4601      	moveq	r1, r0
 8007afa:	2000      	moveq	r0, #0
 8007afc:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8007b00:	bf08      	it	eq
 8007b02:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8007b06:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8007b0a:	fabc f28c 	clz	r2, ip
 8007b0e:	3a08      	subs	r2, #8
 8007b10:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8007b14:	db10      	blt.n	8007b38 <__aeabi_l2f+0x5c>
 8007b16:	fa01 fc02 	lsl.w	ip, r1, r2
 8007b1a:	4463      	add	r3, ip
 8007b1c:	fa00 fc02 	lsl.w	ip, r0, r2
 8007b20:	f1c2 0220 	rsb	r2, r2, #32
 8007b24:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8007b28:	fa20 f202 	lsr.w	r2, r0, r2
 8007b2c:	eb43 0002 	adc.w	r0, r3, r2
 8007b30:	bf08      	it	eq
 8007b32:	f020 0001 	biceq.w	r0, r0, #1
 8007b36:	4770      	bx	lr
 8007b38:	f102 0220 	add.w	r2, r2, #32
 8007b3c:	fa01 fc02 	lsl.w	ip, r1, r2
 8007b40:	f1c2 0220 	rsb	r2, r2, #32
 8007b44:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8007b48:	fa21 f202 	lsr.w	r2, r1, r2
 8007b4c:	eb43 0002 	adc.w	r0, r3, r2
 8007b50:	bf08      	it	eq
 8007b52:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8007b56:	4770      	bx	lr

08007b58 <__aeabi_fmul>:
 8007b58:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8007b5c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8007b60:	bf1e      	ittt	ne
 8007b62:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8007b66:	ea92 0f0c 	teqne	r2, ip
 8007b6a:	ea93 0f0c 	teqne	r3, ip
 8007b6e:	d06f      	beq.n	8007c50 <__aeabi_fmul+0xf8>
 8007b70:	441a      	add	r2, r3
 8007b72:	ea80 0c01 	eor.w	ip, r0, r1
 8007b76:	0240      	lsls	r0, r0, #9
 8007b78:	bf18      	it	ne
 8007b7a:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8007b7e:	d01e      	beq.n	8007bbe <__aeabi_fmul+0x66>
 8007b80:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007b84:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8007b88:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8007b8c:	fba0 3101 	umull	r3, r1, r0, r1
 8007b90:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8007b94:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8007b98:	bf3e      	ittt	cc
 8007b9a:	0049      	lslcc	r1, r1, #1
 8007b9c:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8007ba0:	005b      	lslcc	r3, r3, #1
 8007ba2:	ea40 0001 	orr.w	r0, r0, r1
 8007ba6:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8007baa:	2afd      	cmp	r2, #253	; 0xfd
 8007bac:	d81d      	bhi.n	8007bea <__aeabi_fmul+0x92>
 8007bae:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8007bb2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8007bb6:	bf08      	it	eq
 8007bb8:	f020 0001 	biceq.w	r0, r0, #1
 8007bbc:	4770      	bx	lr
 8007bbe:	f090 0f00 	teq	r0, #0
 8007bc2:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8007bc6:	bf08      	it	eq
 8007bc8:	0249      	lsleq	r1, r1, #9
 8007bca:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8007bce:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8007bd2:	3a7f      	subs	r2, #127	; 0x7f
 8007bd4:	bfc2      	ittt	gt
 8007bd6:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8007bda:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8007bde:	4770      	bxgt	lr
 8007be0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007be4:	f04f 0300 	mov.w	r3, #0
 8007be8:	3a01      	subs	r2, #1
 8007bea:	dc5d      	bgt.n	8007ca8 <__aeabi_fmul+0x150>
 8007bec:	f112 0f19 	cmn.w	r2, #25
 8007bf0:	bfdc      	itt	le
 8007bf2:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8007bf6:	4770      	bxle	lr
 8007bf8:	f1c2 0200 	rsb	r2, r2, #0
 8007bfc:	0041      	lsls	r1, r0, #1
 8007bfe:	fa21 f102 	lsr.w	r1, r1, r2
 8007c02:	f1c2 0220 	rsb	r2, r2, #32
 8007c06:	fa00 fc02 	lsl.w	ip, r0, r2
 8007c0a:	ea5f 0031 	movs.w	r0, r1, rrx
 8007c0e:	f140 0000 	adc.w	r0, r0, #0
 8007c12:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8007c16:	bf08      	it	eq
 8007c18:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8007c1c:	4770      	bx	lr
 8007c1e:	f092 0f00 	teq	r2, #0
 8007c22:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8007c26:	bf02      	ittt	eq
 8007c28:	0040      	lsleq	r0, r0, #1
 8007c2a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8007c2e:	3a01      	subeq	r2, #1
 8007c30:	d0f9      	beq.n	8007c26 <__aeabi_fmul+0xce>
 8007c32:	ea40 000c 	orr.w	r0, r0, ip
 8007c36:	f093 0f00 	teq	r3, #0
 8007c3a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8007c3e:	bf02      	ittt	eq
 8007c40:	0049      	lsleq	r1, r1, #1
 8007c42:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8007c46:	3b01      	subeq	r3, #1
 8007c48:	d0f9      	beq.n	8007c3e <__aeabi_fmul+0xe6>
 8007c4a:	ea41 010c 	orr.w	r1, r1, ip
 8007c4e:	e78f      	b.n	8007b70 <__aeabi_fmul+0x18>
 8007c50:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8007c54:	ea92 0f0c 	teq	r2, ip
 8007c58:	bf18      	it	ne
 8007c5a:	ea93 0f0c 	teqne	r3, ip
 8007c5e:	d00a      	beq.n	8007c76 <__aeabi_fmul+0x11e>
 8007c60:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8007c64:	bf18      	it	ne
 8007c66:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8007c6a:	d1d8      	bne.n	8007c1e <__aeabi_fmul+0xc6>
 8007c6c:	ea80 0001 	eor.w	r0, r0, r1
 8007c70:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8007c74:	4770      	bx	lr
 8007c76:	f090 0f00 	teq	r0, #0
 8007c7a:	bf17      	itett	ne
 8007c7c:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8007c80:	4608      	moveq	r0, r1
 8007c82:	f091 0f00 	teqne	r1, #0
 8007c86:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8007c8a:	d014      	beq.n	8007cb6 <__aeabi_fmul+0x15e>
 8007c8c:	ea92 0f0c 	teq	r2, ip
 8007c90:	d101      	bne.n	8007c96 <__aeabi_fmul+0x13e>
 8007c92:	0242      	lsls	r2, r0, #9
 8007c94:	d10f      	bne.n	8007cb6 <__aeabi_fmul+0x15e>
 8007c96:	ea93 0f0c 	teq	r3, ip
 8007c9a:	d103      	bne.n	8007ca4 <__aeabi_fmul+0x14c>
 8007c9c:	024b      	lsls	r3, r1, #9
 8007c9e:	bf18      	it	ne
 8007ca0:	4608      	movne	r0, r1
 8007ca2:	d108      	bne.n	8007cb6 <__aeabi_fmul+0x15e>
 8007ca4:	ea80 0001 	eor.w	r0, r0, r1
 8007ca8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8007cac:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8007cb0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007cb4:	4770      	bx	lr
 8007cb6:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8007cba:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8007cbe:	4770      	bx	lr

08007cc0 <__aeabi_fdiv>:
 8007cc0:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8007cc4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8007cc8:	bf1e      	ittt	ne
 8007cca:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8007cce:	ea92 0f0c 	teqne	r2, ip
 8007cd2:	ea93 0f0c 	teqne	r3, ip
 8007cd6:	d069      	beq.n	8007dac <__aeabi_fdiv+0xec>
 8007cd8:	eba2 0203 	sub.w	r2, r2, r3
 8007cdc:	ea80 0c01 	eor.w	ip, r0, r1
 8007ce0:	0249      	lsls	r1, r1, #9
 8007ce2:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8007ce6:	d037      	beq.n	8007d58 <__aeabi_fdiv+0x98>
 8007ce8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8007cec:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8007cf0:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8007cf4:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8007cf8:	428b      	cmp	r3, r1
 8007cfa:	bf38      	it	cc
 8007cfc:	005b      	lslcc	r3, r3, #1
 8007cfe:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8007d02:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8007d06:	428b      	cmp	r3, r1
 8007d08:	bf24      	itt	cs
 8007d0a:	1a5b      	subcs	r3, r3, r1
 8007d0c:	ea40 000c 	orrcs.w	r0, r0, ip
 8007d10:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8007d14:	bf24      	itt	cs
 8007d16:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8007d1a:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8007d1e:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8007d22:	bf24      	itt	cs
 8007d24:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8007d28:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8007d2c:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8007d30:	bf24      	itt	cs
 8007d32:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8007d36:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8007d3a:	011b      	lsls	r3, r3, #4
 8007d3c:	bf18      	it	ne
 8007d3e:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8007d42:	d1e0      	bne.n	8007d06 <__aeabi_fdiv+0x46>
 8007d44:	2afd      	cmp	r2, #253	; 0xfd
 8007d46:	f63f af50 	bhi.w	8007bea <__aeabi_fmul+0x92>
 8007d4a:	428b      	cmp	r3, r1
 8007d4c:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8007d50:	bf08      	it	eq
 8007d52:	f020 0001 	biceq.w	r0, r0, #1
 8007d56:	4770      	bx	lr
 8007d58:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8007d5c:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8007d60:	327f      	adds	r2, #127	; 0x7f
 8007d62:	bfc2      	ittt	gt
 8007d64:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8007d68:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8007d6c:	4770      	bxgt	lr
 8007d6e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007d72:	f04f 0300 	mov.w	r3, #0
 8007d76:	3a01      	subs	r2, #1
 8007d78:	e737      	b.n	8007bea <__aeabi_fmul+0x92>
 8007d7a:	f092 0f00 	teq	r2, #0
 8007d7e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8007d82:	bf02      	ittt	eq
 8007d84:	0040      	lsleq	r0, r0, #1
 8007d86:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8007d8a:	3a01      	subeq	r2, #1
 8007d8c:	d0f9      	beq.n	8007d82 <__aeabi_fdiv+0xc2>
 8007d8e:	ea40 000c 	orr.w	r0, r0, ip
 8007d92:	f093 0f00 	teq	r3, #0
 8007d96:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8007d9a:	bf02      	ittt	eq
 8007d9c:	0049      	lsleq	r1, r1, #1
 8007d9e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8007da2:	3b01      	subeq	r3, #1
 8007da4:	d0f9      	beq.n	8007d9a <__aeabi_fdiv+0xda>
 8007da6:	ea41 010c 	orr.w	r1, r1, ip
 8007daa:	e795      	b.n	8007cd8 <__aeabi_fdiv+0x18>
 8007dac:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8007db0:	ea92 0f0c 	teq	r2, ip
 8007db4:	d108      	bne.n	8007dc8 <__aeabi_fdiv+0x108>
 8007db6:	0242      	lsls	r2, r0, #9
 8007db8:	f47f af7d 	bne.w	8007cb6 <__aeabi_fmul+0x15e>
 8007dbc:	ea93 0f0c 	teq	r3, ip
 8007dc0:	f47f af70 	bne.w	8007ca4 <__aeabi_fmul+0x14c>
 8007dc4:	4608      	mov	r0, r1
 8007dc6:	e776      	b.n	8007cb6 <__aeabi_fmul+0x15e>
 8007dc8:	ea93 0f0c 	teq	r3, ip
 8007dcc:	d104      	bne.n	8007dd8 <__aeabi_fdiv+0x118>
 8007dce:	024b      	lsls	r3, r1, #9
 8007dd0:	f43f af4c 	beq.w	8007c6c <__aeabi_fmul+0x114>
 8007dd4:	4608      	mov	r0, r1
 8007dd6:	e76e      	b.n	8007cb6 <__aeabi_fmul+0x15e>
 8007dd8:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8007ddc:	bf18      	it	ne
 8007dde:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8007de2:	d1ca      	bne.n	8007d7a <__aeabi_fdiv+0xba>
 8007de4:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8007de8:	f47f af5c 	bne.w	8007ca4 <__aeabi_fmul+0x14c>
 8007dec:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8007df0:	f47f af3c 	bne.w	8007c6c <__aeabi_fmul+0x114>
 8007df4:	e75f      	b.n	8007cb6 <__aeabi_fmul+0x15e>
 8007df6:	bf00      	nop

08007df8 <__gesf2>:
 8007df8:	f04f 3cff 	mov.w	ip, #4294967295
 8007dfc:	e006      	b.n	8007e0c <__cmpsf2+0x4>
 8007dfe:	bf00      	nop

08007e00 <__lesf2>:
 8007e00:	f04f 0c01 	mov.w	ip, #1
 8007e04:	e002      	b.n	8007e0c <__cmpsf2+0x4>
 8007e06:	bf00      	nop

08007e08 <__cmpsf2>:
 8007e08:	f04f 0c01 	mov.w	ip, #1
 8007e0c:	f84d cd04 	str.w	ip, [sp, #-4]!
 8007e10:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8007e14:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8007e18:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8007e1c:	bf18      	it	ne
 8007e1e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8007e22:	d011      	beq.n	8007e48 <__cmpsf2+0x40>
 8007e24:	b001      	add	sp, #4
 8007e26:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8007e2a:	bf18      	it	ne
 8007e2c:	ea90 0f01 	teqne	r0, r1
 8007e30:	bf58      	it	pl
 8007e32:	ebb2 0003 	subspl.w	r0, r2, r3
 8007e36:	bf88      	it	hi
 8007e38:	17c8      	asrhi	r0, r1, #31
 8007e3a:	bf38      	it	cc
 8007e3c:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8007e40:	bf18      	it	ne
 8007e42:	f040 0001 	orrne.w	r0, r0, #1
 8007e46:	4770      	bx	lr
 8007e48:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8007e4c:	d102      	bne.n	8007e54 <__cmpsf2+0x4c>
 8007e4e:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8007e52:	d105      	bne.n	8007e60 <__cmpsf2+0x58>
 8007e54:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8007e58:	d1e4      	bne.n	8007e24 <__cmpsf2+0x1c>
 8007e5a:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8007e5e:	d0e1      	beq.n	8007e24 <__cmpsf2+0x1c>
 8007e60:	f85d 0b04 	ldr.w	r0, [sp], #4
 8007e64:	4770      	bx	lr
 8007e66:	bf00      	nop

08007e68 <__aeabi_cfrcmple>:
 8007e68:	4684      	mov	ip, r0
 8007e6a:	4608      	mov	r0, r1
 8007e6c:	4661      	mov	r1, ip
 8007e6e:	e7ff      	b.n	8007e70 <__aeabi_cfcmpeq>

08007e70 <__aeabi_cfcmpeq>:
 8007e70:	b50f      	push	{r0, r1, r2, r3, lr}
 8007e72:	f7ff ffc9 	bl	8007e08 <__cmpsf2>
 8007e76:	2800      	cmp	r0, #0
 8007e78:	bf48      	it	mi
 8007e7a:	f110 0f00 	cmnmi.w	r0, #0
 8007e7e:	bd0f      	pop	{r0, r1, r2, r3, pc}

08007e80 <__aeabi_fcmpeq>:
 8007e80:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007e84:	f7ff fff4 	bl	8007e70 <__aeabi_cfcmpeq>
 8007e88:	bf0c      	ite	eq
 8007e8a:	2001      	moveq	r0, #1
 8007e8c:	2000      	movne	r0, #0
 8007e8e:	f85d fb08 	ldr.w	pc, [sp], #8
 8007e92:	bf00      	nop

08007e94 <__aeabi_fcmplt>:
 8007e94:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007e98:	f7ff ffea 	bl	8007e70 <__aeabi_cfcmpeq>
 8007e9c:	bf34      	ite	cc
 8007e9e:	2001      	movcc	r0, #1
 8007ea0:	2000      	movcs	r0, #0
 8007ea2:	f85d fb08 	ldr.w	pc, [sp], #8
 8007ea6:	bf00      	nop

08007ea8 <__aeabi_fcmple>:
 8007ea8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007eac:	f7ff ffe0 	bl	8007e70 <__aeabi_cfcmpeq>
 8007eb0:	bf94      	ite	ls
 8007eb2:	2001      	movls	r0, #1
 8007eb4:	2000      	movhi	r0, #0
 8007eb6:	f85d fb08 	ldr.w	pc, [sp], #8
 8007eba:	bf00      	nop

08007ebc <__aeabi_fcmpge>:
 8007ebc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007ec0:	f7ff ffd2 	bl	8007e68 <__aeabi_cfrcmple>
 8007ec4:	bf94      	ite	ls
 8007ec6:	2001      	movls	r0, #1
 8007ec8:	2000      	movhi	r0, #0
 8007eca:	f85d fb08 	ldr.w	pc, [sp], #8
 8007ece:	bf00      	nop

08007ed0 <__aeabi_fcmpgt>:
 8007ed0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007ed4:	f7ff ffc8 	bl	8007e68 <__aeabi_cfrcmple>
 8007ed8:	bf34      	ite	cc
 8007eda:	2001      	movcc	r0, #1
 8007edc:	2000      	movcs	r0, #0
 8007ede:	f85d fb08 	ldr.w	pc, [sp], #8
 8007ee2:	bf00      	nop

08007ee4 <__aeabi_f2iz>:
 8007ee4:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8007ee8:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8007eec:	d30f      	bcc.n	8007f0e <__aeabi_f2iz+0x2a>
 8007eee:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8007ef2:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8007ef6:	d90d      	bls.n	8007f14 <__aeabi_f2iz+0x30>
 8007ef8:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8007efc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007f00:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8007f04:	fa23 f002 	lsr.w	r0, r3, r2
 8007f08:	bf18      	it	ne
 8007f0a:	4240      	negne	r0, r0
 8007f0c:	4770      	bx	lr
 8007f0e:	f04f 0000 	mov.w	r0, #0
 8007f12:	4770      	bx	lr
 8007f14:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8007f18:	d101      	bne.n	8007f1e <__aeabi_f2iz+0x3a>
 8007f1a:	0242      	lsls	r2, r0, #9
 8007f1c:	d105      	bne.n	8007f2a <__aeabi_f2iz+0x46>
 8007f1e:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 8007f22:	bf08      	it	eq
 8007f24:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8007f28:	4770      	bx	lr
 8007f2a:	f04f 0000 	mov.w	r0, #0
 8007f2e:	4770      	bx	lr

08007f30 <__aeabi_f2uiz>:
 8007f30:	0042      	lsls	r2, r0, #1
 8007f32:	d20e      	bcs.n	8007f52 <__aeabi_f2uiz+0x22>
 8007f34:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8007f38:	d30b      	bcc.n	8007f52 <__aeabi_f2uiz+0x22>
 8007f3a:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8007f3e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8007f42:	d409      	bmi.n	8007f58 <__aeabi_f2uiz+0x28>
 8007f44:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8007f48:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007f4c:	fa23 f002 	lsr.w	r0, r3, r2
 8007f50:	4770      	bx	lr
 8007f52:	f04f 0000 	mov.w	r0, #0
 8007f56:	4770      	bx	lr
 8007f58:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8007f5c:	d101      	bne.n	8007f62 <__aeabi_f2uiz+0x32>
 8007f5e:	0242      	lsls	r2, r0, #9
 8007f60:	d102      	bne.n	8007f68 <__aeabi_f2uiz+0x38>
 8007f62:	f04f 30ff 	mov.w	r0, #4294967295
 8007f66:	4770      	bx	lr
 8007f68:	f04f 0000 	mov.w	r0, #0
 8007f6c:	4770      	bx	lr
 8007f6e:	bf00      	nop

08007f70 <memcmp>:
 8007f70:	2a03      	cmp	r2, #3
 8007f72:	b470      	push	{r4, r5, r6}
 8007f74:	d922      	bls.n	8007fbc <memcmp+0x4c>
 8007f76:	ea41 0300 	orr.w	r3, r1, r0
 8007f7a:	079b      	lsls	r3, r3, #30
 8007f7c:	d013      	beq.n	8007fa6 <memcmp+0x36>
 8007f7e:	7805      	ldrb	r5, [r0, #0]
 8007f80:	3a01      	subs	r2, #1
 8007f82:	780c      	ldrb	r4, [r1, #0]
 8007f84:	2300      	movs	r3, #0
 8007f86:	42a5      	cmp	r5, r4
 8007f88:	d006      	beq.n	8007f98 <memcmp+0x28>
 8007f8a:	e01b      	b.n	8007fc4 <memcmp+0x54>
 8007f8c:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8007f90:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8007f94:	42a5      	cmp	r5, r4
 8007f96:	d115      	bne.n	8007fc4 <memcmp+0x54>
 8007f98:	4293      	cmp	r3, r2
 8007f9a:	f103 0301 	add.w	r3, r3, #1
 8007f9e:	d1f5      	bne.n	8007f8c <memcmp+0x1c>
 8007fa0:	2000      	movs	r0, #0
 8007fa2:	bc70      	pop	{r4, r5, r6}
 8007fa4:	4770      	bx	lr
 8007fa6:	460c      	mov	r4, r1
 8007fa8:	4603      	mov	r3, r0
 8007faa:	3104      	adds	r1, #4
 8007fac:	3004      	adds	r0, #4
 8007fae:	681e      	ldr	r6, [r3, #0]
 8007fb0:	6825      	ldr	r5, [r4, #0]
 8007fb2:	42ae      	cmp	r6, r5
 8007fb4:	d108      	bne.n	8007fc8 <memcmp+0x58>
 8007fb6:	3a04      	subs	r2, #4
 8007fb8:	2a03      	cmp	r2, #3
 8007fba:	d8f4      	bhi.n	8007fa6 <memcmp+0x36>
 8007fbc:	2a00      	cmp	r2, #0
 8007fbe:	d1de      	bne.n	8007f7e <memcmp+0xe>
 8007fc0:	4610      	mov	r0, r2
 8007fc2:	e7ee      	b.n	8007fa2 <memcmp+0x32>
 8007fc4:	1b28      	subs	r0, r5, r4
 8007fc6:	e7ec      	b.n	8007fa2 <memcmp+0x32>
 8007fc8:	4621      	mov	r1, r4
 8007fca:	4618      	mov	r0, r3
 8007fcc:	2a00      	cmp	r2, #0
 8007fce:	d1d6      	bne.n	8007f7e <memcmp+0xe>
 8007fd0:	e7f6      	b.n	8007fc0 <memcmp+0x50>
 8007fd2:	bf00      	nop

08007fd4 <memcpy>:
 8007fd4:	2a03      	cmp	r2, #3
 8007fd6:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8007fda:	d809      	bhi.n	8007ff0 <memcpy+0x1c>
 8007fdc:	b12a      	cbz	r2, 8007fea <memcpy+0x16>
 8007fde:	2300      	movs	r3, #0
 8007fe0:	5ccc      	ldrb	r4, [r1, r3]
 8007fe2:	54c4      	strb	r4, [r0, r3]
 8007fe4:	3301      	adds	r3, #1
 8007fe6:	4293      	cmp	r3, r2
 8007fe8:	d1fa      	bne.n	8007fe0 <memcpy+0xc>
 8007fea:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8007fee:	4770      	bx	lr
 8007ff0:	0783      	lsls	r3, r0, #30
 8007ff2:	4402      	add	r2, r0
 8007ff4:	d00e      	beq.n	8008014 <memcpy+0x40>
 8007ff6:	1c44      	adds	r4, r0, #1
 8007ff8:	1c4d      	adds	r5, r1, #1
 8007ffa:	f815 7c01 	ldrb.w	r7, [r5, #-1]
 8007ffe:	f004 0603 	and.w	r6, r4, #3
 8008002:	4623      	mov	r3, r4
 8008004:	3401      	adds	r4, #1
 8008006:	4629      	mov	r1, r5
 8008008:	3501      	adds	r5, #1
 800800a:	f804 7c02 	strb.w	r7, [r4, #-2]
 800800e:	2e00      	cmp	r6, #0
 8008010:	d1f3      	bne.n	8007ffa <memcpy+0x26>
 8008012:	e000      	b.n	8008016 <memcpy+0x42>
 8008014:	4603      	mov	r3, r0
 8008016:	f011 0403 	ands.w	r4, r1, #3
 800801a:	d06d      	beq.n	80080f8 <memcpy+0x124>
 800801c:	1ad7      	subs	r7, r2, r3
 800801e:	1b0d      	subs	r5, r1, r4
 8008020:	2f03      	cmp	r7, #3
 8008022:	682e      	ldr	r6, [r5, #0]
 8008024:	dd19      	ble.n	800805a <memcpy+0x86>
 8008026:	f1c4 0c04 	rsb	ip, r4, #4
 800802a:	ea4f 08c4 	mov.w	r8, r4, lsl #3
 800802e:	1d1c      	adds	r4, r3, #4
 8008030:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8008034:	f855 7f04 	ldr.w	r7, [r5, #4]!
 8008038:	ebc4 0902 	rsb	r9, r4, r2
 800803c:	4623      	mov	r3, r4
 800803e:	3104      	adds	r1, #4
 8008040:	3404      	adds	r4, #4
 8008042:	f1b9 0f03 	cmp.w	r9, #3
 8008046:	fa26 fa08 	lsr.w	sl, r6, r8
 800804a:	fa07 fb0c 	lsl.w	fp, r7, ip
 800804e:	463e      	mov	r6, r7
 8008050:	ea4b 070a 	orr.w	r7, fp, sl
 8008054:	f844 7c08 	str.w	r7, [r4, #-8]
 8008058:	dcec      	bgt.n	8008034 <memcpy+0x60>
 800805a:	429a      	cmp	r2, r3
 800805c:	d9c5      	bls.n	8007fea <memcpy+0x16>
 800805e:	3301      	adds	r3, #1
 8008060:	3101      	adds	r1, #1
 8008062:	3201      	adds	r2, #1
 8008064:	f811 4c01 	ldrb.w	r4, [r1, #-1]
 8008068:	3301      	adds	r3, #1
 800806a:	3101      	adds	r1, #1
 800806c:	4293      	cmp	r3, r2
 800806e:	f803 4c02 	strb.w	r4, [r3, #-2]
 8008072:	d1f7      	bne.n	8008064 <memcpy+0x90>
 8008074:	e7b9      	b.n	8007fea <memcpy+0x16>
 8008076:	680c      	ldr	r4, [r1, #0]
 8008078:	3340      	adds	r3, #64	; 0x40
 800807a:	3140      	adds	r1, #64	; 0x40
 800807c:	f843 4c40 	str.w	r4, [r3, #-64]
 8008080:	f851 4c3c 	ldr.w	r4, [r1, #-60]
 8008084:	f843 4c3c 	str.w	r4, [r3, #-60]
 8008088:	f851 4c38 	ldr.w	r4, [r1, #-56]
 800808c:	f843 4c38 	str.w	r4, [r3, #-56]
 8008090:	f851 4c34 	ldr.w	r4, [r1, #-52]
 8008094:	f843 4c34 	str.w	r4, [r3, #-52]
 8008098:	f851 4c30 	ldr.w	r4, [r1, #-48]
 800809c:	f843 4c30 	str.w	r4, [r3, #-48]
 80080a0:	f851 4c2c 	ldr.w	r4, [r1, #-44]
 80080a4:	f843 4c2c 	str.w	r4, [r3, #-44]
 80080a8:	f851 4c28 	ldr.w	r4, [r1, #-40]
 80080ac:	f843 4c28 	str.w	r4, [r3, #-40]
 80080b0:	f851 4c24 	ldr.w	r4, [r1, #-36]
 80080b4:	f843 4c24 	str.w	r4, [r3, #-36]
 80080b8:	f851 4c20 	ldr.w	r4, [r1, #-32]
 80080bc:	f843 4c20 	str.w	r4, [r3, #-32]
 80080c0:	f851 4c1c 	ldr.w	r4, [r1, #-28]
 80080c4:	f843 4c1c 	str.w	r4, [r3, #-28]
 80080c8:	f851 4c18 	ldr.w	r4, [r1, #-24]
 80080cc:	f843 4c18 	str.w	r4, [r3, #-24]
 80080d0:	f851 4c14 	ldr.w	r4, [r1, #-20]
 80080d4:	f843 4c14 	str.w	r4, [r3, #-20]
 80080d8:	f851 4c10 	ldr.w	r4, [r1, #-16]
 80080dc:	f843 4c10 	str.w	r4, [r3, #-16]
 80080e0:	f851 4c0c 	ldr.w	r4, [r1, #-12]
 80080e4:	f843 4c0c 	str.w	r4, [r3, #-12]
 80080e8:	f851 4c08 	ldr.w	r4, [r1, #-8]
 80080ec:	f843 4c08 	str.w	r4, [r3, #-8]
 80080f0:	f851 4c04 	ldr.w	r4, [r1, #-4]
 80080f4:	f843 4c04 	str.w	r4, [r3, #-4]
 80080f8:	1ad4      	subs	r4, r2, r3
 80080fa:	2c3f      	cmp	r4, #63	; 0x3f
 80080fc:	dcbb      	bgt.n	8008076 <memcpy+0xa2>
 80080fe:	e011      	b.n	8008124 <memcpy+0x150>
 8008100:	680c      	ldr	r4, [r1, #0]
 8008102:	3310      	adds	r3, #16
 8008104:	3110      	adds	r1, #16
 8008106:	f843 4c10 	str.w	r4, [r3, #-16]
 800810a:	f851 4c0c 	ldr.w	r4, [r1, #-12]
 800810e:	f843 4c0c 	str.w	r4, [r3, #-12]
 8008112:	f851 4c08 	ldr.w	r4, [r1, #-8]
 8008116:	f843 4c08 	str.w	r4, [r3, #-8]
 800811a:	f851 4c04 	ldr.w	r4, [r1, #-4]
 800811e:	f843 4c04 	str.w	r4, [r3, #-4]
 8008122:	1ad4      	subs	r4, r2, r3
 8008124:	2c0f      	cmp	r4, #15
 8008126:	dceb      	bgt.n	8008100 <memcpy+0x12c>
 8008128:	2c03      	cmp	r4, #3
 800812a:	dd96      	ble.n	800805a <memcpy+0x86>
 800812c:	1d1c      	adds	r4, r3, #4
 800812e:	1d0d      	adds	r5, r1, #4
 8008130:	f855 7c04 	ldr.w	r7, [r5, #-4]
 8008134:	1b16      	subs	r6, r2, r4
 8008136:	4623      	mov	r3, r4
 8008138:	4629      	mov	r1, r5
 800813a:	3404      	adds	r4, #4
 800813c:	3504      	adds	r5, #4
 800813e:	2e03      	cmp	r6, #3
 8008140:	f844 7c08 	str.w	r7, [r4, #-8]
 8008144:	dcf4      	bgt.n	8008130 <memcpy+0x15c>
 8008146:	e788      	b.n	800805a <memcpy+0x86>

08008148 <memset>:
 8008148:	2a03      	cmp	r2, #3
 800814a:	b2c9      	uxtb	r1, r1
 800814c:	b470      	push	{r4, r5, r6}
 800814e:	d808      	bhi.n	8008162 <memset+0x1a>
 8008150:	b12a      	cbz	r2, 800815e <memset+0x16>
 8008152:	4603      	mov	r3, r0
 8008154:	1812      	adds	r2, r2, r0
 8008156:	f803 1b01 	strb.w	r1, [r3], #1
 800815a:	4293      	cmp	r3, r2
 800815c:	d1fb      	bne.n	8008156 <memset+0xe>
 800815e:	bc70      	pop	{r4, r5, r6}
 8008160:	4770      	bx	lr
 8008162:	0783      	lsls	r3, r0, #30
 8008164:	4402      	add	r2, r0
 8008166:	d009      	beq.n	800817c <memset+0x34>
 8008168:	1c44      	adds	r4, r0, #1
 800816a:	f004 0503 	and.w	r5, r4, #3
 800816e:	4623      	mov	r3, r4
 8008170:	f804 1c01 	strb.w	r1, [r4, #-1]
 8008174:	3401      	adds	r4, #1
 8008176:	2d00      	cmp	r5, #0
 8008178:	d1f7      	bne.n	800816a <memset+0x22>
 800817a:	e000      	b.n	800817e <memset+0x36>
 800817c:	4603      	mov	r3, r0
 800817e:	1ad5      	subs	r5, r2, r3
 8008180:	eb01 2401 	add.w	r4, r1, r1, lsl #8
 8008184:	2d3f      	cmp	r5, #63	; 0x3f
 8008186:	eb04 4404 	add.w	r4, r4, r4, lsl #16
 800818a:	dd2c      	ble.n	80081e6 <memset+0x9e>
 800818c:	601c      	str	r4, [r3, #0]
 800818e:	3340      	adds	r3, #64	; 0x40
 8008190:	1ad5      	subs	r5, r2, r3
 8008192:	f843 4c3c 	str.w	r4, [r3, #-60]
 8008196:	2d3f      	cmp	r5, #63	; 0x3f
 8008198:	f843 4c38 	str.w	r4, [r3, #-56]
 800819c:	f843 4c34 	str.w	r4, [r3, #-52]
 80081a0:	f843 4c30 	str.w	r4, [r3, #-48]
 80081a4:	f843 4c2c 	str.w	r4, [r3, #-44]
 80081a8:	f843 4c28 	str.w	r4, [r3, #-40]
 80081ac:	f843 4c24 	str.w	r4, [r3, #-36]
 80081b0:	f843 4c20 	str.w	r4, [r3, #-32]
 80081b4:	f843 4c1c 	str.w	r4, [r3, #-28]
 80081b8:	f843 4c18 	str.w	r4, [r3, #-24]
 80081bc:	f843 4c14 	str.w	r4, [r3, #-20]
 80081c0:	f843 4c10 	str.w	r4, [r3, #-16]
 80081c4:	f843 4c0c 	str.w	r4, [r3, #-12]
 80081c8:	f843 4c08 	str.w	r4, [r3, #-8]
 80081cc:	f843 4c04 	str.w	r4, [r3, #-4]
 80081d0:	dcdc      	bgt.n	800818c <memset+0x44>
 80081d2:	e008      	b.n	80081e6 <memset+0x9e>
 80081d4:	601c      	str	r4, [r3, #0]
 80081d6:	3310      	adds	r3, #16
 80081d8:	1ad5      	subs	r5, r2, r3
 80081da:	f843 4c0c 	str.w	r4, [r3, #-12]
 80081de:	f843 4c08 	str.w	r4, [r3, #-8]
 80081e2:	f843 4c04 	str.w	r4, [r3, #-4]
 80081e6:	2d0f      	cmp	r5, #15
 80081e8:	dcf4      	bgt.n	80081d4 <memset+0x8c>
 80081ea:	2d03      	cmp	r5, #3
 80081ec:	dd08      	ble.n	8008200 <memset+0xb8>
 80081ee:	1d1d      	adds	r5, r3, #4
 80081f0:	1b56      	subs	r6, r2, r5
 80081f2:	f845 4c04 	str.w	r4, [r5, #-4]
 80081f6:	2e03      	cmp	r6, #3
 80081f8:	462b      	mov	r3, r5
 80081fa:	f105 0504 	add.w	r5, r5, #4
 80081fe:	dcf7      	bgt.n	80081f0 <memset+0xa8>
 8008200:	429a      	cmp	r2, r3
 8008202:	d9ac      	bls.n	800815e <memset+0x16>
 8008204:	3301      	adds	r3, #1
 8008206:	3201      	adds	r2, #1
 8008208:	f803 1c01 	strb.w	r1, [r3, #-1]
 800820c:	3301      	adds	r3, #1
 800820e:	4293      	cmp	r3, r2
 8008210:	d1fa      	bne.n	8008208 <memset+0xc0>
 8008212:	e7a4      	b.n	800815e <memset+0x16>

08008214 <strncpy>:
 8008214:	ea41 0300 	orr.w	r3, r1, r0
 8008218:	f013 0f03 	tst.w	r3, #3
 800821c:	4603      	mov	r3, r0
 800821e:	b470      	push	{r4, r5, r6}
 8008220:	d025      	beq.n	800826e <strncpy+0x5a>
 8008222:	b1aa      	cbz	r2, 8008250 <strncpy+0x3c>
 8008224:	780c      	ldrb	r4, [r1, #0]
 8008226:	3a01      	subs	r2, #1
 8008228:	f803 4b01 	strb.w	r4, [r3], #1
 800822c:	b14c      	cbz	r4, 8008242 <strncpy+0x2e>
 800822e:	461c      	mov	r4, r3
 8008230:	b172      	cbz	r2, 8008250 <strncpy+0x3c>
 8008232:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8008236:	3a01      	subs	r2, #1
 8008238:	f804 5b01 	strb.w	r5, [r4], #1
 800823c:	4623      	mov	r3, r4
 800823e:	2d00      	cmp	r5, #0
 8008240:	d1f6      	bne.n	8008230 <strncpy+0x1c>
 8008242:	b12a      	cbz	r2, 8008250 <strncpy+0x3c>
 8008244:	189a      	adds	r2, r3, r2
 8008246:	2100      	movs	r1, #0
 8008248:	f803 1b01 	strb.w	r1, [r3], #1
 800824c:	4293      	cmp	r3, r2
 800824e:	d1fb      	bne.n	8008248 <strncpy+0x34>
 8008250:	bc70      	pop	{r4, r5, r6}
 8008252:	4770      	bx	lr
 8008254:	460e      	mov	r6, r1
 8008256:	f851 4b04 	ldr.w	r4, [r1], #4
 800825a:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 800825e:	ea25 0504 	bic.w	r5, r5, r4
 8008262:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 8008266:	d105      	bne.n	8008274 <strncpy+0x60>
 8008268:	3a04      	subs	r2, #4
 800826a:	f843 4b04 	str.w	r4, [r3], #4
 800826e:	2a03      	cmp	r2, #3
 8008270:	d8f0      	bhi.n	8008254 <strncpy+0x40>
 8008272:	e7d6      	b.n	8008222 <strncpy+0xe>
 8008274:	4631      	mov	r1, r6
 8008276:	e7d4      	b.n	8008222 <strncpy+0xe>

08008278 <cosf>:
 8008278:	f640 73d8 	movw	r3, #4056	; 0xfd8
 800827c:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8008280:	f6c3 7349 	movt	r3, #16201	; 0x3f49
 8008284:	4601      	mov	r1, r0
 8008286:	429a      	cmp	r2, r3
 8008288:	b500      	push	{lr}
 800828a:	b083      	sub	sp, #12
 800828c:	dd15      	ble.n	80082ba <cosf+0x42>
 800828e:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8008292:	db03      	blt.n	800829c <cosf+0x24>
 8008294:	f7ff fb56 	bl	8007944 <__aeabi_fsub>
 8008298:	b003      	add	sp, #12
 800829a:	bd00      	pop	{pc}
 800829c:	4669      	mov	r1, sp
 800829e:	f000 fd63 	bl	8008d68 <__ieee754_rem_pio2f>
 80082a2:	f000 0203 	and.w	r2, r0, #3
 80082a6:	9800      	ldr	r0, [sp, #0]
 80082a8:	2a01      	cmp	r2, #1
 80082aa:	d010      	beq.n	80082ce <cosf+0x56>
 80082ac:	2a02      	cmp	r2, #2
 80082ae:	d008      	beq.n	80082c2 <cosf+0x4a>
 80082b0:	b99a      	cbnz	r2, 80082da <cosf+0x62>
 80082b2:	9901      	ldr	r1, [sp, #4]
 80082b4:	f000 ff52 	bl	800915c <__kernel_cosf>
 80082b8:	e7ee      	b.n	8008298 <cosf+0x20>
 80082ba:	2100      	movs	r1, #0
 80082bc:	f000 ff4e 	bl	800915c <__kernel_cosf>
 80082c0:	e7ea      	b.n	8008298 <cosf+0x20>
 80082c2:	9901      	ldr	r1, [sp, #4]
 80082c4:	f000 ff4a 	bl	800915c <__kernel_cosf>
 80082c8:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80082cc:	e7e4      	b.n	8008298 <cosf+0x20>
 80082ce:	9901      	ldr	r1, [sp, #4]
 80082d0:	f001 fb4c 	bl	800996c <__kernel_sinf>
 80082d4:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80082d8:	e7de      	b.n	8008298 <cosf+0x20>
 80082da:	2201      	movs	r2, #1
 80082dc:	9901      	ldr	r1, [sp, #4]
 80082de:	f001 fb45 	bl	800996c <__kernel_sinf>
 80082e2:	e7d9      	b.n	8008298 <cosf+0x20>

080082e4 <sinf>:
 80082e4:	f640 73d8 	movw	r3, #4056	; 0xfd8
 80082e8:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 80082ec:	f6c3 7349 	movt	r3, #16201	; 0x3f49
 80082f0:	4601      	mov	r1, r0
 80082f2:	429a      	cmp	r2, r3
 80082f4:	b500      	push	{lr}
 80082f6:	b083      	sub	sp, #12
 80082f8:	dd16      	ble.n	8008328 <sinf+0x44>
 80082fa:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 80082fe:	db03      	blt.n	8008308 <sinf+0x24>
 8008300:	f7ff fb20 	bl	8007944 <__aeabi_fsub>
 8008304:	b003      	add	sp, #12
 8008306:	bd00      	pop	{pc}
 8008308:	4669      	mov	r1, sp
 800830a:	f000 fd2d 	bl	8008d68 <__ieee754_rem_pio2f>
 800830e:	f000 0003 	and.w	r0, r0, #3
 8008312:	2801      	cmp	r0, #1
 8008314:	d015      	beq.n	8008342 <sinf+0x5e>
 8008316:	2802      	cmp	r0, #2
 8008318:	d00b      	beq.n	8008332 <sinf+0x4e>
 800831a:	b9b8      	cbnz	r0, 800834c <sinf+0x68>
 800831c:	9800      	ldr	r0, [sp, #0]
 800831e:	2201      	movs	r2, #1
 8008320:	9901      	ldr	r1, [sp, #4]
 8008322:	f001 fb23 	bl	800996c <__kernel_sinf>
 8008326:	e7ed      	b.n	8008304 <sinf+0x20>
 8008328:	2100      	movs	r1, #0
 800832a:	2200      	movs	r2, #0
 800832c:	f001 fb1e 	bl	800996c <__kernel_sinf>
 8008330:	e7e8      	b.n	8008304 <sinf+0x20>
 8008332:	9800      	ldr	r0, [sp, #0]
 8008334:	2201      	movs	r2, #1
 8008336:	9901      	ldr	r1, [sp, #4]
 8008338:	f001 fb18 	bl	800996c <__kernel_sinf>
 800833c:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8008340:	e7e0      	b.n	8008304 <sinf+0x20>
 8008342:	9800      	ldr	r0, [sp, #0]
 8008344:	9901      	ldr	r1, [sp, #4]
 8008346:	f000 ff09 	bl	800915c <__kernel_cosf>
 800834a:	e7db      	b.n	8008304 <sinf+0x20>
 800834c:	9800      	ldr	r0, [sp, #0]
 800834e:	9901      	ldr	r1, [sp, #4]
 8008350:	f000 ff04 	bl	800915c <__kernel_cosf>
 8008354:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8008358:	e7d4      	b.n	8008304 <sinf+0x20>
 800835a:	bf00      	nop

0800835c <atan2>:
 800835c:	f000 b8fc 	b.w	8008558 <__ieee754_atan2>

08008360 <sqrt>:
 8008360:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008364:	b08a      	sub	sp, #40	; 0x28
 8008366:	4604      	mov	r4, r0
 8008368:	460d      	mov	r5, r1
 800836a:	f000 fa05 	bl	8008778 <__ieee754_sqrt>
 800836e:	f240 0a48 	movw	sl, #72	; 0x48
 8008372:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8008376:	f99a 3000 	ldrsb.w	r3, [sl]
 800837a:	3301      	adds	r3, #1
 800837c:	4606      	mov	r6, r0
 800837e:	460f      	mov	r7, r1
 8008380:	d00f      	beq.n	80083a2 <sqrt+0x42>
 8008382:	4620      	mov	r0, r4
 8008384:	4629      	mov	r1, r5
 8008386:	f001 fd0f 	bl	8009da8 <__fpclassifyd>
 800838a:	b150      	cbz	r0, 80083a2 <sqrt+0x42>
 800838c:	f04f 0800 	mov.w	r8, #0
 8008390:	f04f 0900 	mov.w	r9, #0
 8008394:	4620      	mov	r0, r4
 8008396:	4629      	mov	r1, r5
 8008398:	4642      	mov	r2, r8
 800839a:	464b      	mov	r3, r9
 800839c:	f002 f998 	bl	800a6d0 <__aeabi_dcmplt>
 80083a0:	b920      	cbnz	r0, 80083ac <sqrt+0x4c>
 80083a2:	4630      	mov	r0, r6
 80083a4:	4639      	mov	r1, r7
 80083a6:	b00a      	add	sp, #40	; 0x28
 80083a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80083ac:	f89a 6000 	ldrb.w	r6, [sl]
 80083b0:	f64a 530c 	movw	r3, #44300	; 0xad0c
 80083b4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80083b8:	2201      	movs	r2, #1
 80083ba:	e9cd 4504 	strd	r4, r5, [sp, #16]
 80083be:	e88d 000c 	stmia.w	sp, {r2, r3}
 80083c2:	2300      	movs	r3, #0
 80083c4:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80083c8:	9308      	str	r3, [sp, #32]
 80083ca:	b956      	cbnz	r6, 80083e2 <sqrt+0x82>
 80083cc:	e9cd 8906 	strd	r8, r9, [sp, #24]
 80083d0:	4668      	mov	r0, sp
 80083d2:	f001 fd11 	bl	8009df8 <matherr>
 80083d6:	b170      	cbz	r0, 80083f6 <sqrt+0x96>
 80083d8:	9b08      	ldr	r3, [sp, #32]
 80083da:	b98b      	cbnz	r3, 8008400 <sqrt+0xa0>
 80083dc:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 80083e0:	e7df      	b.n	80083a2 <sqrt+0x42>
 80083e2:	4640      	mov	r0, r8
 80083e4:	4649      	mov	r1, r9
 80083e6:	4642      	mov	r2, r8
 80083e8:	464b      	mov	r3, r9
 80083ea:	f002 f829 	bl	800a440 <__aeabi_ddiv>
 80083ee:	2e02      	cmp	r6, #2
 80083f0:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80083f4:	d1ec      	bne.n	80083d0 <sqrt+0x70>
 80083f6:	f001 fef3 	bl	800a1e0 <__errno>
 80083fa:	2321      	movs	r3, #33	; 0x21
 80083fc:	6003      	str	r3, [r0, #0]
 80083fe:	e7eb      	b.n	80083d8 <sqrt+0x78>
 8008400:	f001 feee 	bl	800a1e0 <__errno>
 8008404:	9b08      	ldr	r3, [sp, #32]
 8008406:	6003      	str	r3, [r0, #0]
 8008408:	e7e8      	b.n	80083dc <sqrt+0x7c>
 800840a:	bf00      	nop

0800840c <asinf>:
 800840c:	b570      	push	{r4, r5, r6, lr}
 800840e:	b08a      	sub	sp, #40	; 0x28
 8008410:	4606      	mov	r6, r0
 8008412:	f000 fa77 	bl	8008904 <__ieee754_asinf>
 8008416:	f240 0448 	movw	r4, #72	; 0x48
 800841a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800841e:	f994 3000 	ldrsb.w	r3, [r4]
 8008422:	3301      	adds	r3, #1
 8008424:	4605      	mov	r5, r0
 8008426:	d003      	beq.n	8008430 <asinf+0x24>
 8008428:	4630      	mov	r0, r6
 800842a:	f001 fe57 	bl	800a0dc <__fpclassifyf>
 800842e:	b910      	cbnz	r0, 8008436 <asinf+0x2a>
 8008430:	4628      	mov	r0, r5
 8008432:	b00a      	add	sp, #40	; 0x28
 8008434:	bd70      	pop	{r4, r5, r6, pc}
 8008436:	4630      	mov	r0, r6
 8008438:	f001 fe04 	bl	800a044 <fabsf>
 800843c:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8008440:	f7ff fd46 	bl	8007ed0 <__aeabi_fcmpgt>
 8008444:	2800      	cmp	r0, #0
 8008446:	d0f3      	beq.n	8008430 <asinf+0x24>
 8008448:	f64a 5314 	movw	r3, #44308	; 0xad14
 800844c:	4630      	mov	r0, r6
 800844e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008452:	9301      	str	r3, [sp, #4]
 8008454:	2301      	movs	r3, #1
 8008456:	9300      	str	r3, [sp, #0]
 8008458:	2300      	movs	r3, #0
 800845a:	9308      	str	r3, [sp, #32]
 800845c:	f7ff f9a2 	bl	80077a4 <__aeabi_f2d>
 8008460:	4602      	mov	r2, r0
 8008462:	f64a 5010 	movw	r0, #44304	; 0xad10
 8008466:	f6c0 0000 	movt	r0, #2048	; 0x800
 800846a:	460b      	mov	r3, r1
 800846c:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8008470:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8008474:	f001 fcc2 	bl	8009dfc <nan>
 8008478:	f994 3000 	ldrsb.w	r3, [r4]
 800847c:	2b02      	cmp	r3, #2
 800847e:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8008482:	d00b      	beq.n	800849c <asinf+0x90>
 8008484:	4668      	mov	r0, sp
 8008486:	f001 fcb7 	bl	8009df8 <matherr>
 800848a:	b138      	cbz	r0, 800849c <asinf+0x90>
 800848c:	9b08      	ldr	r3, [sp, #32]
 800848e:	b953      	cbnz	r3, 80084a6 <asinf+0x9a>
 8008490:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8008494:	f7ff fa02 	bl	800789c <__aeabi_d2f>
 8008498:	4605      	mov	r5, r0
 800849a:	e7c9      	b.n	8008430 <asinf+0x24>
 800849c:	f001 fea0 	bl	800a1e0 <__errno>
 80084a0:	2321      	movs	r3, #33	; 0x21
 80084a2:	6003      	str	r3, [r0, #0]
 80084a4:	e7f2      	b.n	800848c <asinf+0x80>
 80084a6:	f001 fe9b 	bl	800a1e0 <__errno>
 80084aa:	9b08      	ldr	r3, [sp, #32]
 80084ac:	6003      	str	r3, [r0, #0]
 80084ae:	e7ef      	b.n	8008490 <asinf+0x84>

080084b0 <atan2f>:
 80084b0:	f000 bbb4 	b.w	8008c1c <__ieee754_atan2f>

080084b4 <sqrtf>:
 80084b4:	b570      	push	{r4, r5, r6, lr}
 80084b6:	b08a      	sub	sp, #40	; 0x28
 80084b8:	4605      	mov	r5, r0
 80084ba:	f000 fdfb 	bl	80090b4 <__ieee754_sqrtf>
 80084be:	f240 0448 	movw	r4, #72	; 0x48
 80084c2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80084c6:	f994 3000 	ldrsb.w	r3, [r4]
 80084ca:	3301      	adds	r3, #1
 80084cc:	4606      	mov	r6, r0
 80084ce:	d008      	beq.n	80084e2 <sqrtf+0x2e>
 80084d0:	4628      	mov	r0, r5
 80084d2:	f001 fe03 	bl	800a0dc <__fpclassifyf>
 80084d6:	b120      	cbz	r0, 80084e2 <sqrtf+0x2e>
 80084d8:	4628      	mov	r0, r5
 80084da:	2100      	movs	r1, #0
 80084dc:	f7ff fcda 	bl	8007e94 <__aeabi_fcmplt>
 80084e0:	b910      	cbnz	r0, 80084e8 <sqrtf+0x34>
 80084e2:	4630      	mov	r0, r6
 80084e4:	b00a      	add	sp, #40	; 0x28
 80084e6:	bd70      	pop	{r4, r5, r6, pc}
 80084e8:	f64a 531c 	movw	r3, #44316	; 0xad1c
 80084ec:	4628      	mov	r0, r5
 80084ee:	f6c0 0300 	movt	r3, #2048	; 0x800
 80084f2:	9301      	str	r3, [sp, #4]
 80084f4:	2301      	movs	r3, #1
 80084f6:	9300      	str	r3, [sp, #0]
 80084f8:	2300      	movs	r3, #0
 80084fa:	9308      	str	r3, [sp, #32]
 80084fc:	f7ff f952 	bl	80077a4 <__aeabi_f2d>
 8008500:	7824      	ldrb	r4, [r4, #0]
 8008502:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8008506:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800850a:	b97c      	cbnz	r4, 800852c <sqrtf+0x78>
 800850c:	2200      	movs	r2, #0
 800850e:	2300      	movs	r3, #0
 8008510:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8008514:	4668      	mov	r0, sp
 8008516:	f001 fc6f 	bl	8009df8 <matherr>
 800851a:	b188      	cbz	r0, 8008540 <sqrtf+0x8c>
 800851c:	9b08      	ldr	r3, [sp, #32]
 800851e:	b9a3      	cbnz	r3, 800854a <sqrtf+0x96>
 8008520:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8008524:	f7ff f9ba 	bl	800789c <__aeabi_d2f>
 8008528:	4606      	mov	r6, r0
 800852a:	e7da      	b.n	80084e2 <sqrtf+0x2e>
 800852c:	2000      	movs	r0, #0
 800852e:	2100      	movs	r1, #0
 8008530:	4602      	mov	r2, r0
 8008532:	460b      	mov	r3, r1
 8008534:	f001 ff84 	bl	800a440 <__aeabi_ddiv>
 8008538:	2c02      	cmp	r4, #2
 800853a:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800853e:	d1e9      	bne.n	8008514 <sqrtf+0x60>
 8008540:	f001 fe4e 	bl	800a1e0 <__errno>
 8008544:	2321      	movs	r3, #33	; 0x21
 8008546:	6003      	str	r3, [r0, #0]
 8008548:	e7e8      	b.n	800851c <sqrtf+0x68>
 800854a:	f001 fe49 	bl	800a1e0 <__errno>
 800854e:	9b08      	ldr	r3, [sp, #32]
 8008550:	6003      	str	r3, [r0, #0]
 8008552:	e7e5      	b.n	8008520 <sqrtf+0x6c>
 8008554:	0000      	movs	r0, r0
	...

08008558 <__ieee754_atan2>:
 8008558:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800855c:	b084      	sub	sp, #16
 800855e:	2600      	movs	r6, #0
 8008560:	4604      	mov	r4, r0
 8008562:	e9cd 2300 	strd	r2, r3, [sp]
 8008566:	f6c7 76f0 	movt	r6, #32752	; 0x7ff0
 800856a:	e89d 1080 	ldmia.w	sp, {r7, ip}
 800856e:	460d      	mov	r5, r1
 8008570:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8008574:	4602      	mov	r2, r0
 8008576:	f1c7 0900 	rsb	r9, r7, #0
 800857a:	f02c 4800 	bic.w	r8, ip, #2147483648	; 0x80000000
 800857e:	ea49 0907 	orr.w	r9, r9, r7
 8008582:	460b      	mov	r3, r1
 8008584:	ea48 79d9 	orr.w	r9, r8, r9, lsr #31
 8008588:	45b1      	cmp	r9, r6
 800858a:	d84f      	bhi.n	800862c <__ieee754_atan2+0xd4>
 800858c:	f1c0 0a00 	rsb	sl, r0, #0
 8008590:	f021 4900 	bic.w	r9, r1, #2147483648	; 0x80000000
 8008594:	ea4a 0a00 	orr.w	sl, sl, r0
 8008598:	ea49 7ada 	orr.w	sl, r9, sl, lsr #31
 800859c:	45b2      	cmp	sl, r6
 800859e:	d845      	bhi.n	800862c <__ieee754_atan2+0xd4>
 80085a0:	f10c 4c40 	add.w	ip, ip, #3221225472	; 0xc0000000
 80085a4:	f8dd a004 	ldr.w	sl, [sp, #4]
 80085a8:	f50c 1c80 	add.w	ip, ip, #1048576	; 0x100000
 80085ac:	ea5c 0c07 	orrs.w	ip, ip, r7
 80085b0:	d05c      	beq.n	800866c <__ieee754_atan2+0x114>
 80085b2:	ea4f 76aa 	mov.w	r6, sl, asr #30
 80085b6:	ea59 0202 	orrs.w	r2, r9, r2
 80085ba:	f006 0602 	and.w	r6, r6, #2
 80085be:	ea46 76d1 	orr.w	r6, r6, r1, lsr #31
 80085c2:	d040      	beq.n	8008646 <__ieee754_atan2+0xee>
 80085c4:	ea58 0707 	orrs.w	r7, r8, r7
 80085c8:	d04a      	beq.n	8008660 <__ieee754_atan2+0x108>
 80085ca:	2200      	movs	r2, #0
 80085cc:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 80085d0:	4590      	cmp	r8, r2
 80085d2:	d05c      	beq.n	800868e <__ieee754_atan2+0x136>
 80085d4:	2200      	movs	r2, #0
 80085d6:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 80085da:	4591      	cmp	r9, r2
 80085dc:	d040      	beq.n	8008660 <__ieee754_atan2+0x108>
 80085de:	ebc8 0809 	rsb	r8, r8, r9
 80085e2:	ea4f 5828 	mov.w	r8, r8, asr #20
 80085e6:	f1b8 0f3c 	cmp.w	r8, #60	; 0x3c
 80085ea:	dc4c      	bgt.n	8008686 <__ieee754_atan2+0x12e>
 80085ec:	f118 0f3c 	cmn.w	r8, #60	; 0x3c
 80085f0:	bfac      	ite	ge
 80085f2:	f04f 0800 	movge.w	r8, #0
 80085f6:	f04f 0801 	movlt.w	r8, #1
 80085fa:	ea18 78da 	ands.w	r8, r8, sl, lsr #31
 80085fe:	d073      	beq.n	80086e8 <__ieee754_atan2+0x190>
 8008600:	2000      	movs	r0, #0
 8008602:	2100      	movs	r1, #0
 8008604:	2e01      	cmp	r6, #1
 8008606:	d06b      	beq.n	80086e0 <__ieee754_atan2+0x188>
 8008608:	2e02      	cmp	r6, #2
 800860a:	d05a      	beq.n	80086c2 <__ieee754_atan2+0x16a>
 800860c:	4604      	mov	r4, r0
 800860e:	460d      	mov	r5, r1
 8008610:	b1a6      	cbz	r6, 800863c <__ieee754_atan2+0xe4>
 8008612:	a347      	add	r3, pc, #284	; (adr r3, 8008730 <__ieee754_atan2+0x1d8>)
 8008614:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008618:	f7fe ff64 	bl	80074e4 <__aeabi_dsub>
 800861c:	a346      	add	r3, pc, #280	; (adr r3, 8008738 <__ieee754_atan2+0x1e0>)
 800861e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008622:	f7fe ff5f 	bl	80074e4 <__aeabi_dsub>
 8008626:	4604      	mov	r4, r0
 8008628:	460d      	mov	r5, r1
 800862a:	e007      	b.n	800863c <__ieee754_atan2+0xe4>
 800862c:	4620      	mov	r0, r4
 800862e:	4629      	mov	r1, r5
 8008630:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008634:	f7fe ff58 	bl	80074e8 <__adddf3>
 8008638:	4604      	mov	r4, r0
 800863a:	460d      	mov	r5, r1
 800863c:	4620      	mov	r0, r4
 800863e:	4629      	mov	r1, r5
 8008640:	b004      	add	sp, #16
 8008642:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008646:	2e03      	cmp	r6, #3
 8008648:	d8bc      	bhi.n	80085c4 <__ieee754_atan2+0x6c>
 800864a:	a201      	add	r2, pc, #4	; (adr r2, 8008650 <__ieee754_atan2+0xf8>)
 800864c:	f852 f026 	ldr.w	pc, [r2, r6, lsl #2]
 8008650:	0800863d 	.word	0x0800863d
 8008654:	0800863d 	.word	0x0800863d
 8008658:	0800867f 	.word	0x0800867f
 800865c:	08008677 	.word	0x08008677
 8008660:	2b00      	cmp	r3, #0
 8008662:	db2a      	blt.n	80086ba <__ieee754_atan2+0x162>
 8008664:	a536      	add	r5, pc, #216	; (adr r5, 8008740 <__ieee754_atan2+0x1e8>)
 8008666:	e9d5 4500 	ldrd	r4, r5, [r5]
 800866a:	e7e7      	b.n	800863c <__ieee754_atan2+0xe4>
 800866c:	b004      	add	sp, #16
 800866e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008672:	f001 b9fd 	b.w	8009a70 <atan>
 8008676:	a534      	add	r5, pc, #208	; (adr r5, 8008748 <__ieee754_atan2+0x1f0>)
 8008678:	e9d5 4500 	ldrd	r4, r5, [r5]
 800867c:	e7de      	b.n	800863c <__ieee754_atan2+0xe4>
 800867e:	a52e      	add	r5, pc, #184	; (adr r5, 8008738 <__ieee754_atan2+0x1e0>)
 8008680:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008684:	e7da      	b.n	800863c <__ieee754_atan2+0xe4>
 8008686:	a12e      	add	r1, pc, #184	; (adr r1, 8008740 <__ieee754_atan2+0x1e8>)
 8008688:	e9d1 0100 	ldrd	r0, r1, [r1]
 800868c:	e7ba      	b.n	8008604 <__ieee754_atan2+0xac>
 800868e:	45c1      	cmp	r9, r8
 8008690:	d035      	beq.n	80086fe <__ieee754_atan2+0x1a6>
 8008692:	2e03      	cmp	r6, #3
 8008694:	d89e      	bhi.n	80085d4 <__ieee754_atan2+0x7c>
 8008696:	a201      	add	r2, pc, #4	; (adr r2, 800869c <__ieee754_atan2+0x144>)
 8008698:	f852 f026 	ldr.w	pc, [r2, r6, lsl #2]
 800869c:	080086b5 	.word	0x080086b5
 80086a0:	080086ad 	.word	0x080086ad
 80086a4:	0800867f 	.word	0x0800867f
 80086a8:	08008677 	.word	0x08008677
 80086ac:	2400      	movs	r4, #0
 80086ae:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 80086b2:	e7c3      	b.n	800863c <__ieee754_atan2+0xe4>
 80086b4:	2400      	movs	r4, #0
 80086b6:	2500      	movs	r5, #0
 80086b8:	e7c0      	b.n	800863c <__ieee754_atan2+0xe4>
 80086ba:	a525      	add	r5, pc, #148	; (adr r5, 8008750 <__ieee754_atan2+0x1f8>)
 80086bc:	e9d5 4500 	ldrd	r4, r5, [r5]
 80086c0:	e7bc      	b.n	800863c <__ieee754_atan2+0xe4>
 80086c2:	a31b      	add	r3, pc, #108	; (adr r3, 8008730 <__ieee754_atan2+0x1d8>)
 80086c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80086c8:	f7fe ff0c 	bl	80074e4 <__aeabi_dsub>
 80086cc:	4602      	mov	r2, r0
 80086ce:	460b      	mov	r3, r1
 80086d0:	a119      	add	r1, pc, #100	; (adr r1, 8008738 <__ieee754_atan2+0x1e0>)
 80086d2:	e9d1 0100 	ldrd	r0, r1, [r1]
 80086d6:	f7fe ff05 	bl	80074e4 <__aeabi_dsub>
 80086da:	4604      	mov	r4, r0
 80086dc:	460d      	mov	r5, r1
 80086de:	e7ad      	b.n	800863c <__ieee754_atan2+0xe4>
 80086e0:	4604      	mov	r4, r0
 80086e2:	f101 4500 	add.w	r5, r1, #2147483648	; 0x80000000
 80086e6:	e7a9      	b.n	800863c <__ieee754_atan2+0xe4>
 80086e8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80086ec:	4620      	mov	r0, r4
 80086ee:	4629      	mov	r1, r5
 80086f0:	f001 fea6 	bl	800a440 <__aeabi_ddiv>
 80086f4:	f001 fb54 	bl	8009da0 <fabs>
 80086f8:	f001 f9ba 	bl	8009a70 <atan>
 80086fc:	e782      	b.n	8008604 <__ieee754_atan2+0xac>
 80086fe:	2e03      	cmp	r6, #3
 8008700:	d8ae      	bhi.n	8008660 <__ieee754_atan2+0x108>
 8008702:	e8df f006 	tbb	[pc, r6]
 8008706:	0a0e      	.short	0x0a0e
 8008708:	0206      	.short	0x0206
 800870a:	a513      	add	r5, pc, #76	; (adr r5, 8008758 <__ieee754_atan2+0x200>)
 800870c:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008710:	e794      	b.n	800863c <__ieee754_atan2+0xe4>
 8008712:	a513      	add	r5, pc, #76	; (adr r5, 8008760 <__ieee754_atan2+0x208>)
 8008714:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008718:	e790      	b.n	800863c <__ieee754_atan2+0xe4>
 800871a:	a513      	add	r5, pc, #76	; (adr r5, 8008768 <__ieee754_atan2+0x210>)
 800871c:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008720:	e78c      	b.n	800863c <__ieee754_atan2+0xe4>
 8008722:	a513      	add	r5, pc, #76	; (adr r5, 8008770 <__ieee754_atan2+0x218>)
 8008724:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008728:	e788      	b.n	800863c <__ieee754_atan2+0xe4>
 800872a:	bf00      	nop
 800872c:	f3af 8000 	nop.w
 8008730:	33145c07 	.word	0x33145c07
 8008734:	3ca1a626 	.word	0x3ca1a626
 8008738:	54442d18 	.word	0x54442d18
 800873c:	400921fb 	.word	0x400921fb
 8008740:	54442d18 	.word	0x54442d18
 8008744:	3ff921fb 	.word	0x3ff921fb
 8008748:	54442d18 	.word	0x54442d18
 800874c:	c00921fb 	.word	0xc00921fb
 8008750:	54442d18 	.word	0x54442d18
 8008754:	bff921fb 	.word	0xbff921fb
 8008758:	7f3321d2 	.word	0x7f3321d2
 800875c:	c002d97c 	.word	0xc002d97c
 8008760:	7f3321d2 	.word	0x7f3321d2
 8008764:	4002d97c 	.word	0x4002d97c
 8008768:	54442d18 	.word	0x54442d18
 800876c:	bfe921fb 	.word	0xbfe921fb
 8008770:	54442d18 	.word	0x54442d18
 8008774:	3fe921fb 	.word	0x3fe921fb

08008778 <__ieee754_sqrt>:
 8008778:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800877c:	2700      	movs	r7, #0
 800877e:	46b9      	mov	r9, r7
 8008780:	f6c7 77f0 	movt	r7, #32752	; 0x7ff0
 8008784:	f6c7 79f0 	movt	r9, #32752	; 0x7ff0
 8008788:	400f      	ands	r7, r1
 800878a:	454f      	cmp	r7, r9
 800878c:	4604      	mov	r4, r0
 800878e:	460d      	mov	r5, r1
 8008790:	4602      	mov	r2, r0
 8008792:	460b      	mov	r3, r1
 8008794:	460e      	mov	r6, r1
 8008796:	4680      	mov	r8, r0
 8008798:	f000 8099 	beq.w	80088ce <__ieee754_sqrt+0x156>
 800879c:	2900      	cmp	r1, #0
 800879e:	dd77      	ble.n	8008890 <__ieee754_sqrt+0x118>
 80087a0:	150f      	asrs	r7, r1, #20
 80087a2:	f000 8082 	beq.w	80088aa <__ieee754_sqrt+0x132>
 80087a6:	f026 437f 	bic.w	r3, r6, #4278190080	; 0xff000000
 80087aa:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 80087ae:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80087b2:	07fa      	lsls	r2, r7, #31
 80087b4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80087b8:	bf44      	itt	mi
 80087ba:	ea4f 72d8 	movmi.w	r2, r8, lsr #31
 80087be:	ea4f 0848 	movmi.w	r8, r8, lsl #1
 80087c2:	f04f 0c00 	mov.w	ip, #0
 80087c6:	bf48      	it	mi
 80087c8:	eb02 0343 	addmi.w	r3, r2, r3, lsl #1
 80087cc:	4660      	mov	r0, ip
 80087ce:	ea4f 72d8 	mov.w	r2, r8, lsr #31
 80087d2:	107f      	asrs	r7, r7, #1
 80087d4:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80087d8:	2416      	movs	r4, #22
 80087da:	ea4f 0248 	mov.w	r2, r8, lsl #1
 80087de:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80087e2:	1845      	adds	r5, r0, r1
 80087e4:	0fd6      	lsrs	r6, r2, #31
 80087e6:	429d      	cmp	r5, r3
 80087e8:	ea4f 0242 	mov.w	r2, r2, lsl #1
 80087ec:	bfde      	ittt	le
 80087ee:	ebc5 0303 	rsble	r3, r5, r3
 80087f2:	1868      	addle	r0, r5, r1
 80087f4:	448c      	addle	ip, r1
 80087f6:	0849      	lsrs	r1, r1, #1
 80087f8:	3c01      	subs	r4, #1
 80087fa:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 80087fe:	d1f0      	bne.n	80087e2 <__ieee754_sqrt+0x6a>
 8008800:	2620      	movs	r6, #32
 8008802:	46a0      	mov	r8, r4
 8008804:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8008808:	e00e      	b.n	8008828 <__ieee754_sqrt+0xb0>
 800880a:	4681      	mov	r9, r0
 800880c:	1a1b      	subs	r3, r3, r0
 800880e:	4295      	cmp	r5, r2
 8008810:	bf88      	it	hi
 8008812:	3b01      	subhi	r3, #1
 8008814:	1b52      	subs	r2, r2, r5
 8008816:	1864      	adds	r4, r4, r1
 8008818:	4648      	mov	r0, r9
 800881a:	0fd5      	lsrs	r5, r2, #31
 800881c:	0849      	lsrs	r1, r1, #1
 800881e:	0052      	lsls	r2, r2, #1
 8008820:	3e01      	subs	r6, #1
 8008822:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 8008826:	d015      	beq.n	8008854 <__ieee754_sqrt+0xdc>
 8008828:	4298      	cmp	r0, r3
 800882a:	eb01 0508 	add.w	r5, r1, r8
 800882e:	db03      	blt.n	8008838 <__ieee754_sqrt+0xc0>
 8008830:	4295      	cmp	r5, r2
 8008832:	bf98      	it	ls
 8008834:	4283      	cmpls	r3, r0
 8008836:	d1f0      	bne.n	800881a <__ieee754_sqrt+0xa2>
 8008838:	f005 4900 	and.w	r9, r5, #2147483648	; 0x80000000
 800883c:	eb05 0801 	add.w	r8, r5, r1
 8008840:	f1b9 4f00 	cmp.w	r9, #2147483648	; 0x80000000
 8008844:	d1e1      	bne.n	800880a <__ieee754_sqrt+0x92>
 8008846:	f1b8 0f00 	cmp.w	r8, #0
 800884a:	bfa8      	it	ge
 800884c:	f100 0901 	addge.w	r9, r0, #1
 8008850:	dadc      	bge.n	800880c <__ieee754_sqrt+0x94>
 8008852:	e7da      	b.n	800880a <__ieee754_sqrt+0x92>
 8008854:	4313      	orrs	r3, r2
 8008856:	d112      	bne.n	800887e <__ieee754_sqrt+0x106>
 8008858:	0866      	lsrs	r6, r4, #1
 800885a:	ea4f 036c 	mov.w	r3, ip, asr #1
 800885e:	f01c 0f01 	tst.w	ip, #1
 8008862:	f103 537f 	add.w	r3, r3, #1069547520	; 0x3fc00000
 8008866:	bf18      	it	ne
 8008868:	f046 4600 	orrne.w	r6, r6, #2147483648	; 0x80000000
 800886c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
 8008870:	4634      	mov	r4, r6
 8008872:	eb03 5507 	add.w	r5, r3, r7, lsl #20
 8008876:	4620      	mov	r0, r4
 8008878:	4629      	mov	r1, r5
 800887a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800887e:	1c63      	adds	r3, r4, #1
 8008880:	bf08      	it	eq
 8008882:	f10c 0c01 	addeq.w	ip, ip, #1
 8008886:	d0e8      	beq.n	800885a <__ieee754_sqrt+0xe2>
 8008888:	f004 0301 	and.w	r3, r4, #1
 800888c:	191c      	adds	r4, r3, r4
 800888e:	e7e3      	b.n	8008858 <__ieee754_sqrt+0xe0>
 8008890:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 8008894:	4306      	orrs	r6, r0
 8008896:	d0ee      	beq.n	8008876 <__ieee754_sqrt+0xfe>
 8008898:	bb41      	cbnz	r1, 80088ec <__ieee754_sqrt+0x174>
 800889a:	460f      	mov	r7, r1
 800889c:	ea4f 26d8 	mov.w	r6, r8, lsr #11
 80088a0:	3f15      	subs	r7, #21
 80088a2:	ea4f 5848 	mov.w	r8, r8, lsl #21
 80088a6:	2e00      	cmp	r6, #0
 80088a8:	d0f8      	beq.n	800889c <__ieee754_sqrt+0x124>
 80088aa:	f416 1380 	ands.w	r3, r6, #1048576	; 0x100000
 80088ae:	d119      	bne.n	80088e4 <__ieee754_sqrt+0x16c>
 80088b0:	0076      	lsls	r6, r6, #1
 80088b2:	3301      	adds	r3, #1
 80088b4:	02f1      	lsls	r1, r6, #11
 80088b6:	d5fb      	bpl.n	80088b0 <__ieee754_sqrt+0x138>
 80088b8:	f1c3 0101 	rsb	r1, r3, #1
 80088bc:	f1c3 0220 	rsb	r2, r3, #32
 80088c0:	fa28 f202 	lsr.w	r2, r8, r2
 80088c4:	187f      	adds	r7, r7, r1
 80088c6:	4316      	orrs	r6, r2
 80088c8:	fa08 f803 	lsl.w	r8, r8, r3
 80088cc:	e76b      	b.n	80087a6 <__ieee754_sqrt+0x2e>
 80088ce:	f001 fc8d 	bl	800a1ec <__aeabi_dmul>
 80088d2:	4602      	mov	r2, r0
 80088d4:	460b      	mov	r3, r1
 80088d6:	4620      	mov	r0, r4
 80088d8:	4629      	mov	r1, r5
 80088da:	f7fe fe05 	bl	80074e8 <__adddf3>
 80088de:	4604      	mov	r4, r0
 80088e0:	460d      	mov	r5, r1
 80088e2:	e7c8      	b.n	8008876 <__ieee754_sqrt+0xfe>
 80088e4:	2220      	movs	r2, #32
 80088e6:	2101      	movs	r1, #1
 80088e8:	2300      	movs	r3, #0
 80088ea:	e7e9      	b.n	80088c0 <__ieee754_sqrt+0x148>
 80088ec:	4602      	mov	r2, r0
 80088ee:	460b      	mov	r3, r1
 80088f0:	f7fe fdf8 	bl	80074e4 <__aeabi_dsub>
 80088f4:	4602      	mov	r2, r0
 80088f6:	460b      	mov	r3, r1
 80088f8:	f001 fda2 	bl	800a440 <__aeabi_ddiv>
 80088fc:	4604      	mov	r4, r0
 80088fe:	460d      	mov	r5, r1
 8008900:	e7b9      	b.n	8008876 <__ieee754_sqrt+0xfe>
 8008902:	bf00      	nop

08008904 <__ieee754_asinf>:
 8008904:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008908:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 800890c:	f1b5 5f7e 	cmp.w	r5, #1065353216	; 0x3f800000
 8008910:	4604      	mov	r4, r0
 8008912:	4606      	mov	r6, r0
 8008914:	f000 80fd 	beq.w	8008b12 <__ieee754_asinf+0x20e>
 8008918:	f300 80d5 	bgt.w	8008ac6 <__ieee754_asinf+0x1c2>
 800891c:	f1b5 5f7c 	cmp.w	r5, #1056964608	; 0x3f000000
 8008920:	da10      	bge.n	8008944 <__ieee754_asinf+0x40>
 8008922:	f1b5 5f48 	cmp.w	r5, #838860800	; 0x32000000
 8008926:	f280 810a 	bge.w	8008b3e <__ieee754_asinf+0x23a>
 800892a:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 800892e:	f2c7 1149 	movt	r1, #29001	; 0x7149
 8008932:	f7ff f809 	bl	8007948 <__addsf3>
 8008936:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800893a:	f7ff fac9 	bl	8007ed0 <__aeabi_fcmpgt>
 800893e:	2800      	cmp	r0, #0
 8008940:	f040 80c8 	bne.w	8008ad4 <__ieee754_asinf+0x1d0>
 8008944:	4620      	mov	r0, r4
 8008946:	f001 fb7d 	bl	800a044 <fabsf>
 800894a:	4601      	mov	r1, r0
 800894c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8008950:	f7fe fff8 	bl	8007944 <__aeabi_fsub>
 8008954:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8008958:	f7ff f8fe 	bl	8007b58 <__aeabi_fmul>
 800895c:	f64e 7108 	movw	r1, #61192	; 0xef08
 8008960:	f6c3 0111 	movt	r1, #14353	; 0x3811
 8008964:	4604      	mov	r4, r0
 8008966:	f7ff f8f7 	bl	8007b58 <__aeabi_fmul>
 800896a:	f647 7104 	movw	r1, #32516	; 0x7f04
 800896e:	f6c3 214f 	movt	r1, #14927	; 0x3a4f
 8008972:	f7fe ffe9 	bl	8007948 <__addsf3>
 8008976:	4621      	mov	r1, r4
 8008978:	f7ff f8ee 	bl	8007b58 <__aeabi_fmul>
 800897c:	f241 1146 	movw	r1, #4422	; 0x1146
 8008980:	f6c3 5124 	movt	r1, #15652	; 0x3d24
 8008984:	f7fe ffde 	bl	8007944 <__aeabi_fsub>
 8008988:	4621      	mov	r1, r4
 800898a:	f7ff f8e5 	bl	8007b58 <__aeabi_fmul>
 800898e:	f640 21a8 	movw	r1, #2728	; 0xaa8
 8008992:	f6c3 614e 	movt	r1, #15950	; 0x3e4e
 8008996:	f7fe ffd7 	bl	8007948 <__addsf3>
 800899a:	4621      	mov	r1, r4
 800899c:	f7ff f8dc 	bl	8007b58 <__aeabi_fmul>
 80089a0:	f24b 0190 	movw	r1, #45200	; 0xb090
 80089a4:	f6c3 61a6 	movt	r1, #16038	; 0x3ea6
 80089a8:	f7fe ffcc 	bl	8007944 <__aeabi_fsub>
 80089ac:	4621      	mov	r1, r4
 80089ae:	f7ff f8d3 	bl	8007b58 <__aeabi_fmul>
 80089b2:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 80089b6:	f6c3 612a 	movt	r1, #15914	; 0x3e2a
 80089ba:	f7fe ffc5 	bl	8007948 <__addsf3>
 80089be:	4621      	mov	r1, r4
 80089c0:	f7ff f8ca 	bl	8007b58 <__aeabi_fmul>
 80089c4:	f24c 612e 	movw	r1, #50734	; 0xc62e
 80089c8:	f6c3 519d 	movt	r1, #15773	; 0x3d9d
 80089cc:	4681      	mov	r9, r0
 80089ce:	4620      	mov	r0, r4
 80089d0:	f7ff f8c2 	bl	8007b58 <__aeabi_fmul>
 80089d4:	f243 3161 	movw	r1, #13153	; 0x3361
 80089d8:	f6c3 7130 	movt	r1, #16176	; 0x3f30
 80089dc:	f7fe ffb2 	bl	8007944 <__aeabi_fsub>
 80089e0:	4621      	mov	r1, r4
 80089e2:	f7ff f8b9 	bl	8007b58 <__aeabi_fmul>
 80089e6:	f245 712d 	movw	r1, #22317	; 0x572d
 80089ea:	f2c4 0101 	movt	r1, #16385	; 0x4001
 80089ee:	f7fe ffab 	bl	8007948 <__addsf3>
 80089f2:	4621      	mov	r1, r4
 80089f4:	f7ff f8b0 	bl	8007b58 <__aeabi_fmul>
 80089f8:	f24d 1139 	movw	r1, #53561	; 0xd139
 80089fc:	f2c4 0119 	movt	r1, #16409	; 0x4019
 8008a00:	f7fe ffa0 	bl	8007944 <__aeabi_fsub>
 8008a04:	4621      	mov	r1, r4
 8008a06:	f7ff f8a7 	bl	8007b58 <__aeabi_fmul>
 8008a0a:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8008a0e:	f7fe ff9b 	bl	8007948 <__addsf3>
 8008a12:	4680      	mov	r8, r0
 8008a14:	4620      	mov	r0, r4
 8008a16:	f000 fb4d 	bl	80090b4 <__ieee754_sqrtf>
 8008a1a:	f649 1399 	movw	r3, #39321	; 0x9999
 8008a1e:	f6c3 7379 	movt	r3, #16249	; 0x3f79
 8008a22:	429d      	cmp	r5, r3
 8008a24:	4607      	mov	r7, r0
 8008a26:	dc58      	bgt.n	8008ada <__ieee754_asinf+0x1d6>
 8008a28:	4601      	mov	r1, r0
 8008a2a:	f420 657f 	bic.w	r5, r0, #4080	; 0xff0
 8008a2e:	f7fe ff8b 	bl	8007948 <__addsf3>
 8008a32:	4641      	mov	r1, r8
 8008a34:	f025 050f 	bic.w	r5, r5, #15
 8008a38:	4682      	mov	sl, r0
 8008a3a:	4648      	mov	r0, r9
 8008a3c:	f7ff f940 	bl	8007cc0 <__aeabi_fdiv>
 8008a40:	4601      	mov	r1, r0
 8008a42:	4650      	mov	r0, sl
 8008a44:	f7ff f888 	bl	8007b58 <__aeabi_fmul>
 8008a48:	4629      	mov	r1, r5
 8008a4a:	4680      	mov	r8, r0
 8008a4c:	4628      	mov	r0, r5
 8008a4e:	f7ff f883 	bl	8007b58 <__aeabi_fmul>
 8008a52:	4601      	mov	r1, r0
 8008a54:	4620      	mov	r0, r4
 8008a56:	f7fe ff75 	bl	8007944 <__aeabi_fsub>
 8008a5a:	4629      	mov	r1, r5
 8008a5c:	4604      	mov	r4, r0
 8008a5e:	4638      	mov	r0, r7
 8008a60:	f7fe ff72 	bl	8007948 <__addsf3>
 8008a64:	4601      	mov	r1, r0
 8008a66:	4620      	mov	r0, r4
 8008a68:	f7ff f92a 	bl	8007cc0 <__aeabi_fdiv>
 8008a6c:	4601      	mov	r1, r0
 8008a6e:	f7fe ff6b 	bl	8007948 <__addsf3>
 8008a72:	4601      	mov	r1, r0
 8008a74:	f64b 502e 	movw	r0, #48430	; 0xbd2e
 8008a78:	f2cb 303b 	movt	r0, #45883	; 0xb33b
 8008a7c:	f7fe ff62 	bl	8007944 <__aeabi_fsub>
 8008a80:	4601      	mov	r1, r0
 8008a82:	4640      	mov	r0, r8
 8008a84:	f7fe ff5e 	bl	8007944 <__aeabi_fsub>
 8008a88:	4629      	mov	r1, r5
 8008a8a:	4604      	mov	r4, r0
 8008a8c:	4628      	mov	r0, r5
 8008a8e:	f7fe ff5b 	bl	8007948 <__addsf3>
 8008a92:	4601      	mov	r1, r0
 8008a94:	f640 70db 	movw	r0, #4059	; 0xfdb
 8008a98:	f6c3 7049 	movt	r0, #16201	; 0x3f49
 8008a9c:	f7fe ff52 	bl	8007944 <__aeabi_fsub>
 8008aa0:	4601      	mov	r1, r0
 8008aa2:	4620      	mov	r0, r4
 8008aa4:	f7fe ff4e 	bl	8007944 <__aeabi_fsub>
 8008aa8:	4601      	mov	r1, r0
 8008aaa:	f640 70db 	movw	r0, #4059	; 0xfdb
 8008aae:	f6c3 7049 	movt	r0, #16201	; 0x3f49
 8008ab2:	f7fe ff47 	bl	8007944 <__aeabi_fsub>
 8008ab6:	2e00      	cmp	r6, #0
 8008ab8:	bfd4      	ite	le
 8008aba:	f100 4400 	addle.w	r4, r0, #2147483648	; 0x80000000
 8008abe:	4604      	movgt	r4, r0
 8008ac0:	4620      	mov	r0, r4
 8008ac2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008ac6:	4601      	mov	r1, r0
 8008ac8:	f7fe ff3c 	bl	8007944 <__aeabi_fsub>
 8008acc:	4601      	mov	r1, r0
 8008ace:	f7ff f8f7 	bl	8007cc0 <__aeabi_fdiv>
 8008ad2:	4604      	mov	r4, r0
 8008ad4:	4620      	mov	r0, r4
 8008ad6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008ada:	4641      	mov	r1, r8
 8008adc:	4648      	mov	r0, r9
 8008ade:	f7ff f8ef 	bl	8007cc0 <__aeabi_fdiv>
 8008ae2:	4601      	mov	r1, r0
 8008ae4:	4638      	mov	r0, r7
 8008ae6:	f7ff f837 	bl	8007b58 <__aeabi_fmul>
 8008aea:	4639      	mov	r1, r7
 8008aec:	f7fe ff2c 	bl	8007948 <__addsf3>
 8008af0:	4601      	mov	r1, r0
 8008af2:	f7fe ff29 	bl	8007948 <__addsf3>
 8008af6:	f64b 512e 	movw	r1, #48430	; 0xbd2e
 8008afa:	f2c3 313b 	movt	r1, #13115	; 0x333b
 8008afe:	f7fe ff23 	bl	8007948 <__addsf3>
 8008b02:	4601      	mov	r1, r0
 8008b04:	f640 70db 	movw	r0, #4059	; 0xfdb
 8008b08:	f6c3 70c9 	movt	r0, #16329	; 0x3fc9
 8008b0c:	f7fe ff1a 	bl	8007944 <__aeabi_fsub>
 8008b10:	e7d1      	b.n	8008ab6 <__ieee754_asinf+0x1b2>
 8008b12:	f640 71db 	movw	r1, #4059	; 0xfdb
 8008b16:	f6c3 71c9 	movt	r1, #16329	; 0x3fc9
 8008b1a:	f7ff f81d 	bl	8007b58 <__aeabi_fmul>
 8008b1e:	f64b 512e 	movw	r1, #48430	; 0xbd2e
 8008b22:	f2cb 313b 	movt	r1, #45883	; 0xb33b
 8008b26:	4605      	mov	r5, r0
 8008b28:	4620      	mov	r0, r4
 8008b2a:	f7ff f815 	bl	8007b58 <__aeabi_fmul>
 8008b2e:	4601      	mov	r1, r0
 8008b30:	4628      	mov	r0, r5
 8008b32:	f7fe ff09 	bl	8007948 <__addsf3>
 8008b36:	4604      	mov	r4, r0
 8008b38:	4620      	mov	r0, r4
 8008b3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008b3e:	4601      	mov	r1, r0
 8008b40:	f7ff f80a 	bl	8007b58 <__aeabi_fmul>
 8008b44:	f64e 7108 	movw	r1, #61192	; 0xef08
 8008b48:	f6c3 0111 	movt	r1, #14353	; 0x3811
 8008b4c:	4605      	mov	r5, r0
 8008b4e:	f7ff f803 	bl	8007b58 <__aeabi_fmul>
 8008b52:	f647 7104 	movw	r1, #32516	; 0x7f04
 8008b56:	f6c3 214f 	movt	r1, #14927	; 0x3a4f
 8008b5a:	f7fe fef5 	bl	8007948 <__addsf3>
 8008b5e:	4629      	mov	r1, r5
 8008b60:	f7fe fffa 	bl	8007b58 <__aeabi_fmul>
 8008b64:	f241 1146 	movw	r1, #4422	; 0x1146
 8008b68:	f6c3 5124 	movt	r1, #15652	; 0x3d24
 8008b6c:	f7fe feea 	bl	8007944 <__aeabi_fsub>
 8008b70:	4629      	mov	r1, r5
 8008b72:	f7fe fff1 	bl	8007b58 <__aeabi_fmul>
 8008b76:	f640 21a8 	movw	r1, #2728	; 0xaa8
 8008b7a:	f6c3 614e 	movt	r1, #15950	; 0x3e4e
 8008b7e:	f7fe fee3 	bl	8007948 <__addsf3>
 8008b82:	4629      	mov	r1, r5
 8008b84:	f7fe ffe8 	bl	8007b58 <__aeabi_fmul>
 8008b88:	f24b 0190 	movw	r1, #45200	; 0xb090
 8008b8c:	f6c3 61a6 	movt	r1, #16038	; 0x3ea6
 8008b90:	f7fe fed8 	bl	8007944 <__aeabi_fsub>
 8008b94:	4629      	mov	r1, r5
 8008b96:	f7fe ffdf 	bl	8007b58 <__aeabi_fmul>
 8008b9a:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8008b9e:	f6c3 612a 	movt	r1, #15914	; 0x3e2a
 8008ba2:	f7fe fed1 	bl	8007948 <__addsf3>
 8008ba6:	4629      	mov	r1, r5
 8008ba8:	f7fe ffd6 	bl	8007b58 <__aeabi_fmul>
 8008bac:	f24c 612e 	movw	r1, #50734	; 0xc62e
 8008bb0:	f6c3 519d 	movt	r1, #15773	; 0x3d9d
 8008bb4:	4606      	mov	r6, r0
 8008bb6:	4628      	mov	r0, r5
 8008bb8:	f7fe ffce 	bl	8007b58 <__aeabi_fmul>
 8008bbc:	f243 3161 	movw	r1, #13153	; 0x3361
 8008bc0:	f6c3 7130 	movt	r1, #16176	; 0x3f30
 8008bc4:	f7fe febe 	bl	8007944 <__aeabi_fsub>
 8008bc8:	4629      	mov	r1, r5
 8008bca:	f7fe ffc5 	bl	8007b58 <__aeabi_fmul>
 8008bce:	f245 712d 	movw	r1, #22317	; 0x572d
 8008bd2:	f2c4 0101 	movt	r1, #16385	; 0x4001
 8008bd6:	f7fe feb7 	bl	8007948 <__addsf3>
 8008bda:	4629      	mov	r1, r5
 8008bdc:	f7fe ffbc 	bl	8007b58 <__aeabi_fmul>
 8008be0:	f24d 1139 	movw	r1, #53561	; 0xd139
 8008be4:	f2c4 0119 	movt	r1, #16409	; 0x4019
 8008be8:	f7fe feac 	bl	8007944 <__aeabi_fsub>
 8008bec:	4629      	mov	r1, r5
 8008bee:	f7fe ffb3 	bl	8007b58 <__aeabi_fmul>
 8008bf2:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8008bf6:	f7fe fea7 	bl	8007948 <__addsf3>
 8008bfa:	4601      	mov	r1, r0
 8008bfc:	4630      	mov	r0, r6
 8008bfe:	f7ff f85f 	bl	8007cc0 <__aeabi_fdiv>
 8008c02:	4601      	mov	r1, r0
 8008c04:	4620      	mov	r0, r4
 8008c06:	f7fe ffa7 	bl	8007b58 <__aeabi_fmul>
 8008c0a:	4601      	mov	r1, r0
 8008c0c:	4620      	mov	r0, r4
 8008c0e:	f7fe fe9b 	bl	8007948 <__addsf3>
 8008c12:	4604      	mov	r4, r0
 8008c14:	4620      	mov	r0, r4
 8008c16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008c1a:	bf00      	nop

08008c1c <__ieee754_atan2f>:
 8008c1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008c1e:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 8008c22:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 8008c26:	4603      	mov	r3, r0
 8008c28:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8008c2c:	bfd8      	it	le
 8008c2e:	f1b6 4fff 	cmple.w	r6, #2139095040	; 0x7f800000
 8008c32:	4605      	mov	r5, r0
 8008c34:	dc45      	bgt.n	8008cc2 <__ieee754_atan2f+0xa6>
 8008c36:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
 8008c3a:	d04c      	beq.n	8008cd6 <__ieee754_atan2f+0xba>
 8008c3c:	178f      	asrs	r7, r1, #30
 8008c3e:	f007 0702 	and.w	r7, r7, #2
 8008c42:	ea47 77d0 	orr.w	r7, r7, r0, lsr #31
 8008c46:	b94c      	cbnz	r4, 8008c5c <__ieee754_atan2f+0x40>
 8008c48:	2f02      	cmp	r7, #2
 8008c4a:	d03f      	beq.n	8008ccc <__ieee754_atan2f+0xb0>
 8008c4c:	2f03      	cmp	r7, #3
 8008c4e:	d103      	bne.n	8008c58 <__ieee754_atan2f+0x3c>
 8008c50:	f640 73db 	movw	r3, #4059	; 0xfdb
 8008c54:	f2cc 0349 	movt	r3, #49225	; 0xc049
 8008c58:	4618      	mov	r0, r3
 8008c5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008c5c:	b336      	cbz	r6, 8008cac <__ieee754_atan2f+0x90>
 8008c5e:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8008c62:	d055      	beq.n	8008d10 <__ieee754_atan2f+0xf4>
 8008c64:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8008c68:	d020      	beq.n	8008cac <__ieee754_atan2f+0x90>
 8008c6a:	1ba4      	subs	r4, r4, r6
 8008c6c:	15e4      	asrs	r4, r4, #23
 8008c6e:	2c3c      	cmp	r4, #60	; 0x3c
 8008c70:	bfc4      	itt	gt
 8008c72:	f640 70db 	movwgt	r0, #4059	; 0xfdb
 8008c76:	f6c3 70c9 	movtgt	r0, #16329	; 0x3fc9
 8008c7a:	dd30      	ble.n	8008cde <__ieee754_atan2f+0xc2>
 8008c7c:	2f01      	cmp	r7, #1
 8008c7e:	bf08      	it	eq
 8008c80:	f100 4300 	addeq.w	r3, r0, #2147483648	; 0x80000000
 8008c84:	d0e8      	beq.n	8008c58 <__ieee754_atan2f+0x3c>
 8008c86:	2f02      	cmp	r7, #2
 8008c88:	d033      	beq.n	8008cf2 <__ieee754_atan2f+0xd6>
 8008c8a:	4603      	mov	r3, r0
 8008c8c:	2f00      	cmp	r7, #0
 8008c8e:	d0e3      	beq.n	8008c58 <__ieee754_atan2f+0x3c>
 8008c90:	f64b 512e 	movw	r1, #48430	; 0xbd2e
 8008c94:	f2c3 31bb 	movt	r1, #13243	; 0x33bb
 8008c98:	f7fe fe56 	bl	8007948 <__addsf3>
 8008c9c:	f640 71db 	movw	r1, #4059	; 0xfdb
 8008ca0:	f2c4 0149 	movt	r1, #16457	; 0x4049
 8008ca4:	f7fe fe4e 	bl	8007944 <__aeabi_fsub>
 8008ca8:	4603      	mov	r3, r0
 8008caa:	e7d5      	b.n	8008c58 <__ieee754_atan2f+0x3c>
 8008cac:	2d00      	cmp	r5, #0
 8008cae:	f640 73db 	movw	r3, #4059	; 0xfdb
 8008cb2:	bfb8      	it	lt
 8008cb4:	f6cb 73c9 	movtlt	r3, #49097	; 0xbfc9
 8008cb8:	dbce      	blt.n	8008c58 <__ieee754_atan2f+0x3c>
 8008cba:	f6c3 73c9 	movt	r3, #16329	; 0x3fc9
 8008cbe:	4618      	mov	r0, r3
 8008cc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008cc2:	f7fe fe41 	bl	8007948 <__addsf3>
 8008cc6:	4603      	mov	r3, r0
 8008cc8:	4618      	mov	r0, r3
 8008cca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008ccc:	f640 73db 	movw	r3, #4059	; 0xfdb
 8008cd0:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8008cd4:	e7c0      	b.n	8008c58 <__ieee754_atan2f+0x3c>
 8008cd6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8008cda:	f001 b895 	b.w	8009e08 <atanf>
 8008cde:	f114 0f3c 	cmn.w	r4, #60	; 0x3c
 8008ce2:	bfac      	ite	ge
 8008ce4:	2400      	movge	r4, #0
 8008ce6:	2401      	movlt	r4, #1
 8008ce8:	ea14 74d1 	ands.w	r4, r4, r1, lsr #31
 8008cec:	d01d      	beq.n	8008d2a <__ieee754_atan2f+0x10e>
 8008cee:	2000      	movs	r0, #0
 8008cf0:	e7c4      	b.n	8008c7c <__ieee754_atan2f+0x60>
 8008cf2:	f64b 512e 	movw	r1, #48430	; 0xbd2e
 8008cf6:	f2c3 31bb 	movt	r1, #13243	; 0x33bb
 8008cfa:	f7fe fe25 	bl	8007948 <__addsf3>
 8008cfe:	4601      	mov	r1, r0
 8008d00:	f640 70db 	movw	r0, #4059	; 0xfdb
 8008d04:	f2c4 0049 	movt	r0, #16457	; 0x4049
 8008d08:	f7fe fe1c 	bl	8007944 <__aeabi_fsub>
 8008d0c:	4603      	mov	r3, r0
 8008d0e:	e7a3      	b.n	8008c58 <__ieee754_atan2f+0x3c>
 8008d10:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8008d14:	d010      	beq.n	8008d38 <__ieee754_atan2f+0x11c>
 8008d16:	2f02      	cmp	r7, #2
 8008d18:	d0d8      	beq.n	8008ccc <__ieee754_atan2f+0xb0>
 8008d1a:	2f03      	cmp	r7, #3
 8008d1c:	d098      	beq.n	8008c50 <__ieee754_atan2f+0x34>
 8008d1e:	2300      	movs	r3, #0
 8008d20:	2f01      	cmp	r7, #1
 8008d22:	d199      	bne.n	8008c58 <__ieee754_atan2f+0x3c>
 8008d24:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8008d28:	e796      	b.n	8008c58 <__ieee754_atan2f+0x3c>
 8008d2a:	f7fe ffc9 	bl	8007cc0 <__aeabi_fdiv>
 8008d2e:	f001 f989 	bl	800a044 <fabsf>
 8008d32:	f001 f869 	bl	8009e08 <atanf>
 8008d36:	e7a1      	b.n	8008c7c <__ieee754_atan2f+0x60>
 8008d38:	2f02      	cmp	r7, #2
 8008d3a:	d00b      	beq.n	8008d54 <__ieee754_atan2f+0x138>
 8008d3c:	2f03      	cmp	r7, #3
 8008d3e:	d00e      	beq.n	8008d5e <__ieee754_atan2f+0x142>
 8008d40:	2f01      	cmp	r7, #1
 8008d42:	f640 73db 	movw	r3, #4059	; 0xfdb
 8008d46:	bf18      	it	ne
 8008d48:	f6c3 7349 	movtne	r3, #16201	; 0x3f49
 8008d4c:	d184      	bne.n	8008c58 <__ieee754_atan2f+0x3c>
 8008d4e:	f6cb 7349 	movt	r3, #48969	; 0xbf49
 8008d52:	e781      	b.n	8008c58 <__ieee754_atan2f+0x3c>
 8008d54:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
 8008d58:	f2c4 0316 	movt	r3, #16406	; 0x4016
 8008d5c:	e77c      	b.n	8008c58 <__ieee754_atan2f+0x3c>
 8008d5e:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
 8008d62:	f2cc 0316 	movt	r3, #49174	; 0xc016
 8008d66:	e777      	b.n	8008c58 <__ieee754_atan2f+0x3c>

08008d68 <__ieee754_rem_pio2f>:
 8008d68:	f640 73d8 	movw	r3, #4056	; 0xfd8
 8008d6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008d70:	f6c3 7349 	movt	r3, #16201	; 0x3f49
 8008d74:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 8008d78:	b089      	sub	sp, #36	; 0x24
 8008d7a:	429c      	cmp	r4, r3
 8008d7c:	4606      	mov	r6, r0
 8008d7e:	460d      	mov	r5, r1
 8008d80:	f340 8088 	ble.w	8008e94 <__ieee754_rem_pio2f+0x12c>
 8008d84:	f64c 33e3 	movw	r3, #52195	; 0xcbe3
 8008d88:	f2c4 0316 	movt	r3, #16406	; 0x4016
 8008d8c:	429c      	cmp	r4, r3
 8008d8e:	dc25      	bgt.n	8008ddc <__ieee754_rem_pio2f+0x74>
 8008d90:	2800      	cmp	r0, #0
 8008d92:	f44f 6178 	mov.w	r1, #3968	; 0xf80
 8008d96:	f6c3 71c9 	movt	r1, #16329	; 0x3fc9
 8008d9a:	f340 814d 	ble.w	8009038 <__ieee754_rem_pio2f+0x2d0>
 8008d9e:	f7fe fdd1 	bl	8007944 <__aeabi_fsub>
 8008da2:	f44f 637d 	mov.w	r3, #4048	; 0xfd0
 8008da6:	f024 040f 	bic.w	r4, r4, #15
 8008daa:	f6c3 73c9 	movt	r3, #16329	; 0x3fc9
 8008dae:	429c      	cmp	r4, r3
 8008db0:	4606      	mov	r6, r0
 8008db2:	d07e      	beq.n	8008eb2 <__ieee754_rem_pio2f+0x14a>
 8008db4:	f244 4143 	movw	r1, #17475	; 0x4443
 8008db8:	2701      	movs	r7, #1
 8008dba:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008dbe:	f7fe fdc1 	bl	8007944 <__aeabi_fsub>
 8008dc2:	4601      	mov	r1, r0
 8008dc4:	6028      	str	r0, [r5, #0]
 8008dc6:	4630      	mov	r0, r6
 8008dc8:	f7fe fdbc 	bl	8007944 <__aeabi_fsub>
 8008dcc:	f244 4143 	movw	r1, #17475	; 0x4443
 8008dd0:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008dd4:	f7fe fdb6 	bl	8007944 <__aeabi_fsub>
 8008dd8:	6068      	str	r0, [r5, #4]
 8008dda:	e05f      	b.n	8008e9c <__ieee754_rem_pio2f+0x134>
 8008ddc:	f44f 6378 	mov.w	r3, #3968	; 0xf80
 8008de0:	f2c4 3349 	movt	r3, #17225	; 0x4349
 8008de4:	429c      	cmp	r4, r3
 8008de6:	dd7f      	ble.n	8008ee8 <__ieee754_rem_pio2f+0x180>
 8008de8:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8008dec:	da5a      	bge.n	8008ea4 <__ieee754_rem_pio2f+0x13c>
 8008dee:	ea4f 59e4 	mov.w	r9, r4, asr #23
 8008df2:	f1a9 0986 	sub.w	r9, r9, #134	; 0x86
 8008df6:	eba4 54c9 	sub.w	r4, r4, r9, lsl #23
 8008dfa:	4620      	mov	r0, r4
 8008dfc:	f7ff f872 	bl	8007ee4 <__aeabi_f2iz>
 8008e00:	f7fe fe56 	bl	8007ab0 <__aeabi_i2f>
 8008e04:	4603      	mov	r3, r0
 8008e06:	4601      	mov	r1, r0
 8008e08:	4620      	mov	r0, r4
 8008e0a:	9305      	str	r3, [sp, #20]
 8008e0c:	f7fe fd9a 	bl	8007944 <__aeabi_fsub>
 8008e10:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8008e14:	f7fe fea0 	bl	8007b58 <__aeabi_fmul>
 8008e18:	4607      	mov	r7, r0
 8008e1a:	f7ff f863 	bl	8007ee4 <__aeabi_f2iz>
 8008e1e:	f7fe fe47 	bl	8007ab0 <__aeabi_i2f>
 8008e22:	4601      	mov	r1, r0
 8008e24:	4604      	mov	r4, r0
 8008e26:	4638      	mov	r0, r7
 8008e28:	9406      	str	r4, [sp, #24]
 8008e2a:	f7fe fd8b 	bl	8007944 <__aeabi_fsub>
 8008e2e:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8008e32:	f7fe fe91 	bl	8007b58 <__aeabi_fmul>
 8008e36:	2100      	movs	r1, #0
 8008e38:	2703      	movs	r7, #3
 8008e3a:	9007      	str	r0, [sp, #28]
 8008e3c:	f7ff f820 	bl	8007e80 <__aeabi_fcmpeq>
 8008e40:	b188      	cbz	r0, 8008e66 <__ieee754_rem_pio2f+0xfe>
 8008e42:	2703      	movs	r7, #3
 8008e44:	4620      	mov	r0, r4
 8008e46:	2100      	movs	r1, #0
 8008e48:	f10d 0818 	add.w	r8, sp, #24
 8008e4c:	3f01      	subs	r7, #1
 8008e4e:	f7ff f817 	bl	8007e80 <__aeabi_fcmpeq>
 8008e52:	b140      	cbz	r0, 8008e66 <__ieee754_rem_pio2f+0xfe>
 8008e54:	f858 4d04 	ldr.w	r4, [r8, #-4]!
 8008e58:	2100      	movs	r1, #0
 8008e5a:	3f01      	subs	r7, #1
 8008e5c:	4620      	mov	r0, r4
 8008e5e:	f7ff f80f 	bl	8007e80 <__aeabi_fcmpeq>
 8008e62:	2800      	cmp	r0, #0
 8008e64:	d1f6      	bne.n	8008e54 <__ieee754_rem_pio2f+0xec>
 8008e66:	2302      	movs	r3, #2
 8008e68:	9300      	str	r3, [sp, #0]
 8008e6a:	4b91      	ldr	r3, [pc, #580]	; (80090b0 <__ieee754_rem_pio2f+0x348>)
 8008e6c:	a805      	add	r0, sp, #20
 8008e6e:	4629      	mov	r1, r5
 8008e70:	464a      	mov	r2, r9
 8008e72:	9301      	str	r3, [sp, #4]
 8008e74:	463b      	mov	r3, r7
 8008e76:	f000 fa4d 	bl	8009314 <__kernel_rem_pio2f>
 8008e7a:	2e00      	cmp	r6, #0
 8008e7c:	4607      	mov	r7, r0
 8008e7e:	da0d      	bge.n	8008e9c <__ieee754_rem_pio2f+0x134>
 8008e80:	682a      	ldr	r2, [r5, #0]
 8008e82:	4247      	negs	r7, r0
 8008e84:	686b      	ldr	r3, [r5, #4]
 8008e86:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 8008e8a:	602a      	str	r2, [r5, #0]
 8008e8c:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8008e90:	606b      	str	r3, [r5, #4]
 8008e92:	e003      	b.n	8008e9c <__ieee754_rem_pio2f+0x134>
 8008e94:	2700      	movs	r7, #0
 8008e96:	6028      	str	r0, [r5, #0]
 8008e98:	2300      	movs	r3, #0
 8008e9a:	604b      	str	r3, [r1, #4]
 8008e9c:	4638      	mov	r0, r7
 8008e9e:	b009      	add	sp, #36	; 0x24
 8008ea0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008ea4:	4601      	mov	r1, r0
 8008ea6:	2700      	movs	r7, #0
 8008ea8:	f7fe fd4c 	bl	8007944 <__aeabi_fsub>
 8008eac:	6068      	str	r0, [r5, #4]
 8008eae:	6028      	str	r0, [r5, #0]
 8008eb0:	e7f4      	b.n	8008e9c <__ieee754_rem_pio2f+0x134>
 8008eb2:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 8008eb6:	2701      	movs	r7, #1
 8008eb8:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008ebc:	f7fe fd42 	bl	8007944 <__aeabi_fsub>
 8008ec0:	f24a 3108 	movw	r1, #41736	; 0xa308
 8008ec4:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008ec8:	4604      	mov	r4, r0
 8008eca:	f7fe fd3b 	bl	8007944 <__aeabi_fsub>
 8008ece:	4601      	mov	r1, r0
 8008ed0:	6028      	str	r0, [r5, #0]
 8008ed2:	4620      	mov	r0, r4
 8008ed4:	f7fe fd36 	bl	8007944 <__aeabi_fsub>
 8008ed8:	f24a 3108 	movw	r1, #41736	; 0xa308
 8008edc:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008ee0:	f7fe fd30 	bl	8007944 <__aeabi_fsub>
 8008ee4:	6068      	str	r0, [r5, #4]
 8008ee6:	e7d9      	b.n	8008e9c <__ieee754_rem_pio2f+0x134>
 8008ee8:	f001 f8ac 	bl	800a044 <fabsf>
 8008eec:	f64f 1184 	movw	r1, #63876	; 0xf984
 8008ef0:	f6c3 7122 	movt	r1, #16162	; 0x3f22
 8008ef4:	4680      	mov	r8, r0
 8008ef6:	f7fe fe2f 	bl	8007b58 <__aeabi_fmul>
 8008efa:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8008efe:	f7fe fd23 	bl	8007948 <__addsf3>
 8008f02:	f7fe ffef 	bl	8007ee4 <__aeabi_f2iz>
 8008f06:	4607      	mov	r7, r0
 8008f08:	f7fe fdd2 	bl	8007ab0 <__aeabi_i2f>
 8008f0c:	f44f 6178 	mov.w	r1, #3968	; 0xf80
 8008f10:	f6c3 71c9 	movt	r1, #16329	; 0x3fc9
 8008f14:	4683      	mov	fp, r0
 8008f16:	f7fe fe1f 	bl	8007b58 <__aeabi_fmul>
 8008f1a:	4601      	mov	r1, r0
 8008f1c:	4640      	mov	r0, r8
 8008f1e:	f7fe fd11 	bl	8007944 <__aeabi_fsub>
 8008f22:	f244 4143 	movw	r1, #17475	; 0x4443
 8008f26:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008f2a:	4681      	mov	r9, r0
 8008f2c:	4658      	mov	r0, fp
 8008f2e:	f7fe fe13 	bl	8007b58 <__aeabi_fmul>
 8008f32:	2f1f      	cmp	r7, #31
 8008f34:	4682      	mov	sl, r0
 8008f36:	4648      	mov	r0, r9
 8008f38:	dc23      	bgt.n	8008f82 <__ieee754_rem_pio2f+0x21a>
 8008f3a:	f64a 036c 	movw	r3, #43116	; 0xa86c
 8008f3e:	1e79      	subs	r1, r7, #1
 8008f40:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008f44:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
 8008f48:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8008f4c:	429a      	cmp	r2, r3
 8008f4e:	d018      	beq.n	8008f82 <__ieee754_rem_pio2f+0x21a>
 8008f50:	4651      	mov	r1, sl
 8008f52:	f7fe fcf7 	bl	8007944 <__aeabi_fsub>
 8008f56:	4680      	mov	r8, r0
 8008f58:	f8c5 8000 	str.w	r8, [r5]
 8008f5c:	4641      	mov	r1, r8
 8008f5e:	4648      	mov	r0, r9
 8008f60:	f7fe fcf0 	bl	8007944 <__aeabi_fsub>
 8008f64:	4651      	mov	r1, sl
 8008f66:	f7fe fced 	bl	8007944 <__aeabi_fsub>
 8008f6a:	2e00      	cmp	r6, #0
 8008f6c:	6068      	str	r0, [r5, #4]
 8008f6e:	da95      	bge.n	8008e9c <__ieee754_rem_pio2f+0x134>
 8008f70:	f108 4800 	add.w	r8, r8, #2147483648	; 0x80000000
 8008f74:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8008f78:	f8c5 8000 	str.w	r8, [r5]
 8008f7c:	427f      	negs	r7, r7
 8008f7e:	6068      	str	r0, [r5, #4]
 8008f80:	e78c      	b.n	8008e9c <__ieee754_rem_pio2f+0x134>
 8008f82:	4651      	mov	r1, sl
 8008f84:	f7fe fcde 	bl	8007944 <__aeabi_fsub>
 8008f88:	15e3      	asrs	r3, r4, #23
 8008f8a:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 8008f8e:	4680      	mov	r8, r0
 8008f90:	1a9a      	subs	r2, r3, r2
 8008f92:	2a08      	cmp	r2, #8
 8008f94:	dde0      	ble.n	8008f58 <__ieee754_rem_pio2f+0x1f0>
 8008f96:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 8008f9a:	4658      	mov	r0, fp
 8008f9c:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008fa0:	9303      	str	r3, [sp, #12]
 8008fa2:	f7fe fdd9 	bl	8007b58 <__aeabi_fmul>
 8008fa6:	4680      	mov	r8, r0
 8008fa8:	4648      	mov	r0, r9
 8008faa:	4641      	mov	r1, r8
 8008fac:	f7fe fcca 	bl	8007944 <__aeabi_fsub>
 8008fb0:	4604      	mov	r4, r0
 8008fb2:	4648      	mov	r0, r9
 8008fb4:	4621      	mov	r1, r4
 8008fb6:	f7fe fcc5 	bl	8007944 <__aeabi_fsub>
 8008fba:	4641      	mov	r1, r8
 8008fbc:	f7fe fcc2 	bl	8007944 <__aeabi_fsub>
 8008fc0:	f24a 3108 	movw	r1, #41736	; 0xa308
 8008fc4:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008fc8:	4680      	mov	r8, r0
 8008fca:	4658      	mov	r0, fp
 8008fcc:	f7fe fdc4 	bl	8007b58 <__aeabi_fmul>
 8008fd0:	4641      	mov	r1, r8
 8008fd2:	f7fe fcb7 	bl	8007944 <__aeabi_fsub>
 8008fd6:	4682      	mov	sl, r0
 8008fd8:	4620      	mov	r0, r4
 8008fda:	4651      	mov	r1, sl
 8008fdc:	f7fe fcb2 	bl	8007944 <__aeabi_fsub>
 8008fe0:	9b03      	ldr	r3, [sp, #12]
 8008fe2:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 8008fe6:	4680      	mov	r8, r0
 8008fe8:	1a9b      	subs	r3, r3, r2
 8008fea:	2b19      	cmp	r3, #25
 8008fec:	bfdc      	itt	le
 8008fee:	6028      	strle	r0, [r5, #0]
 8008ff0:	46a1      	movle	r9, r4
 8008ff2:	ddb3      	ble.n	8008f5c <__ieee754_rem_pio2f+0x1f4>
 8008ff4:	f44f 4123 	mov.w	r1, #41728	; 0xa300
 8008ff8:	4658      	mov	r0, fp
 8008ffa:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008ffe:	f7fe fdab 	bl	8007b58 <__aeabi_fmul>
 8009002:	4680      	mov	r8, r0
 8009004:	4620      	mov	r0, r4
 8009006:	4641      	mov	r1, r8
 8009008:	f7fe fc9c 	bl	8007944 <__aeabi_fsub>
 800900c:	4681      	mov	r9, r0
 800900e:	4620      	mov	r0, r4
 8009010:	4649      	mov	r1, r9
 8009012:	f7fe fc97 	bl	8007944 <__aeabi_fsub>
 8009016:	4641      	mov	r1, r8
 8009018:	f7fe fc94 	bl	8007944 <__aeabi_fsub>
 800901c:	f243 1132 	movw	r1, #12594	; 0x3132
 8009020:	f2c2 418d 	movt	r1, #9357	; 0x248d
 8009024:	4604      	mov	r4, r0
 8009026:	4658      	mov	r0, fp
 8009028:	f7fe fd96 	bl	8007b58 <__aeabi_fmul>
 800902c:	4621      	mov	r1, r4
 800902e:	f7fe fc89 	bl	8007944 <__aeabi_fsub>
 8009032:	4682      	mov	sl, r0
 8009034:	4648      	mov	r0, r9
 8009036:	e78b      	b.n	8008f50 <__ieee754_rem_pio2f+0x1e8>
 8009038:	f7fe fc86 	bl	8007948 <__addsf3>
 800903c:	f44f 637d 	mov.w	r3, #4048	; 0xfd0
 8009040:	f024 040f 	bic.w	r4, r4, #15
 8009044:	f6c3 73c9 	movt	r3, #16329	; 0x3fc9
 8009048:	429c      	cmp	r4, r3
 800904a:	4606      	mov	r6, r0
 800904c:	d014      	beq.n	8009078 <__ieee754_rem_pio2f+0x310>
 800904e:	f244 4143 	movw	r1, #17475	; 0x4443
 8009052:	f04f 37ff 	mov.w	r7, #4294967295
 8009056:	f2c3 7135 	movt	r1, #14133	; 0x3735
 800905a:	f7fe fc75 	bl	8007948 <__addsf3>
 800905e:	4601      	mov	r1, r0
 8009060:	6028      	str	r0, [r5, #0]
 8009062:	4630      	mov	r0, r6
 8009064:	f7fe fc6e 	bl	8007944 <__aeabi_fsub>
 8009068:	f244 4143 	movw	r1, #17475	; 0x4443
 800906c:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8009070:	f7fe fc6a 	bl	8007948 <__addsf3>
 8009074:	6068      	str	r0, [r5, #4]
 8009076:	e711      	b.n	8008e9c <__ieee754_rem_pio2f+0x134>
 8009078:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 800907c:	f04f 37ff 	mov.w	r7, #4294967295
 8009080:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8009084:	f7fe fc60 	bl	8007948 <__addsf3>
 8009088:	f24a 3108 	movw	r1, #41736	; 0xa308
 800908c:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8009090:	4604      	mov	r4, r0
 8009092:	f7fe fc59 	bl	8007948 <__addsf3>
 8009096:	4601      	mov	r1, r0
 8009098:	6028      	str	r0, [r5, #0]
 800909a:	4620      	mov	r0, r4
 800909c:	f7fe fc52 	bl	8007944 <__aeabi_fsub>
 80090a0:	f24a 3108 	movw	r1, #41736	; 0xa308
 80090a4:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 80090a8:	f7fe fc4e 	bl	8007948 <__addsf3>
 80090ac:	6068      	str	r0, [r5, #4]
 80090ae:	e6f5      	b.n	8008e9c <__ieee754_rem_pio2f+0x134>
 80090b0:	0800a8ec 	.word	0x0800a8ec

080090b4 <__ieee754_sqrtf>:
 80090b4:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 80090b8:	4603      	mov	r3, r0
 80090ba:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 80090be:	b570      	push	{r4, r5, r6, lr}
 80090c0:	4604      	mov	r4, r0
 80090c2:	d237      	bcs.n	8009134 <__ieee754_sqrtf+0x80>
 80090c4:	b3a2      	cbz	r2, 8009130 <__ieee754_sqrtf+0x7c>
 80090c6:	2800      	cmp	r0, #0
 80090c8:	db3e      	blt.n	8009148 <__ieee754_sqrtf+0x94>
 80090ca:	15c4      	asrs	r4, r0, #23
 80090cc:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 80090d0:	d209      	bcs.n	80090e6 <__ieee754_sqrtf+0x32>
 80090d2:	f410 0200 	ands.w	r2, r0, #8388608	; 0x800000
 80090d6:	d13f      	bne.n	8009158 <__ieee754_sqrtf+0xa4>
 80090d8:	005b      	lsls	r3, r3, #1
 80090da:	3201      	adds	r2, #1
 80090dc:	0219      	lsls	r1, r3, #8
 80090de:	d5fb      	bpl.n	80090d8 <__ieee754_sqrtf+0x24>
 80090e0:	f1c2 0201 	rsb	r2, r2, #1
 80090e4:	18a4      	adds	r4, r4, r2
 80090e6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80090ea:	3c7f      	subs	r4, #127	; 0x7f
 80090ec:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 80090f0:	07e2      	lsls	r2, r4, #31
 80090f2:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80090f6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80090fa:	bf48      	it	mi
 80090fc:	005b      	lslmi	r3, r3, #1
 80090fe:	2600      	movs	r6, #0
 8009100:	1060      	asrs	r0, r4, #1
 8009102:	2119      	movs	r1, #25
 8009104:	005b      	lsls	r3, r3, #1
 8009106:	4635      	mov	r5, r6
 8009108:	18ac      	adds	r4, r5, r2
 800910a:	429c      	cmp	r4, r3
 800910c:	bfde      	ittt	le
 800910e:	ebc4 0303 	rsble	r3, r4, r3
 8009112:	18a5      	addle	r5, r4, r2
 8009114:	18b6      	addle	r6, r6, r2
 8009116:	0852      	lsrs	r2, r2, #1
 8009118:	005b      	lsls	r3, r3, #1
 800911a:	3901      	subs	r1, #1
 800911c:	d1f4      	bne.n	8009108 <__ieee754_sqrtf+0x54>
 800911e:	b113      	cbz	r3, 8009126 <__ieee754_sqrtf+0x72>
 8009120:	f006 0301 	and.w	r3, r6, #1
 8009124:	18f6      	adds	r6, r6, r3
 8009126:	1076      	asrs	r6, r6, #1
 8009128:	f106 567c 	add.w	r6, r6, #1056964608	; 0x3f000000
 800912c:	eb06 54c0 	add.w	r4, r6, r0, lsl #23
 8009130:	4620      	mov	r0, r4
 8009132:	bd70      	pop	{r4, r5, r6, pc}
 8009134:	4601      	mov	r1, r0
 8009136:	f7fe fd0f 	bl	8007b58 <__aeabi_fmul>
 800913a:	4601      	mov	r1, r0
 800913c:	4620      	mov	r0, r4
 800913e:	f7fe fc03 	bl	8007948 <__addsf3>
 8009142:	4604      	mov	r4, r0
 8009144:	4620      	mov	r0, r4
 8009146:	bd70      	pop	{r4, r5, r6, pc}
 8009148:	4601      	mov	r1, r0
 800914a:	f7fe fbfb 	bl	8007944 <__aeabi_fsub>
 800914e:	4601      	mov	r1, r0
 8009150:	f7fe fdb6 	bl	8007cc0 <__aeabi_fdiv>
 8009154:	4604      	mov	r4, r0
 8009156:	e7eb      	b.n	8009130 <__ieee754_sqrtf+0x7c>
 8009158:	2201      	movs	r2, #1
 800915a:	e7c3      	b.n	80090e4 <__ieee754_sqrtf+0x30>

0800915c <__kernel_cosf>:
 800915c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009160:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8009164:	f1b6 5f48 	cmp.w	r6, #838860800	; 0x32000000
 8009168:	4605      	mov	r5, r0
 800916a:	460f      	mov	r7, r1
 800916c:	da5b      	bge.n	8009226 <__kernel_cosf+0xca>
 800916e:	f7fe feb9 	bl	8007ee4 <__aeabi_f2iz>
 8009172:	2800      	cmp	r0, #0
 8009174:	f000 80ca 	beq.w	800930c <__kernel_cosf+0x1b0>
 8009178:	4629      	mov	r1, r5
 800917a:	4628      	mov	r0, r5
 800917c:	f7fe fcec 	bl	8007b58 <__aeabi_fmul>
 8009180:	f24d 714e 	movw	r1, #55118	; 0xd74e
 8009184:	f6ca 5147 	movt	r1, #44359	; 0xad47
 8009188:	4604      	mov	r4, r0
 800918a:	f7fe fce5 	bl	8007b58 <__aeabi_fmul>
 800918e:	f247 41f6 	movw	r1, #29942	; 0x74f6
 8009192:	f2c3 110f 	movt	r1, #12559	; 0x310f
 8009196:	f7fe fbd7 	bl	8007948 <__addsf3>
 800919a:	4621      	mov	r1, r4
 800919c:	f7fe fcdc 	bl	8007b58 <__aeabi_fmul>
 80091a0:	f24f 217c 	movw	r1, #62076	; 0xf27c
 80091a4:	f2c3 4193 	movt	r1, #13459	; 0x3493
 80091a8:	f7fe fbcc 	bl	8007944 <__aeabi_fsub>
 80091ac:	4621      	mov	r1, r4
 80091ae:	f7fe fcd3 	bl	8007b58 <__aeabi_fmul>
 80091b2:	f640 5101 	movw	r1, #3329	; 0xd01
 80091b6:	f2c3 71d0 	movt	r1, #14288	; 0x37d0
 80091ba:	f7fe fbc5 	bl	8007948 <__addsf3>
 80091be:	4621      	mov	r1, r4
 80091c0:	f7fe fcca 	bl	8007b58 <__aeabi_fmul>
 80091c4:	f640 3161 	movw	r1, #2913	; 0xb61
 80091c8:	f6c3 21b6 	movt	r1, #15030	; 0x3ab6
 80091cc:	f7fe fbba 	bl	8007944 <__aeabi_fsub>
 80091d0:	4621      	mov	r1, r4
 80091d2:	f7fe fcc1 	bl	8007b58 <__aeabi_fmul>
 80091d6:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 80091da:	f6c3 512a 	movt	r1, #15658	; 0x3d2a
 80091de:	f7fe fbb3 	bl	8007948 <__addsf3>
 80091e2:	4621      	mov	r1, r4
 80091e4:	f7fe fcb8 	bl	8007b58 <__aeabi_fmul>
 80091e8:	4680      	mov	r8, r0
 80091ea:	4620      	mov	r0, r4
 80091ec:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80091f0:	f7fe fcb2 	bl	8007b58 <__aeabi_fmul>
 80091f4:	4641      	mov	r1, r8
 80091f6:	4606      	mov	r6, r0
 80091f8:	4620      	mov	r0, r4
 80091fa:	f7fe fcad 	bl	8007b58 <__aeabi_fmul>
 80091fe:	4639      	mov	r1, r7
 8009200:	4604      	mov	r4, r0
 8009202:	4628      	mov	r0, r5
 8009204:	f7fe fca8 	bl	8007b58 <__aeabi_fmul>
 8009208:	4601      	mov	r1, r0
 800920a:	4620      	mov	r0, r4
 800920c:	f7fe fb9a 	bl	8007944 <__aeabi_fsub>
 8009210:	4601      	mov	r1, r0
 8009212:	4630      	mov	r0, r6
 8009214:	f7fe fb96 	bl	8007944 <__aeabi_fsub>
 8009218:	4601      	mov	r1, r0
 800921a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800921e:	f7fe fb91 	bl	8007944 <__aeabi_fsub>
 8009222:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009226:	4601      	mov	r1, r0
 8009228:	f7fe fc96 	bl	8007b58 <__aeabi_fmul>
 800922c:	f24d 714e 	movw	r1, #55118	; 0xd74e
 8009230:	f6ca 5147 	movt	r1, #44359	; 0xad47
 8009234:	4604      	mov	r4, r0
 8009236:	f7fe fc8f 	bl	8007b58 <__aeabi_fmul>
 800923a:	f247 41f6 	movw	r1, #29942	; 0x74f6
 800923e:	f2c3 110f 	movt	r1, #12559	; 0x310f
 8009242:	f7fe fb81 	bl	8007948 <__addsf3>
 8009246:	4621      	mov	r1, r4
 8009248:	f7fe fc86 	bl	8007b58 <__aeabi_fmul>
 800924c:	f24f 217c 	movw	r1, #62076	; 0xf27c
 8009250:	f2c3 4193 	movt	r1, #13459	; 0x3493
 8009254:	f7fe fb76 	bl	8007944 <__aeabi_fsub>
 8009258:	4621      	mov	r1, r4
 800925a:	f7fe fc7d 	bl	8007b58 <__aeabi_fmul>
 800925e:	f640 5101 	movw	r1, #3329	; 0xd01
 8009262:	f2c3 71d0 	movt	r1, #14288	; 0x37d0
 8009266:	f7fe fb6f 	bl	8007948 <__addsf3>
 800926a:	4621      	mov	r1, r4
 800926c:	f7fe fc74 	bl	8007b58 <__aeabi_fmul>
 8009270:	f640 3161 	movw	r1, #2913	; 0xb61
 8009274:	f6c3 21b6 	movt	r1, #15030	; 0x3ab6
 8009278:	f7fe fb64 	bl	8007944 <__aeabi_fsub>
 800927c:	4621      	mov	r1, r4
 800927e:	f7fe fc6b 	bl	8007b58 <__aeabi_fmul>
 8009282:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8009286:	f6c3 512a 	movt	r1, #15658	; 0x3d2a
 800928a:	f7fe fb5d 	bl	8007948 <__addsf3>
 800928e:	4621      	mov	r1, r4
 8009290:	f7fe fc62 	bl	8007b58 <__aeabi_fmul>
 8009294:	f649 1399 	movw	r3, #39321	; 0x9999
 8009298:	f6c3 6399 	movt	r3, #16025	; 0x3e99
 800929c:	429e      	cmp	r6, r3
 800929e:	4680      	mov	r8, r0
 80092a0:	dda3      	ble.n	80091ea <__kernel_cosf+0x8e>
 80092a2:	2300      	movs	r3, #0
 80092a4:	f6c3 7348 	movt	r3, #16200	; 0x3f48
 80092a8:	429e      	cmp	r6, r3
 80092aa:	dc27      	bgt.n	80092fc <__kernel_cosf+0x1a0>
 80092ac:	f106 467f 	add.w	r6, r6, #4278190080	; 0xff000000
 80092b0:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80092b4:	4631      	mov	r1, r6
 80092b6:	f7fe fb45 	bl	8007944 <__aeabi_fsub>
 80092ba:	4681      	mov	r9, r0
 80092bc:	4620      	mov	r0, r4
 80092be:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80092c2:	f7fe fc49 	bl	8007b58 <__aeabi_fmul>
 80092c6:	4631      	mov	r1, r6
 80092c8:	f7fe fb3c 	bl	8007944 <__aeabi_fsub>
 80092cc:	4641      	mov	r1, r8
 80092ce:	4606      	mov	r6, r0
 80092d0:	4620      	mov	r0, r4
 80092d2:	f7fe fc41 	bl	8007b58 <__aeabi_fmul>
 80092d6:	4639      	mov	r1, r7
 80092d8:	4604      	mov	r4, r0
 80092da:	4628      	mov	r0, r5
 80092dc:	f7fe fc3c 	bl	8007b58 <__aeabi_fmul>
 80092e0:	4601      	mov	r1, r0
 80092e2:	4620      	mov	r0, r4
 80092e4:	f7fe fb2e 	bl	8007944 <__aeabi_fsub>
 80092e8:	4601      	mov	r1, r0
 80092ea:	4630      	mov	r0, r6
 80092ec:	f7fe fb2a 	bl	8007944 <__aeabi_fsub>
 80092f0:	4601      	mov	r1, r0
 80092f2:	4648      	mov	r0, r9
 80092f4:	f7fe fb26 	bl	8007944 <__aeabi_fsub>
 80092f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80092fc:	f04f 0900 	mov.w	r9, #0
 8009300:	2600      	movs	r6, #0
 8009302:	f6c3 7938 	movt	r9, #16184	; 0x3f38
 8009306:	f6c3 6690 	movt	r6, #16016	; 0x3e90
 800930a:	e7d7      	b.n	80092bc <__kernel_cosf+0x160>
 800930c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8009310:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08009314 <__kernel_rem_pio2f>:
 8009314:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009318:	b0df      	sub	sp, #380	; 0x17c
 800931a:	1d15      	adds	r5, r2, #4
 800931c:	1ed4      	subs	r4, r2, #3
 800931e:	bf58      	it	pl
 8009320:	4625      	movpl	r5, r4
 8009322:	930b      	str	r3, [sp, #44]	; 0x2c
 8009324:	f64a 4404 	movw	r4, #44036	; 0xac04
 8009328:	3b01      	subs	r3, #1
 800932a:	9303      	str	r3, [sp, #12]
 800932c:	f6c0 0400 	movt	r4, #2048	; 0x800
 8009330:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
 8009332:	10ed      	asrs	r5, r5, #3
 8009334:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
 8009338:	950c      	str	r5, [sp, #48]	; 0x30
 800933a:	4606      	mov	r6, r0
 800933c:	9109      	str	r1, [sp, #36]	; 0x24
 800933e:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 8009342:	43eb      	mvns	r3, r5
 8009344:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8009348:	9307      	str	r3, [sp, #28]
 800934a:	9408      	str	r4, [sp, #32]
 800934c:	9a08      	ldr	r2, [sp, #32]
 800934e:	9c03      	ldr	r4, [sp, #12]
 8009350:	1b2f      	subs	r7, r5, r4
 8009352:	18a5      	adds	r5, r4, r2
 8009354:	d415      	bmi.n	8009382 <__kernel_rem_pio2f+0x6e>
 8009356:	9b69      	ldr	r3, [sp, #420]	; 0x1a4
 8009358:	197d      	adds	r5, r7, r5
 800935a:	3501      	adds	r5, #1
 800935c:	f04f 0800 	mov.w	r8, #0
 8009360:	eb03 0987 	add.w	r9, r3, r7, lsl #2
 8009364:	ac22      	add	r4, sp, #136	; 0x88
 8009366:	2000      	movs	r0, #0
 8009368:	2f00      	cmp	r7, #0
 800936a:	db03      	blt.n	8009374 <__kernel_rem_pio2f+0x60>
 800936c:	f859 0008 	ldr.w	r0, [r9, r8]
 8009370:	f7fe fb9e 	bl	8007ab0 <__aeabi_i2f>
 8009374:	3701      	adds	r7, #1
 8009376:	f844 0008 	str.w	r0, [r4, r8]
 800937a:	42af      	cmp	r7, r5
 800937c:	f108 0804 	add.w	r8, r8, #4
 8009380:	d1f1      	bne.n	8009366 <__kernel_rem_pio2f+0x52>
 8009382:	9b08      	ldr	r3, [sp, #32]
 8009384:	2b00      	cmp	r3, #0
 8009386:	f2c0 82de 	blt.w	8009946 <__kernel_rem_pio2f+0x632>
 800938a:	9b08      	ldr	r3, [sp, #32]
 800938c:	a84a      	add	r0, sp, #296	; 0x128
 800938e:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8009390:	ad49      	add	r5, sp, #292	; 0x124
 8009392:	009b      	lsls	r3, r3, #2
 8009394:	9302      	str	r3, [sp, #8]
 8009396:	18c7      	adds	r7, r0, r3
 8009398:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 800939c:	9a03      	ldr	r2, [sp, #12]
 800939e:	2a00      	cmp	r2, #0
 80093a0:	f2c0 8208 	blt.w	80097b4 <__kernel_rem_pio2f+0x4a0>
 80093a4:	ab22      	add	r3, sp, #136	; 0x88
 80093a6:	f04f 0800 	mov.w	r8, #0
 80093aa:	eb03 0a84 	add.w	sl, r3, r4, lsl #2
 80093ae:	f04f 0900 	mov.w	r9, #0
 80093b2:	f856 0008 	ldr.w	r0, [r6, r8]
 80093b6:	f108 0804 	add.w	r8, r8, #4
 80093ba:	f85a 1d04 	ldr.w	r1, [sl, #-4]!
 80093be:	f7fe fbcb 	bl	8007b58 <__aeabi_fmul>
 80093c2:	4601      	mov	r1, r0
 80093c4:	4648      	mov	r0, r9
 80093c6:	f7fe fabf 	bl	8007948 <__addsf3>
 80093ca:	45d8      	cmp	r8, fp
 80093cc:	4681      	mov	r9, r0
 80093ce:	d1f0      	bne.n	80093b2 <__kernel_rem_pio2f+0x9e>
 80093d0:	f845 9f04 	str.w	r9, [r5, #4]!
 80093d4:	3401      	adds	r4, #1
 80093d6:	42bd      	cmp	r5, r7
 80093d8:	d1e0      	bne.n	800939c <__kernel_rem_pio2f+0x88>
 80093da:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80093de:	ac0e      	add	r4, sp, #56	; 0x38
 80093e0:	9a02      	ldr	r2, [sp, #8]
 80093e2:	18a4      	adds	r4, r4, r2
 80093e4:	940d      	str	r4, [sp, #52]	; 0x34
 80093e6:	ea4f 0488 	mov.w	r4, r8, lsl #2
 80093ea:	a85e      	add	r0, sp, #376	; 0x178
 80093ec:	1903      	adds	r3, r0, r4
 80093ee:	f1b8 0f00 	cmp.w	r8, #0
 80093f2:	9402      	str	r4, [sp, #8]
 80093f4:	f853 ac50 	ldr.w	sl, [r3, #-80]
 80093f8:	dd22      	ble.n	8009440 <__kernel_rem_pio2f+0x12c>
 80093fa:	9a02      	ldr	r2, [sp, #8]
 80093fc:	ac0d      	add	r4, sp, #52	; 0x34
 80093fe:	ab4a      	add	r3, sp, #296	; 0x128
 8009400:	189d      	adds	r5, r3, r2
 8009402:	18a7      	adds	r7, r4, r2
 8009404:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 8009408:	4650      	mov	r0, sl
 800940a:	f7fe fba5 	bl	8007b58 <__aeabi_fmul>
 800940e:	f7fe fd69 	bl	8007ee4 <__aeabi_f2iz>
 8009412:	f7fe fb4d 	bl	8007ab0 <__aeabi_i2f>
 8009416:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 800941a:	4681      	mov	r9, r0
 800941c:	f7fe fb9c 	bl	8007b58 <__aeabi_fmul>
 8009420:	4601      	mov	r1, r0
 8009422:	4650      	mov	r0, sl
 8009424:	f7fe fa8e 	bl	8007944 <__aeabi_fsub>
 8009428:	f7fe fd5c 	bl	8007ee4 <__aeabi_f2iz>
 800942c:	4649      	mov	r1, r9
 800942e:	f844 0f04 	str.w	r0, [r4, #4]!
 8009432:	f855 0d04 	ldr.w	r0, [r5, #-4]!
 8009436:	f7fe fa87 	bl	8007948 <__addsf3>
 800943a:	42bc      	cmp	r4, r7
 800943c:	4682      	mov	sl, r0
 800943e:	d1e1      	bne.n	8009404 <__kernel_rem_pio2f+0xf0>
 8009440:	9907      	ldr	r1, [sp, #28]
 8009442:	4650      	mov	r0, sl
 8009444:	f000 fe64 	bl	800a110 <scalbnf>
 8009448:	f04f 5178 	mov.w	r1, #1040187392	; 0x3e000000
 800944c:	4604      	mov	r4, r0
 800944e:	f7fe fb83 	bl	8007b58 <__aeabi_fmul>
 8009452:	f000 fdfb 	bl	800a04c <floorf>
 8009456:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
 800945a:	f7fe fb7d 	bl	8007b58 <__aeabi_fmul>
 800945e:	4601      	mov	r1, r0
 8009460:	4620      	mov	r0, r4
 8009462:	f7fe fa6f 	bl	8007944 <__aeabi_fsub>
 8009466:	4604      	mov	r4, r0
 8009468:	f7fe fd3c 	bl	8007ee4 <__aeabi_f2iz>
 800946c:	4605      	mov	r5, r0
 800946e:	f7fe fb1f 	bl	8007ab0 <__aeabi_i2f>
 8009472:	4601      	mov	r1, r0
 8009474:	4620      	mov	r0, r4
 8009476:	f7fe fa65 	bl	8007944 <__aeabi_fsub>
 800947a:	9a07      	ldr	r2, [sp, #28]
 800947c:	2a00      	cmp	r2, #0
 800947e:	4607      	mov	r7, r0
 8009480:	f340 8173 	ble.w	800976a <__kernel_rem_pio2f+0x456>
 8009484:	9b07      	ldr	r3, [sp, #28]
 8009486:	f108 32ff 	add.w	r2, r8, #4294967295
 800948a:	ac0e      	add	r4, sp, #56	; 0x38
 800948c:	f1c3 0108 	rsb	r1, r3, #8
 8009490:	f1c3 0007 	rsb	r0, r3, #7
 8009494:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
 8009498:	fa43 f401 	asr.w	r4, r3, r1
 800949c:	192d      	adds	r5, r5, r4
 800949e:	fa04 f101 	lsl.w	r1, r4, r1
 80094a2:	1a5b      	subs	r3, r3, r1
 80094a4:	a90e      	add	r1, sp, #56	; 0x38
 80094a6:	fa43 fa00 	asr.w	sl, r3, r0
 80094aa:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 80094ae:	f1ba 0f00 	cmp.w	sl, #0
 80094b2:	dd30      	ble.n	8009516 <__kernel_rem_pio2f+0x202>
 80094b4:	3501      	adds	r5, #1
 80094b6:	f1b8 0f00 	cmp.w	r8, #0
 80094ba:	f340 8179 	ble.w	80097b0 <__kernel_rem_pio2f+0x49c>
 80094be:	9c02      	ldr	r4, [sp, #8]
 80094c0:	ab0e      	add	r3, sp, #56	; 0x38
 80094c2:	1919      	adds	r1, r3, r4
 80094c4:	2400      	movs	r4, #0
 80094c6:	e007      	b.n	80094d8 <__kernel_rem_pio2f+0x1c4>
 80094c8:	b122      	cbz	r2, 80094d4 <__kernel_rem_pio2f+0x1c0>
 80094ca:	2401      	movs	r4, #1
 80094cc:	f5c2 7280 	rsb	r2, r2, #256	; 0x100
 80094d0:	f843 2c04 	str.w	r2, [r3, #-4]
 80094d4:	428b      	cmp	r3, r1
 80094d6:	d00a      	beq.n	80094ee <__kernel_rem_pio2f+0x1da>
 80094d8:	f853 2b04 	ldr.w	r2, [r3], #4
 80094dc:	2c00      	cmp	r4, #0
 80094de:	d0f3      	beq.n	80094c8 <__kernel_rem_pio2f+0x1b4>
 80094e0:	2401      	movs	r4, #1
 80094e2:	428b      	cmp	r3, r1
 80094e4:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 80094e8:	f843 2c04 	str.w	r2, [r3, #-4]
 80094ec:	d1f4      	bne.n	80094d8 <__kernel_rem_pio2f+0x1c4>
 80094ee:	9a07      	ldr	r2, [sp, #28]
 80094f0:	2a00      	cmp	r2, #0
 80094f2:	dd0d      	ble.n	8009510 <__kernel_rem_pio2f+0x1fc>
 80094f4:	2a01      	cmp	r2, #1
 80094f6:	f000 8141 	beq.w	800977c <__kernel_rem_pio2f+0x468>
 80094fa:	2a02      	cmp	r2, #2
 80094fc:	d108      	bne.n	8009510 <__kernel_rem_pio2f+0x1fc>
 80094fe:	f108 33ff 	add.w	r3, r8, #4294967295
 8009502:	a90e      	add	r1, sp, #56	; 0x38
 8009504:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 8009508:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 800950c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8009510:	f1ba 0f02 	cmp.w	sl, #2
 8009514:	d078      	beq.n	8009608 <__kernel_rem_pio2f+0x2f4>
 8009516:	4638      	mov	r0, r7
 8009518:	2100      	movs	r1, #0
 800951a:	f7fe fcb1 	bl	8007e80 <__aeabi_fcmpeq>
 800951e:	2800      	cmp	r0, #0
 8009520:	f000 808c 	beq.w	800963c <__kernel_rem_pio2f+0x328>
 8009524:	9a08      	ldr	r2, [sp, #32]
 8009526:	f108 30ff 	add.w	r0, r8, #4294967295
 800952a:	4282      	cmp	r2, r0
 800952c:	dc0d      	bgt.n	800954a <__kernel_rem_pio2f+0x236>
 800952e:	9c02      	ldr	r4, [sp, #8]
 8009530:	a90e      	add	r1, sp, #56	; 0x38
 8009532:	2200      	movs	r2, #0
 8009534:	190b      	adds	r3, r1, r4
 8009536:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8009538:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 800953c:	42a3      	cmp	r3, r4
 800953e:	ea42 0201 	orr.w	r2, r2, r1
 8009542:	d1f9      	bne.n	8009538 <__kernel_rem_pio2f+0x224>
 8009544:	2a00      	cmp	r2, #0
 8009546:	f040 81e7 	bne.w	8009918 <__kernel_rem_pio2f+0x604>
 800954a:	9b08      	ldr	r3, [sp, #32]
 800954c:	ac0e      	add	r4, sp, #56	; 0x38
 800954e:	1e5a      	subs	r2, r3, #1
 8009550:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
 8009554:	2b00      	cmp	r3, #0
 8009556:	f040 81f4 	bne.w	8009942 <__kernel_rem_pio2f+0x62e>
 800955a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800955e:	2301      	movs	r3, #1
 8009560:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 8009564:	3301      	adds	r3, #1
 8009566:	2900      	cmp	r1, #0
 8009568:	d0fa      	beq.n	8009560 <__kernel_rem_pio2f+0x24c>
 800956a:	4443      	add	r3, r8
 800956c:	f108 0201 	add.w	r2, r8, #1
 8009570:	429a      	cmp	r2, r3
 8009572:	930a      	str	r3, [sp, #40]	; 0x28
 8009574:	dc45      	bgt.n	8009602 <__kernel_rem_pio2f+0x2ee>
 8009576:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8009578:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800957a:	ebc8 0a04 	rsb	sl, r8, r4
 800957e:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8009580:	eb08 0103 	add.w	r1, r8, r3
 8009584:	9802      	ldr	r0, [sp, #8]
 8009586:	eb04 0308 	add.w	r3, r4, r8
 800958a:	9c03      	ldr	r4, [sp, #12]
 800958c:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8009590:	f8cd a014 	str.w	sl, [sp, #20]
 8009594:	18a2      	adds	r2, r4, r2
 8009596:	ac22      	add	r4, sp, #136	; 0x88
 8009598:	9406      	str	r4, [sp, #24]
 800959a:	1c55      	adds	r5, r2, #1
 800959c:	9c69      	ldr	r4, [sp, #420]	; 0x1a4
 800959e:	9a06      	ldr	r2, [sp, #24]
 80095a0:	eb04 0881 	add.w	r8, r4, r1, lsl #2
 80095a4:	ac4a      	add	r4, sp, #296	; 0x128
 80095a6:	1824      	adds	r4, r4, r0
 80095a8:	9402      	str	r4, [sp, #8]
 80095aa:	2400      	movs	r4, #0
 80095ac:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80095b0:	9304      	str	r3, [sp, #16]
 80095b2:	f858 0f04 	ldr.w	r0, [r8, #4]!
 80095b6:	f04f 0900 	mov.w	r9, #0
 80095ba:	f7fe fa79 	bl	8007ab0 <__aeabi_i2f>
 80095be:	9a03      	ldr	r2, [sp, #12]
 80095c0:	9b04      	ldr	r3, [sp, #16]
 80095c2:	2a00      	cmp	r2, #0
 80095c4:	5118      	str	r0, [r3, r4]
 80095c6:	db13      	blt.n	80095f0 <__kernel_rem_pio2f+0x2dc>
 80095c8:	9b06      	ldr	r3, [sp, #24]
 80095ca:	f04f 0a00 	mov.w	sl, #0
 80095ce:	eb03 0785 	add.w	r7, r3, r5, lsl #2
 80095d2:	f856 000a 	ldr.w	r0, [r6, sl]
 80095d6:	f10a 0a04 	add.w	sl, sl, #4
 80095da:	f857 1d04 	ldr.w	r1, [r7, #-4]!
 80095de:	f7fe fabb 	bl	8007b58 <__aeabi_fmul>
 80095e2:	4601      	mov	r1, r0
 80095e4:	4648      	mov	r0, r9
 80095e6:	f7fe f9af 	bl	8007948 <__addsf3>
 80095ea:	45da      	cmp	sl, fp
 80095ec:	4681      	mov	r9, r0
 80095ee:	d1f0      	bne.n	80095d2 <__kernel_rem_pio2f+0x2be>
 80095f0:	9b05      	ldr	r3, [sp, #20]
 80095f2:	3404      	adds	r4, #4
 80095f4:	9a02      	ldr	r2, [sp, #8]
 80095f6:	3501      	adds	r5, #1
 80095f8:	429c      	cmp	r4, r3
 80095fa:	f842 9f04 	str.w	r9, [r2, #4]!
 80095fe:	9202      	str	r2, [sp, #8]
 8009600:	d1d7      	bne.n	80095b2 <__kernel_rem_pio2f+0x29e>
 8009602:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 8009606:	e6ee      	b.n	80093e6 <__kernel_rem_pio2f+0xd2>
 8009608:	4639      	mov	r1, r7
 800960a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800960e:	f7fe f999 	bl	8007944 <__aeabi_fsub>
 8009612:	4607      	mov	r7, r0
 8009614:	2c00      	cmp	r4, #0
 8009616:	f43f af7e 	beq.w	8009516 <__kernel_rem_pio2f+0x202>
 800961a:	9907      	ldr	r1, [sp, #28]
 800961c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8009620:	f000 fd76 	bl	800a110 <scalbnf>
 8009624:	4601      	mov	r1, r0
 8009626:	4638      	mov	r0, r7
 8009628:	f7fe f98c 	bl	8007944 <__aeabi_fsub>
 800962c:	2100      	movs	r1, #0
 800962e:	4607      	mov	r7, r0
 8009630:	4638      	mov	r0, r7
 8009632:	f7fe fc25 	bl	8007e80 <__aeabi_fcmpeq>
 8009636:	2800      	cmp	r0, #0
 8009638:	f47f af74 	bne.w	8009524 <__kernel_rem_pio2f+0x210>
 800963c:	9b07      	ldr	r3, [sp, #28]
 800963e:	4638      	mov	r0, r7
 8009640:	9502      	str	r5, [sp, #8]
 8009642:	4654      	mov	r4, sl
 8009644:	4259      	negs	r1, r3
 8009646:	f000 fd63 	bl	800a110 <scalbnf>
 800964a:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 800964e:	4605      	mov	r5, r0
 8009650:	f7fe fc34 	bl	8007ebc <__aeabi_fcmpge>
 8009654:	2800      	cmp	r0, #0
 8009656:	f000 817c 	beq.w	8009952 <__kernel_rem_pio2f+0x63e>
 800965a:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 800965e:	4628      	mov	r0, r5
 8009660:	f7fe fa7a 	bl	8007b58 <__aeabi_fmul>
 8009664:	9a07      	ldr	r2, [sp, #28]
 8009666:	3208      	adds	r2, #8
 8009668:	9207      	str	r2, [sp, #28]
 800966a:	f7fe fc3b 	bl	8007ee4 <__aeabi_f2iz>
 800966e:	f7fe fa1f 	bl	8007ab0 <__aeabi_i2f>
 8009672:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8009676:	4606      	mov	r6, r0
 8009678:	f7fe fa6e 	bl	8007b58 <__aeabi_fmul>
 800967c:	4601      	mov	r1, r0
 800967e:	4628      	mov	r0, r5
 8009680:	f7fe f960 	bl	8007944 <__aeabi_fsub>
 8009684:	f7fe fc2e 	bl	8007ee4 <__aeabi_f2iz>
 8009688:	ab0e      	add	r3, sp, #56	; 0x38
 800968a:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
 800968e:	4630      	mov	r0, r6
 8009690:	f7fe fc28 	bl	8007ee4 <__aeabi_f2iz>
 8009694:	f108 0801 	add.w	r8, r8, #1
 8009698:	a90e      	add	r1, sp, #56	; 0x38
 800969a:	f841 0028 	str.w	r0, [r1, r8, lsl #2]
 800969e:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80096a2:	9907      	ldr	r1, [sp, #28]
 80096a4:	f000 fd34 	bl	800a110 <scalbnf>
 80096a8:	f1b8 0f00 	cmp.w	r8, #0
 80096ac:	4605      	mov	r5, r0
 80096ae:	db53      	blt.n	8009758 <__kernel_rem_pio2f+0x444>
 80096b0:	ebc8 7788 	rsb	r7, r8, r8, lsl #30
 80096b4:	ea4f 0688 	mov.w	r6, r8, lsl #2
 80096b8:	ab0e      	add	r3, sp, #56	; 0x38
 80096ba:	a84a      	add	r0, sp, #296	; 0x128
 80096bc:	00bf      	lsls	r7, r7, #2
 80096be:	eb03 0906 	add.w	r9, r3, r6
 80096c2:	3f04      	subs	r7, #4
 80096c4:	1986      	adds	r6, r0, r6
 80096c6:	f04f 0b00 	mov.w	fp, #0
 80096ca:	f859 000b 	ldr.w	r0, [r9, fp]
 80096ce:	f7fe f9ef 	bl	8007ab0 <__aeabi_i2f>
 80096d2:	4629      	mov	r1, r5
 80096d4:	f7fe fa40 	bl	8007b58 <__aeabi_fmul>
 80096d8:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 80096dc:	f846 000b 	str.w	r0, [r6, fp]
 80096e0:	4628      	mov	r0, r5
 80096e2:	f7fe fa39 	bl	8007b58 <__aeabi_fmul>
 80096e6:	f1ab 0b04 	sub.w	fp, fp, #4
 80096ea:	45bb      	cmp	fp, r7
 80096ec:	4605      	mov	r5, r0
 80096ee:	d1ec      	bne.n	80096ca <__kernel_rem_pio2f+0x3b6>
 80096f0:	4f9d      	ldr	r7, [pc, #628]	; (8009968 <__kernel_rem_pio2f+0x654>)
 80096f2:	f108 0b01 	add.w	fp, r8, #1
 80096f6:	f8dd a020 	ldr.w	sl, [sp, #32]
 80096fa:	2500      	movs	r5, #0
 80096fc:	f8cd 800c 	str.w	r8, [sp, #12]
 8009700:	9404      	str	r4, [sp, #16]
 8009702:	f1ba 0f00 	cmp.w	sl, #0
 8009706:	f2c0 8105 	blt.w	8009914 <__kernel_rem_pio2f+0x600>
 800970a:	2d00      	cmp	r5, #0
 800970c:	f2c0 8102 	blt.w	8009914 <__kernel_rem_pio2f+0x600>
 8009710:	f04f 0900 	mov.w	r9, #0
 8009714:	2400      	movs	r4, #0
 8009716:	46c8      	mov	r8, r9
 8009718:	e001      	b.n	800971e <__kernel_rem_pio2f+0x40a>
 800971a:	45a8      	cmp	r8, r5
 800971c:	dc10      	bgt.n	8009740 <__kernel_rem_pio2f+0x42c>
 800971e:	f856 1009 	ldr.w	r1, [r6, r9]
 8009722:	f108 0801 	add.w	r8, r8, #1
 8009726:	f857 0009 	ldr.w	r0, [r7, r9]
 800972a:	f109 0904 	add.w	r9, r9, #4
 800972e:	f7fe fa13 	bl	8007b58 <__aeabi_fmul>
 8009732:	4601      	mov	r1, r0
 8009734:	4620      	mov	r0, r4
 8009736:	f7fe f907 	bl	8007948 <__addsf3>
 800973a:	45c2      	cmp	sl, r8
 800973c:	4604      	mov	r4, r0
 800973e:	daec      	bge.n	800971a <__kernel_rem_pio2f+0x406>
 8009740:	a95e      	add	r1, sp, #376	; 0x178
 8009742:	3e04      	subs	r6, #4
 8009744:	eb01 0385 	add.w	r3, r1, r5, lsl #2
 8009748:	3501      	adds	r5, #1
 800974a:	455d      	cmp	r5, fp
 800974c:	f843 4ca0 	str.w	r4, [r3, #-160]
 8009750:	d1d7      	bne.n	8009702 <__kernel_rem_pio2f+0x3ee>
 8009752:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8009756:	9c04      	ldr	r4, [sp, #16]
 8009758:	9a68      	ldr	r2, [sp, #416]	; 0x1a0
 800975a:	2a03      	cmp	r2, #3
 800975c:	d843      	bhi.n	80097e6 <__kernel_rem_pio2f+0x4d2>
 800975e:	e8df f012 	tbh	[pc, r2, lsl #1]
 8009762:	00c4      	.short	0x00c4
 8009764:	00980098 	.word	0x00980098
 8009768:	0048      	.short	0x0048
 800976a:	d111      	bne.n	8009790 <__kernel_rem_pio2f+0x47c>
 800976c:	f108 33ff 	add.w	r3, r8, #4294967295
 8009770:	aa0e      	add	r2, sp, #56	; 0x38
 8009772:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009776:	ea4f 2a23 	mov.w	sl, r3, asr #8
 800977a:	e698      	b.n	80094ae <__kernel_rem_pio2f+0x19a>
 800977c:	f108 33ff 	add.w	r3, r8, #4294967295
 8009780:	a80e      	add	r0, sp, #56	; 0x38
 8009782:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
 8009786:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800978a:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 800978e:	e6bf      	b.n	8009510 <__kernel_rem_pio2f+0x1fc>
 8009790:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8009794:	f04f 0a00 	mov.w	sl, #0
 8009798:	f7fe fb90 	bl	8007ebc <__aeabi_fcmpge>
 800979c:	2800      	cmp	r0, #0
 800979e:	f43f aeba 	beq.w	8009516 <__kernel_rem_pio2f+0x202>
 80097a2:	3501      	adds	r5, #1
 80097a4:	f1b8 0f00 	cmp.w	r8, #0
 80097a8:	f04f 0a02 	mov.w	sl, #2
 80097ac:	f73f ae87 	bgt.w	80094be <__kernel_rem_pio2f+0x1aa>
 80097b0:	2400      	movs	r4, #0
 80097b2:	e69c      	b.n	80094ee <__kernel_rem_pio2f+0x1da>
 80097b4:	f04f 0900 	mov.w	r9, #0
 80097b8:	3401      	adds	r4, #1
 80097ba:	f845 9f04 	str.w	r9, [r5, #4]!
 80097be:	42bd      	cmp	r5, r7
 80097c0:	f47f adec 	bne.w	800939c <__kernel_rem_pio2f+0x88>
 80097c4:	e609      	b.n	80093da <__kernel_rem_pio2f+0xc6>
 80097c6:	2000      	movs	r0, #0
 80097c8:	2c00      	cmp	r4, #0
 80097ca:	d05b      	beq.n	8009884 <__kernel_rem_pio2f+0x570>
 80097cc:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 80097ce:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80097d2:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80097d4:	f103 4200 	add.w	r2, r3, #2147483648	; 0x80000000
 80097d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80097da:	6098      	str	r0, [r3, #8]
 80097dc:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 80097de:	6022      	str	r2, [r4, #0]
 80097e0:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80097e4:	6063      	str	r3, [r4, #4]
 80097e6:	9a02      	ldr	r2, [sp, #8]
 80097e8:	f002 0007 	and.w	r0, r2, #7
 80097ec:	b05f      	add	sp, #380	; 0x17c
 80097ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80097f2:	f1b8 0f00 	cmp.w	r8, #0
 80097f6:	dde6      	ble.n	80097c6 <__kernel_rem_pio2f+0x4b2>
 80097f8:	f108 35ff 	add.w	r5, r8, #4294967295
 80097fc:	af36      	add	r7, sp, #216	; 0xd8
 80097fe:	aa35      	add	r2, sp, #212	; 0xd4
 8009800:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8009804:	462e      	mov	r6, r5
 8009806:	f856 b904 	ldr.w	fp, [r6], #-4
 800980a:	f8d6 a008 	ldr.w	sl, [r6, #8]
 800980e:	4658      	mov	r0, fp
 8009810:	9201      	str	r2, [sp, #4]
 8009812:	4651      	mov	r1, sl
 8009814:	f7fe f898 	bl	8007948 <__addsf3>
 8009818:	4681      	mov	r9, r0
 800981a:	4658      	mov	r0, fp
 800981c:	4649      	mov	r1, r9
 800981e:	f7fe f891 	bl	8007944 <__aeabi_fsub>
 8009822:	4601      	mov	r1, r0
 8009824:	4650      	mov	r0, sl
 8009826:	f7fe f88f 	bl	8007948 <__addsf3>
 800982a:	9a01      	ldr	r2, [sp, #4]
 800982c:	f8c6 9004 	str.w	r9, [r6, #4]
 8009830:	4296      	cmp	r6, r2
 8009832:	60b0      	str	r0, [r6, #8]
 8009834:	d1e7      	bne.n	8009806 <__kernel_rem_pio2f+0x4f2>
 8009836:	f1b8 0f01 	cmp.w	r8, #1
 800983a:	ddc4      	ble.n	80097c6 <__kernel_rem_pio2f+0x4b2>
 800983c:	f855 a904 	ldr.w	sl, [r5], #-4
 8009840:	f8d5 9008 	ldr.w	r9, [r5, #8]
 8009844:	4650      	mov	r0, sl
 8009846:	4649      	mov	r1, r9
 8009848:	f7fe f87e 	bl	8007948 <__addsf3>
 800984c:	4606      	mov	r6, r0
 800984e:	4650      	mov	r0, sl
 8009850:	4631      	mov	r1, r6
 8009852:	f7fe f877 	bl	8007944 <__aeabi_fsub>
 8009856:	4601      	mov	r1, r0
 8009858:	4648      	mov	r0, r9
 800985a:	f7fe f875 	bl	8007948 <__addsf3>
 800985e:	42bd      	cmp	r5, r7
 8009860:	606e      	str	r6, [r5, #4]
 8009862:	60a8      	str	r0, [r5, #8]
 8009864:	d1ea      	bne.n	800983c <__kernel_rem_pio2f+0x528>
 8009866:	f108 0801 	add.w	r8, r8, #1
 800986a:	f105 0608 	add.w	r6, r5, #8
 800986e:	2000      	movs	r0, #0
 8009870:	eb05 0588 	add.w	r5, r5, r8, lsl #2
 8009874:	f855 1d04 	ldr.w	r1, [r5, #-4]!
 8009878:	f7fe f866 	bl	8007948 <__addsf3>
 800987c:	42b5      	cmp	r5, r6
 800987e:	d1f9      	bne.n	8009874 <__kernel_rem_pio2f+0x560>
 8009880:	2c00      	cmp	r4, #0
 8009882:	d1a3      	bne.n	80097cc <__kernel_rem_pio2f+0x4b8>
 8009884:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8009886:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 8009888:	60a0      	str	r0, [r4, #8]
 800988a:	6023      	str	r3, [r4, #0]
 800988c:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 800988e:	6063      	str	r3, [r4, #4]
 8009890:	e7a9      	b.n	80097e6 <__kernel_rem_pio2f+0x4d2>
 8009892:	2000      	movs	r0, #0
 8009894:	f1b8 0f00 	cmp.w	r8, #0
 8009898:	db0b      	blt.n	80098b2 <__kernel_rem_pio2f+0x59e>
 800989a:	f108 0501 	add.w	r5, r8, #1
 800989e:	ae36      	add	r6, sp, #216	; 0xd8
 80098a0:	2000      	movs	r0, #0
 80098a2:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 80098a6:	f855 1d04 	ldr.w	r1, [r5, #-4]!
 80098aa:	f7fe f84d 	bl	8007948 <__addsf3>
 80098ae:	42b5      	cmp	r5, r6
 80098b0:	d1f9      	bne.n	80098a6 <__kernel_rem_pio2f+0x592>
 80098b2:	f100 4300 	add.w	r3, r0, #2147483648	; 0x80000000
 80098b6:	b904      	cbnz	r4, 80098ba <__kernel_rem_pio2f+0x5a6>
 80098b8:	4603      	mov	r3, r0
 80098ba:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80098bc:	4601      	mov	r1, r0
 80098be:	9836      	ldr	r0, [sp, #216]	; 0xd8
 80098c0:	6013      	str	r3, [r2, #0]
 80098c2:	f7fe f83f 	bl	8007944 <__aeabi_fsub>
 80098c6:	f1b8 0f00 	cmp.w	r8, #0
 80098ca:	dd08      	ble.n	80098de <__kernel_rem_pio2f+0x5ca>
 80098cc:	ad36      	add	r5, sp, #216	; 0xd8
 80098ce:	eb05 0888 	add.w	r8, r5, r8, lsl #2
 80098d2:	f855 1f04 	ldr.w	r1, [r5, #4]!
 80098d6:	f7fe f837 	bl	8007948 <__addsf3>
 80098da:	4545      	cmp	r5, r8
 80098dc:	d1f9      	bne.n	80098d2 <__kernel_rem_pio2f+0x5be>
 80098de:	b10c      	cbz	r4, 80098e4 <__kernel_rem_pio2f+0x5d0>
 80098e0:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80098e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80098e6:	6058      	str	r0, [r3, #4]
 80098e8:	e77d      	b.n	80097e6 <__kernel_rem_pio2f+0x4d2>
 80098ea:	f1b8 0f00 	cmp.w	r8, #0
 80098ee:	db39      	blt.n	8009964 <__kernel_rem_pio2f+0x650>
 80098f0:	f108 0501 	add.w	r5, r8, #1
 80098f4:	ae36      	add	r6, sp, #216	; 0xd8
 80098f6:	2000      	movs	r0, #0
 80098f8:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 80098fc:	f855 1d04 	ldr.w	r1, [r5, #-4]!
 8009900:	f7fe f822 	bl	8007948 <__addsf3>
 8009904:	42b5      	cmp	r5, r6
 8009906:	d1f9      	bne.n	80098fc <__kernel_rem_pio2f+0x5e8>
 8009908:	b10c      	cbz	r4, 800990e <__kernel_rem_pio2f+0x5fa>
 800990a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800990e:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8009910:	6020      	str	r0, [r4, #0]
 8009912:	e768      	b.n	80097e6 <__kernel_rem_pio2f+0x4d2>
 8009914:	2400      	movs	r4, #0
 8009916:	e713      	b.n	8009740 <__kernel_rem_pio2f+0x42c>
 8009918:	a90e      	add	r1, sp, #56	; 0x38
 800991a:	9a07      	ldr	r2, [sp, #28]
 800991c:	9502      	str	r5, [sp, #8]
 800991e:	4654      	mov	r4, sl
 8009920:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 8009924:	3a08      	subs	r2, #8
 8009926:	9207      	str	r2, [sp, #28]
 8009928:	b9d3      	cbnz	r3, 8009960 <__kernel_rem_pio2f+0x64c>
 800992a:	eb01 0380 	add.w	r3, r1, r0, lsl #2
 800992e:	4680      	mov	r8, r0
 8009930:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8009934:	f108 38ff 	add.w	r8, r8, #4294967295
 8009938:	3a08      	subs	r2, #8
 800993a:	2900      	cmp	r1, #0
 800993c:	d0f8      	beq.n	8009930 <__kernel_rem_pio2f+0x61c>
 800993e:	9207      	str	r2, [sp, #28]
 8009940:	e6ad      	b.n	800969e <__kernel_rem_pio2f+0x38a>
 8009942:	2301      	movs	r3, #1
 8009944:	e611      	b.n	800956a <__kernel_rem_pio2f+0x256>
 8009946:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8009948:	009c      	lsls	r4, r3, #2
 800994a:	9402      	str	r4, [sp, #8]
 800994c:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 8009950:	e543      	b.n	80093da <__kernel_rem_pio2f+0xc6>
 8009952:	4628      	mov	r0, r5
 8009954:	f7fe fac6 	bl	8007ee4 <__aeabi_f2iz>
 8009958:	aa0e      	add	r2, sp, #56	; 0x38
 800995a:	f842 0028 	str.w	r0, [r2, r8, lsl #2]
 800995e:	e69e      	b.n	800969e <__kernel_rem_pio2f+0x38a>
 8009960:	4680      	mov	r8, r0
 8009962:	e69c      	b.n	800969e <__kernel_rem_pio2f+0x38a>
 8009964:	2000      	movs	r0, #0
 8009966:	e7cf      	b.n	8009908 <__kernel_rem_pio2f+0x5f4>
 8009968:	0800ac10 	.word	0x0800ac10

0800996c <__kernel_sinf>:
 800996c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009970:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 8009974:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8009978:	4604      	mov	r4, r0
 800997a:	460f      	mov	r7, r1
 800997c:	4690      	mov	r8, r2
 800997e:	da03      	bge.n	8009988 <__kernel_sinf+0x1c>
 8009980:	f7fe fab0 	bl	8007ee4 <__aeabi_f2iz>
 8009984:	2800      	cmp	r0, #0
 8009986:	d059      	beq.n	8009a3c <__kernel_sinf+0xd0>
 8009988:	4621      	mov	r1, r4
 800998a:	4620      	mov	r0, r4
 800998c:	f7fe f8e4 	bl	8007b58 <__aeabi_fmul>
 8009990:	4621      	mov	r1, r4
 8009992:	4605      	mov	r5, r0
 8009994:	f7fe f8e0 	bl	8007b58 <__aeabi_fmul>
 8009998:	f64c 11d3 	movw	r1, #51667	; 0xc9d3
 800999c:	f6c2 712e 	movt	r1, #12078	; 0x2f2e
 80099a0:	4606      	mov	r6, r0
 80099a2:	4628      	mov	r0, r5
 80099a4:	f7fe f8d8 	bl	8007b58 <__aeabi_fmul>
 80099a8:	f642 7134 	movw	r1, #12084	; 0x2f34
 80099ac:	f2c3 21d7 	movt	r1, #13015	; 0x32d7
 80099b0:	f7fd ffc8 	bl	8007944 <__aeabi_fsub>
 80099b4:	4629      	mov	r1, r5
 80099b6:	f7fe f8cf 	bl	8007b58 <__aeabi_fmul>
 80099ba:	f64e 711b 	movw	r1, #61211	; 0xef1b
 80099be:	f2c3 6138 	movt	r1, #13880	; 0x3638
 80099c2:	f7fd ffc1 	bl	8007948 <__addsf3>
 80099c6:	4629      	mov	r1, r5
 80099c8:	f7fe f8c6 	bl	8007b58 <__aeabi_fmul>
 80099cc:	f640 5101 	movw	r1, #3329	; 0xd01
 80099d0:	f6c3 1150 	movt	r1, #14672	; 0x3950
 80099d4:	f7fd ffb6 	bl	8007944 <__aeabi_fsub>
 80099d8:	4629      	mov	r1, r5
 80099da:	f7fe f8bd 	bl	8007b58 <__aeabi_fmul>
 80099de:	f648 0189 	movw	r1, #34953	; 0x8889
 80099e2:	f6c3 4108 	movt	r1, #15368	; 0x3c08
 80099e6:	f7fd ffaf 	bl	8007948 <__addsf3>
 80099ea:	4681      	mov	r9, r0
 80099ec:	f1b8 0f00 	cmp.w	r8, #0
 80099f0:	d027      	beq.n	8009a42 <__kernel_sinf+0xd6>
 80099f2:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80099f6:	4638      	mov	r0, r7
 80099f8:	f7fe f8ae 	bl	8007b58 <__aeabi_fmul>
 80099fc:	4649      	mov	r1, r9
 80099fe:	4680      	mov	r8, r0
 8009a00:	4630      	mov	r0, r6
 8009a02:	f7fe f8a9 	bl	8007b58 <__aeabi_fmul>
 8009a06:	4601      	mov	r1, r0
 8009a08:	4640      	mov	r0, r8
 8009a0a:	f7fd ff9b 	bl	8007944 <__aeabi_fsub>
 8009a0e:	4629      	mov	r1, r5
 8009a10:	f7fe f8a2 	bl	8007b58 <__aeabi_fmul>
 8009a14:	4639      	mov	r1, r7
 8009a16:	f7fd ff95 	bl	8007944 <__aeabi_fsub>
 8009a1a:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8009a1e:	f6c3 612a 	movt	r1, #15914	; 0x3e2a
 8009a22:	4605      	mov	r5, r0
 8009a24:	4630      	mov	r0, r6
 8009a26:	f7fe f897 	bl	8007b58 <__aeabi_fmul>
 8009a2a:	4601      	mov	r1, r0
 8009a2c:	4628      	mov	r0, r5
 8009a2e:	f7fd ff8b 	bl	8007948 <__addsf3>
 8009a32:	4601      	mov	r1, r0
 8009a34:	4620      	mov	r0, r4
 8009a36:	f7fd ff85 	bl	8007944 <__aeabi_fsub>
 8009a3a:	4604      	mov	r4, r0
 8009a3c:	4620      	mov	r0, r4
 8009a3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009a42:	4601      	mov	r1, r0
 8009a44:	4628      	mov	r0, r5
 8009a46:	f7fe f887 	bl	8007b58 <__aeabi_fmul>
 8009a4a:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8009a4e:	f6c3 612a 	movt	r1, #15914	; 0x3e2a
 8009a52:	f7fd ff77 	bl	8007944 <__aeabi_fsub>
 8009a56:	4631      	mov	r1, r6
 8009a58:	f7fe f87e 	bl	8007b58 <__aeabi_fmul>
 8009a5c:	4601      	mov	r1, r0
 8009a5e:	4620      	mov	r0, r4
 8009a60:	f7fd ff72 	bl	8007948 <__addsf3>
 8009a64:	4604      	mov	r4, r0
 8009a66:	4620      	mov	r0, r4
 8009a68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009a6c:	0000      	movs	r0, r0
	...

08009a70 <atan>:
 8009a70:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009a74:	4689      	mov	r9, r1
 8009a76:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009a7a:	f029 4400 	bic.w	r4, r9, #2147483648	; 0x80000000
 8009a7e:	f2c4 410f 	movt	r1, #17423	; 0x440f
 8009a82:	4680      	mov	r8, r0
 8009a84:	428c      	cmp	r4, r1
 8009a86:	464a      	mov	r2, r9
 8009a88:	46ca      	mov	sl, r9
 8009a8a:	dd1f      	ble.n	8009acc <atan+0x5c>
 8009a8c:	2300      	movs	r3, #0
 8009a8e:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8009a92:	429c      	cmp	r4, r3
 8009a94:	f300 80c0 	bgt.w	8009c18 <atan+0x1a8>
 8009a98:	bf14      	ite	ne
 8009a9a:	2300      	movne	r3, #0
 8009a9c:	2301      	moveq	r3, #1
 8009a9e:	2800      	cmp	r0, #0
 8009aa0:	bf0c      	ite	eq
 8009aa2:	2100      	moveq	r1, #0
 8009aa4:	f003 0101 	andne.w	r1, r3, #1
 8009aa8:	2900      	cmp	r1, #0
 8009aaa:	f040 80b5 	bne.w	8009c18 <atan+0x1a8>
 8009aae:	f242 19fb 	movw	r9, #8699	; 0x21fb
 8009ab2:	f642 5818 	movw	r8, #11544	; 0x2d18
 8009ab6:	464b      	mov	r3, r9
 8009ab8:	f6cb 79f9 	movt	r9, #49145	; 0xbff9
 8009abc:	f6c3 73f9 	movt	r3, #16377	; 0x3ff9
 8009ac0:	f2c5 4844 	movt	r8, #21572	; 0x5444
 8009ac4:	2a00      	cmp	r2, #0
 8009ac6:	bfc8      	it	gt
 8009ac8:	4699      	movgt	r9, r3
 8009aca:	e0ad      	b.n	8009c28 <atan+0x1b8>
 8009acc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009ad0:	f6c3 73db 	movt	r3, #16347	; 0x3fdb
 8009ad4:	429c      	cmp	r4, r3
 8009ad6:	f300 80ba 	bgt.w	8009c4e <atan+0x1de>
 8009ada:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009ade:	f6c3 631f 	movt	r3, #15903	; 0x3e1f
 8009ae2:	429c      	cmp	r4, r3
 8009ae4:	f340 80a4 	ble.w	8009c30 <atan+0x1c0>
 8009ae8:	f04f 3bff 	mov.w	fp, #4294967295
 8009aec:	4642      	mov	r2, r8
 8009aee:	464b      	mov	r3, r9
 8009af0:	4640      	mov	r0, r8
 8009af2:	4649      	mov	r1, r9
 8009af4:	f000 fb7a 	bl	800a1ec <__aeabi_dmul>
 8009af8:	4602      	mov	r2, r0
 8009afa:	460b      	mov	r3, r1
 8009afc:	4606      	mov	r6, r0
 8009afe:	460f      	mov	r7, r1
 8009b00:	f000 fb74 	bl	800a1ec <__aeabi_dmul>
 8009b04:	a38e      	add	r3, pc, #568	; (adr r3, 8009d40 <atan+0x2d0>)
 8009b06:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b0a:	4604      	mov	r4, r0
 8009b0c:	460d      	mov	r5, r1
 8009b0e:	f000 fb6d 	bl	800a1ec <__aeabi_dmul>
 8009b12:	a38d      	add	r3, pc, #564	; (adr r3, 8009d48 <atan+0x2d8>)
 8009b14:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b18:	f7fd fce6 	bl	80074e8 <__adddf3>
 8009b1c:	4622      	mov	r2, r4
 8009b1e:	462b      	mov	r3, r5
 8009b20:	f000 fb64 	bl	800a1ec <__aeabi_dmul>
 8009b24:	a38a      	add	r3, pc, #552	; (adr r3, 8009d50 <atan+0x2e0>)
 8009b26:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b2a:	f7fd fcdd 	bl	80074e8 <__adddf3>
 8009b2e:	4622      	mov	r2, r4
 8009b30:	462b      	mov	r3, r5
 8009b32:	f000 fb5b 	bl	800a1ec <__aeabi_dmul>
 8009b36:	a388      	add	r3, pc, #544	; (adr r3, 8009d58 <atan+0x2e8>)
 8009b38:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b3c:	f7fd fcd4 	bl	80074e8 <__adddf3>
 8009b40:	4622      	mov	r2, r4
 8009b42:	462b      	mov	r3, r5
 8009b44:	f000 fb52 	bl	800a1ec <__aeabi_dmul>
 8009b48:	a385      	add	r3, pc, #532	; (adr r3, 8009d60 <atan+0x2f0>)
 8009b4a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b4e:	f7fd fccb 	bl	80074e8 <__adddf3>
 8009b52:	4622      	mov	r2, r4
 8009b54:	462b      	mov	r3, r5
 8009b56:	f000 fb49 	bl	800a1ec <__aeabi_dmul>
 8009b5a:	a383      	add	r3, pc, #524	; (adr r3, 8009d68 <atan+0x2f8>)
 8009b5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b60:	f7fd fcc2 	bl	80074e8 <__adddf3>
 8009b64:	4632      	mov	r2, r6
 8009b66:	463b      	mov	r3, r7
 8009b68:	f000 fb40 	bl	800a1ec <__aeabi_dmul>
 8009b6c:	a380      	add	r3, pc, #512	; (adr r3, 8009d70 <atan+0x300>)
 8009b6e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b72:	4606      	mov	r6, r0
 8009b74:	460f      	mov	r7, r1
 8009b76:	4620      	mov	r0, r4
 8009b78:	4629      	mov	r1, r5
 8009b7a:	f000 fb37 	bl	800a1ec <__aeabi_dmul>
 8009b7e:	a37e      	add	r3, pc, #504	; (adr r3, 8009d78 <atan+0x308>)
 8009b80:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b84:	f7fd fcae 	bl	80074e4 <__aeabi_dsub>
 8009b88:	4622      	mov	r2, r4
 8009b8a:	462b      	mov	r3, r5
 8009b8c:	f000 fb2e 	bl	800a1ec <__aeabi_dmul>
 8009b90:	a37b      	add	r3, pc, #492	; (adr r3, 8009d80 <atan+0x310>)
 8009b92:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b96:	f7fd fca5 	bl	80074e4 <__aeabi_dsub>
 8009b9a:	4622      	mov	r2, r4
 8009b9c:	462b      	mov	r3, r5
 8009b9e:	f000 fb25 	bl	800a1ec <__aeabi_dmul>
 8009ba2:	a379      	add	r3, pc, #484	; (adr r3, 8009d88 <atan+0x318>)
 8009ba4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009ba8:	f7fd fc9c 	bl	80074e4 <__aeabi_dsub>
 8009bac:	4622      	mov	r2, r4
 8009bae:	462b      	mov	r3, r5
 8009bb0:	f000 fb1c 	bl	800a1ec <__aeabi_dmul>
 8009bb4:	a376      	add	r3, pc, #472	; (adr r3, 8009d90 <atan+0x320>)
 8009bb6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009bba:	f7fd fc93 	bl	80074e4 <__aeabi_dsub>
 8009bbe:	4622      	mov	r2, r4
 8009bc0:	462b      	mov	r3, r5
 8009bc2:	f000 fb13 	bl	800a1ec <__aeabi_dmul>
 8009bc6:	f1bb 3fff 	cmp.w	fp, #4294967295
 8009bca:	4602      	mov	r2, r0
 8009bcc:	460b      	mov	r3, r1
 8009bce:	d063      	beq.n	8009c98 <atan+0x228>
 8009bd0:	f64a 4440 	movw	r4, #44096	; 0xac40
 8009bd4:	4630      	mov	r0, r6
 8009bd6:	f6c0 0400 	movt	r4, #2048	; 0x800
 8009bda:	4639      	mov	r1, r7
 8009bdc:	eb04 0bcb 	add.w	fp, r4, fp, lsl #3
 8009be0:	f7fd fc82 	bl	80074e8 <__adddf3>
 8009be4:	464b      	mov	r3, r9
 8009be6:	4642      	mov	r2, r8
 8009be8:	f000 fb00 	bl	800a1ec <__aeabi_dmul>
 8009bec:	e9db 2308 	ldrd	r2, r3, [fp, #32]
 8009bf0:	f7fd fc78 	bl	80074e4 <__aeabi_dsub>
 8009bf4:	464b      	mov	r3, r9
 8009bf6:	4642      	mov	r2, r8
 8009bf8:	f7fd fc74 	bl	80074e4 <__aeabi_dsub>
 8009bfc:	4602      	mov	r2, r0
 8009bfe:	460b      	mov	r3, r1
 8009c00:	e9db 0100 	ldrd	r0, r1, [fp]
 8009c04:	f7fd fc6e 	bl	80074e4 <__aeabi_dsub>
 8009c08:	f1ba 0f00 	cmp.w	sl, #0
 8009c0c:	4680      	mov	r8, r0
 8009c0e:	bfb4      	ite	lt
 8009c10:	f101 4900 	addlt.w	r9, r1, #2147483648	; 0x80000000
 8009c14:	4689      	movge	r9, r1
 8009c16:	e007      	b.n	8009c28 <atan+0x1b8>
 8009c18:	4640      	mov	r0, r8
 8009c1a:	4642      	mov	r2, r8
 8009c1c:	4649      	mov	r1, r9
 8009c1e:	464b      	mov	r3, r9
 8009c20:	f7fd fc62 	bl	80074e8 <__adddf3>
 8009c24:	4680      	mov	r8, r0
 8009c26:	4689      	mov	r9, r1
 8009c28:	4640      	mov	r0, r8
 8009c2a:	4649      	mov	r1, r9
 8009c2c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009c30:	a359      	add	r3, pc, #356	; (adr r3, 8009d98 <atan+0x328>)
 8009c32:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009c36:	4649      	mov	r1, r9
 8009c38:	f7fd fc56 	bl	80074e8 <__adddf3>
 8009c3c:	2300      	movs	r3, #0
 8009c3e:	2200      	movs	r2, #0
 8009c40:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 8009c44:	f000 fd62 	bl	800a70c <__aeabi_dcmpgt>
 8009c48:	2800      	cmp	r0, #0
 8009c4a:	d1ed      	bne.n	8009c28 <atan+0x1b8>
 8009c4c:	e74c      	b.n	8009ae8 <atan+0x78>
 8009c4e:	4649      	mov	r1, r9
 8009c50:	f000 f8a6 	bl	8009da0 <fabs>
 8009c54:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009c58:	f6c3 73f2 	movt	r3, #16370	; 0x3ff2
 8009c5c:	429c      	cmp	r4, r3
 8009c5e:	4606      	mov	r6, r0
 8009c60:	460f      	mov	r7, r1
 8009c62:	dc2a      	bgt.n	8009cba <atan+0x24a>
 8009c64:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009c68:	f6c3 73e5 	movt	r3, #16357	; 0x3fe5
 8009c6c:	429c      	cmp	r4, r3
 8009c6e:	dc58      	bgt.n	8009d22 <atan+0x2b2>
 8009c70:	4602      	mov	r2, r0
 8009c72:	460b      	mov	r3, r1
 8009c74:	f7fd fc38 	bl	80074e8 <__adddf3>
 8009c78:	2300      	movs	r3, #0
 8009c7a:	2200      	movs	r2, #0
 8009c7c:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 8009c80:	f7fd fc30 	bl	80074e4 <__aeabi_dsub>
 8009c84:	f04f 0b00 	mov.w	fp, #0
 8009c88:	2200      	movs	r2, #0
 8009c8a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009c8e:	4604      	mov	r4, r0
 8009c90:	460d      	mov	r5, r1
 8009c92:	4630      	mov	r0, r6
 8009c94:	4639      	mov	r1, r7
 8009c96:	e02c      	b.n	8009cf2 <atan+0x282>
 8009c98:	4630      	mov	r0, r6
 8009c9a:	4639      	mov	r1, r7
 8009c9c:	f7fd fc24 	bl	80074e8 <__adddf3>
 8009ca0:	4642      	mov	r2, r8
 8009ca2:	464b      	mov	r3, r9
 8009ca4:	f000 faa2 	bl	800a1ec <__aeabi_dmul>
 8009ca8:	4602      	mov	r2, r0
 8009caa:	460b      	mov	r3, r1
 8009cac:	4640      	mov	r0, r8
 8009cae:	4649      	mov	r1, r9
 8009cb0:	f7fd fc18 	bl	80074e4 <__aeabi_dsub>
 8009cb4:	4680      	mov	r8, r0
 8009cb6:	4689      	mov	r9, r1
 8009cb8:	e7b6      	b.n	8009c28 <atan+0x1b8>
 8009cba:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8009cbe:	f2c4 0303 	movt	r3, #16387	; 0x4003
 8009cc2:	429c      	cmp	r4, r3
 8009cc4:	dc20      	bgt.n	8009d08 <atan+0x298>
 8009cc6:	2300      	movs	r3, #0
 8009cc8:	2200      	movs	r2, #0
 8009cca:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 8009cce:	f04f 0b02 	mov.w	fp, #2
 8009cd2:	f7fd fc07 	bl	80074e4 <__aeabi_dsub>
 8009cd6:	2300      	movs	r3, #0
 8009cd8:	2200      	movs	r2, #0
 8009cda:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 8009cde:	4604      	mov	r4, r0
 8009ce0:	460d      	mov	r5, r1
 8009ce2:	4630      	mov	r0, r6
 8009ce4:	4639      	mov	r1, r7
 8009ce6:	f000 fa81 	bl	800a1ec <__aeabi_dmul>
 8009cea:	2300      	movs	r3, #0
 8009cec:	2200      	movs	r2, #0
 8009cee:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 8009cf2:	f7fd fbf9 	bl	80074e8 <__adddf3>
 8009cf6:	4602      	mov	r2, r0
 8009cf8:	460b      	mov	r3, r1
 8009cfa:	4620      	mov	r0, r4
 8009cfc:	4629      	mov	r1, r5
 8009cfe:	f000 fb9f 	bl	800a440 <__aeabi_ddiv>
 8009d02:	4680      	mov	r8, r0
 8009d04:	4689      	mov	r9, r1
 8009d06:	e6f1      	b.n	8009aec <atan+0x7c>
 8009d08:	2100      	movs	r1, #0
 8009d0a:	2000      	movs	r0, #0
 8009d0c:	f6cb 71f0 	movt	r1, #49136	; 0xbff0
 8009d10:	4632      	mov	r2, r6
 8009d12:	463b      	mov	r3, r7
 8009d14:	f04f 0b03 	mov.w	fp, #3
 8009d18:	f000 fb92 	bl	800a440 <__aeabi_ddiv>
 8009d1c:	4680      	mov	r8, r0
 8009d1e:	4689      	mov	r9, r1
 8009d20:	e6e4      	b.n	8009aec <atan+0x7c>
 8009d22:	2300      	movs	r3, #0
 8009d24:	2200      	movs	r2, #0
 8009d26:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 8009d2a:	f04f 0b01 	mov.w	fp, #1
 8009d2e:	f7fd fbd9 	bl	80074e4 <__aeabi_dsub>
 8009d32:	4604      	mov	r4, r0
 8009d34:	460d      	mov	r5, r1
 8009d36:	4630      	mov	r0, r6
 8009d38:	4639      	mov	r1, r7
 8009d3a:	e7d6      	b.n	8009cea <atan+0x27a>
 8009d3c:	f3af 8000 	nop.w
 8009d40:	e322da11 	.word	0xe322da11
 8009d44:	3f90ad3a 	.word	0x3f90ad3a
 8009d48:	24760deb 	.word	0x24760deb
 8009d4c:	3fa97b4b 	.word	0x3fa97b4b
 8009d50:	a0d03d51 	.word	0xa0d03d51
 8009d54:	3fb10d66 	.word	0x3fb10d66
 8009d58:	c54c206e 	.word	0xc54c206e
 8009d5c:	3fb745cd 	.word	0x3fb745cd
 8009d60:	920083ff 	.word	0x920083ff
 8009d64:	3fc24924 	.word	0x3fc24924
 8009d68:	5555550d 	.word	0x5555550d
 8009d6c:	3fd55555 	.word	0x3fd55555
 8009d70:	2c6a6c2f 	.word	0x2c6a6c2f
 8009d74:	bfa2b444 	.word	0xbfa2b444
 8009d78:	52defd9a 	.word	0x52defd9a
 8009d7c:	3fadde2d 	.word	0x3fadde2d
 8009d80:	af749a6d 	.word	0xaf749a6d
 8009d84:	3fb3b0f2 	.word	0x3fb3b0f2
 8009d88:	fe231671 	.word	0xfe231671
 8009d8c:	3fbc71c6 	.word	0x3fbc71c6
 8009d90:	9998ebc4 	.word	0x9998ebc4
 8009d94:	3fc99999 	.word	0x3fc99999
 8009d98:	8800759c 	.word	0x8800759c
 8009d9c:	7e37e43c 	.word	0x7e37e43c

08009da0 <fabs>:
 8009da0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8009da4:	4770      	bx	lr
 8009da6:	bf00      	nop

08009da8 <__fpclassifyd>:
 8009da8:	ea50 0201 	orrs.w	r2, r0, r1
 8009dac:	d101      	bne.n	8009db2 <__fpclassifyd+0xa>
 8009dae:	2002      	movs	r0, #2
 8009db0:	4770      	bx	lr
 8009db2:	f1d0 0201 	rsbs	r2, r0, #1
 8009db6:	bf38      	it	cc
 8009db8:	2200      	movcc	r2, #0
 8009dba:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8009dbe:	bf08      	it	eq
 8009dc0:	2800      	cmpeq	r0, #0
 8009dc2:	d0f4      	beq.n	8009dae <__fpclassifyd+0x6>
 8009dc4:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8009dc8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009dcc:	f5a3 1080 	sub.w	r0, r3, #1048576	; 0x100000
 8009dd0:	f6c7 71df 	movt	r1, #32735	; 0x7fdf
 8009dd4:	4288      	cmp	r0, r1
 8009dd6:	d801      	bhi.n	8009ddc <__fpclassifyd+0x34>
 8009dd8:	2004      	movs	r0, #4
 8009dda:	4770      	bx	lr
 8009ddc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8009de0:	d201      	bcs.n	8009de6 <__fpclassifyd+0x3e>
 8009de2:	2003      	movs	r0, #3
 8009de4:	4770      	bx	lr
 8009de6:	2000      	movs	r0, #0
 8009de8:	f6c7 70f0 	movt	r0, #32752	; 0x7ff0
 8009dec:	4283      	cmp	r3, r0
 8009dee:	bf14      	ite	ne
 8009df0:	2000      	movne	r0, #0
 8009df2:	f002 0001 	andeq.w	r0, r2, #1
 8009df6:	4770      	bx	lr

08009df8 <matherr>:
 8009df8:	2000      	movs	r0, #0
 8009dfa:	4770      	bx	lr

08009dfc <nan>:
 8009dfc:	2100      	movs	r1, #0
 8009dfe:	2000      	movs	r0, #0
 8009e00:	f6c7 71f8 	movt	r1, #32760	; 0x7ff8
 8009e04:	4770      	bx	lr
 8009e06:	bf00      	nop

08009e08 <atanf>:
 8009e08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009e0c:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 8009e10:	f1b5 4fa1 	cmp.w	r5, #1350565888	; 0x50800000
 8009e14:	4604      	mov	r4, r0
 8009e16:	4606      	mov	r6, r0
 8009e18:	db0e      	blt.n	8009e38 <atanf+0x30>
 8009e1a:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 8009e1e:	f300 80a4 	bgt.w	8009f6a <atanf+0x162>
 8009e22:	2800      	cmp	r0, #0
 8009e24:	f640 74db 	movw	r4, #4059	; 0xfdb
 8009e28:	bfc8      	it	gt
 8009e2a:	f6c3 74c9 	movtgt	r4, #16329	; 0x3fc9
 8009e2e:	f340 80cf 	ble.w	8009fd0 <atanf+0x1c8>
 8009e32:	4620      	mov	r0, r4
 8009e34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009e38:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009e3c:	f6c3 63df 	movt	r3, #16095	; 0x3edf
 8009e40:	429d      	cmp	r5, r3
 8009e42:	f300 80a9 	bgt.w	8009f98 <atanf+0x190>
 8009e46:	f1b5 5f44 	cmp.w	r5, #822083584	; 0x31000000
 8009e4a:	f2c0 8095 	blt.w	8009f78 <atanf+0x170>
 8009e4e:	f04f 37ff 	mov.w	r7, #4294967295
 8009e52:	4621      	mov	r1, r4
 8009e54:	4620      	mov	r0, r4
 8009e56:	f7fd fe7f 	bl	8007b58 <__aeabi_fmul>
 8009e5a:	4601      	mov	r1, r0
 8009e5c:	4680      	mov	r8, r0
 8009e5e:	f7fd fe7b 	bl	8007b58 <__aeabi_fmul>
 8009e62:	f646 11d7 	movw	r1, #27095	; 0x69d7
 8009e66:	f6c3 4185 	movt	r1, #15493	; 0x3c85
 8009e6a:	4605      	mov	r5, r0
 8009e6c:	f7fd fe74 	bl	8007b58 <__aeabi_fmul>
 8009e70:	f64d 2159 	movw	r1, #55897	; 0xda59
 8009e74:	f6c3 514b 	movt	r1, #15691	; 0x3d4b
 8009e78:	f7fd fd66 	bl	8007948 <__addsf3>
 8009e7c:	4629      	mov	r1, r5
 8009e7e:	f7fd fe6b 	bl	8007b58 <__aeabi_fmul>
 8009e82:	f646 3135 	movw	r1, #27445	; 0x6b35
 8009e86:	f6c3 5188 	movt	r1, #15752	; 0x3d88
 8009e8a:	f7fd fd5d 	bl	8007948 <__addsf3>
 8009e8e:	4629      	mov	r1, r5
 8009e90:	f7fd fe62 	bl	8007b58 <__aeabi_fmul>
 8009e94:	f642 616e 	movw	r1, #11886	; 0x2e6e
 8009e98:	f6c3 51ba 	movt	r1, #15802	; 0x3dba
 8009e9c:	f7fd fd54 	bl	8007948 <__addsf3>
 8009ea0:	4629      	mov	r1, r5
 8009ea2:	f7fd fe59 	bl	8007b58 <__aeabi_fmul>
 8009ea6:	f644 1125 	movw	r1, #18725	; 0x4925
 8009eaa:	f6c3 6112 	movt	r1, #15890	; 0x3e12
 8009eae:	f7fd fd4b 	bl	8007948 <__addsf3>
 8009eb2:	4629      	mov	r1, r5
 8009eb4:	f7fd fe50 	bl	8007b58 <__aeabi_fmul>
 8009eb8:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8009ebc:	f6c3 61aa 	movt	r1, #16042	; 0x3eaa
 8009ec0:	f7fd fd42 	bl	8007948 <__addsf3>
 8009ec4:	4641      	mov	r1, r8
 8009ec6:	f7fd fe47 	bl	8007b58 <__aeabi_fmul>
 8009eca:	f24a 2121 	movw	r1, #41505	; 0xa221
 8009ece:	f6cb 5115 	movt	r1, #48405	; 0xbd15
 8009ed2:	4680      	mov	r8, r0
 8009ed4:	4628      	mov	r0, r5
 8009ed6:	f7fd fe3f 	bl	8007b58 <__aeabi_fmul>
 8009eda:	f24f 116b 	movw	r1, #61803	; 0xf16b
 8009ede:	f6c3 516e 	movt	r1, #15726	; 0x3d6e
 8009ee2:	f7fd fd2f 	bl	8007944 <__aeabi_fsub>
 8009ee6:	4629      	mov	r1, r5
 8009ee8:	f7fd fe36 	bl	8007b58 <__aeabi_fmul>
 8009eec:	f248 7195 	movw	r1, #34709	; 0x8795
 8009ef0:	f6c3 519d 	movt	r1, #15773	; 0x3d9d
 8009ef4:	f7fd fd26 	bl	8007944 <__aeabi_fsub>
 8009ef8:	4629      	mov	r1, r5
 8009efa:	f7fd fe2d 	bl	8007b58 <__aeabi_fmul>
 8009efe:	f648 6138 	movw	r1, #36408	; 0x8e38
 8009f02:	f6c3 51e3 	movt	r1, #15843	; 0x3de3
 8009f06:	f7fd fd1d 	bl	8007944 <__aeabi_fsub>
 8009f0a:	4629      	mov	r1, r5
 8009f0c:	f7fd fe24 	bl	8007b58 <__aeabi_fmul>
 8009f10:	f64c 41cd 	movw	r1, #52429	; 0xcccd
 8009f14:	f6c3 614c 	movt	r1, #15948	; 0x3e4c
 8009f18:	f7fd fd14 	bl	8007944 <__aeabi_fsub>
 8009f1c:	4629      	mov	r1, r5
 8009f1e:	f7fd fe1b 	bl	8007b58 <__aeabi_fmul>
 8009f22:	1c7b      	adds	r3, r7, #1
 8009f24:	4601      	mov	r1, r0
 8009f26:	d056      	beq.n	8009fd6 <atanf+0x1ce>
 8009f28:	f64a 4580 	movw	r5, #44160	; 0xac80
 8009f2c:	4640      	mov	r0, r8
 8009f2e:	f7fd fd0b 	bl	8007948 <__addsf3>
 8009f32:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009f36:	4621      	mov	r1, r4
 8009f38:	f7fd fe0e 	bl	8007b58 <__aeabi_fmul>
 8009f3c:	eb05 0387 	add.w	r3, r5, r7, lsl #2
 8009f40:	6919      	ldr	r1, [r3, #16]
 8009f42:	f7fd fcff 	bl	8007944 <__aeabi_fsub>
 8009f46:	4621      	mov	r1, r4
 8009f48:	f7fd fcfc 	bl	8007944 <__aeabi_fsub>
 8009f4c:	4601      	mov	r1, r0
 8009f4e:	f855 0027 	ldr.w	r0, [r5, r7, lsl #2]
 8009f52:	f7fd fcf7 	bl	8007944 <__aeabi_fsub>
 8009f56:	2e00      	cmp	r6, #0
 8009f58:	bfb8      	it	lt
 8009f5a:	f100 4400 	addlt.w	r4, r0, #2147483648	; 0x80000000
 8009f5e:	f6ff af68 	blt.w	8009e32 <atanf+0x2a>
 8009f62:	4604      	mov	r4, r0
 8009f64:	4620      	mov	r0, r4
 8009f66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009f6a:	4601      	mov	r1, r0
 8009f6c:	f7fd fcec 	bl	8007948 <__addsf3>
 8009f70:	4604      	mov	r4, r0
 8009f72:	4620      	mov	r0, r4
 8009f74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009f78:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 8009f7c:	f2c7 1149 	movt	r1, #29001	; 0x7149
 8009f80:	f7fd fce2 	bl	8007948 <__addsf3>
 8009f84:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8009f88:	f7fd ffa2 	bl	8007ed0 <__aeabi_fcmpgt>
 8009f8c:	2800      	cmp	r0, #0
 8009f8e:	f43f af5e 	beq.w	8009e4e <atanf+0x46>
 8009f92:	4620      	mov	r0, r4
 8009f94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009f98:	f000 f854 	bl	800a044 <fabsf>
 8009f9c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009fa0:	f6c3 7397 	movt	r3, #16279	; 0x3f97
 8009fa4:	429d      	cmp	r5, r3
 8009fa6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009faa:	4604      	mov	r4, r0
 8009fac:	dc1f      	bgt.n	8009fee <atanf+0x1e6>
 8009fae:	f6c3 732f 	movt	r3, #16175	; 0x3f2f
 8009fb2:	429d      	cmp	r5, r3
 8009fb4:	dc3d      	bgt.n	800a032 <atanf+0x22a>
 8009fb6:	4601      	mov	r1, r0
 8009fb8:	2700      	movs	r7, #0
 8009fba:	f7fd fcc5 	bl	8007948 <__addsf3>
 8009fbe:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8009fc2:	f7fd fcbf 	bl	8007944 <__aeabi_fsub>
 8009fc6:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8009fca:	4605      	mov	r5, r0
 8009fcc:	4620      	mov	r0, r4
 8009fce:	e01f      	b.n	800a010 <atanf+0x208>
 8009fd0:	f6cb 74c9 	movt	r4, #49097	; 0xbfc9
 8009fd4:	e72d      	b.n	8009e32 <atanf+0x2a>
 8009fd6:	4640      	mov	r0, r8
 8009fd8:	f7fd fcb6 	bl	8007948 <__addsf3>
 8009fdc:	4621      	mov	r1, r4
 8009fde:	f7fd fdbb 	bl	8007b58 <__aeabi_fmul>
 8009fe2:	4601      	mov	r1, r0
 8009fe4:	4620      	mov	r0, r4
 8009fe6:	f7fd fcad 	bl	8007944 <__aeabi_fsub>
 8009fea:	4604      	mov	r4, r0
 8009fec:	e721      	b.n	8009e32 <atanf+0x2a>
 8009fee:	f2c4 031b 	movt	r3, #16411	; 0x401b
 8009ff2:	429d      	cmp	r5, r3
 8009ff4:	dc14      	bgt.n	800a020 <atanf+0x218>
 8009ff6:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 8009ffa:	2702      	movs	r7, #2
 8009ffc:	f7fd fca2 	bl	8007944 <__aeabi_fsub>
 800a000:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 800a004:	4605      	mov	r5, r0
 800a006:	4620      	mov	r0, r4
 800a008:	f7fd fda6 	bl	8007b58 <__aeabi_fmul>
 800a00c:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800a010:	f7fd fc9a 	bl	8007948 <__addsf3>
 800a014:	4601      	mov	r1, r0
 800a016:	4628      	mov	r0, r5
 800a018:	f7fd fe52 	bl	8007cc0 <__aeabi_fdiv>
 800a01c:	4604      	mov	r4, r0
 800a01e:	e718      	b.n	8009e52 <atanf+0x4a>
 800a020:	2000      	movs	r0, #0
 800a022:	4621      	mov	r1, r4
 800a024:	f6cb 7080 	movt	r0, #49024	; 0xbf80
 800a028:	2703      	movs	r7, #3
 800a02a:	f7fd fe49 	bl	8007cc0 <__aeabi_fdiv>
 800a02e:	4604      	mov	r4, r0
 800a030:	e70f      	b.n	8009e52 <atanf+0x4a>
 800a032:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800a036:	2701      	movs	r7, #1
 800a038:	f7fd fc84 	bl	8007944 <__aeabi_fsub>
 800a03c:	4605      	mov	r5, r0
 800a03e:	4620      	mov	r0, r4
 800a040:	e7e4      	b.n	800a00c <atanf+0x204>
 800a042:	bf00      	nop

0800a044 <fabsf>:
 800a044:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800a048:	4770      	bx	lr
 800a04a:	bf00      	nop

0800a04c <floorf>:
 800a04c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a04e:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 800a052:	4601      	mov	r1, r0
 800a054:	4604      	mov	r4, r0
 800a056:	0df5      	lsrs	r5, r6, #23
 800a058:	3d7f      	subs	r5, #127	; 0x7f
 800a05a:	2d16      	cmp	r5, #22
 800a05c:	dc20      	bgt.n	800a0a0 <floorf+0x54>
 800a05e:	2d00      	cmp	r5, #0
 800a060:	4607      	mov	r7, r0
 800a062:	db25      	blt.n	800a0b0 <floorf+0x64>
 800a064:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800a068:	f2c0 037f 	movt	r3, #127	; 0x7f
 800a06c:	fa43 f605 	asr.w	r6, r3, r5
 800a070:	4206      	tst	r6, r0
 800a072:	d013      	beq.n	800a09c <floorf+0x50>
 800a074:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 800a078:	f2c7 1149 	movt	r1, #29001	; 0x7149
 800a07c:	f7fd fc64 	bl	8007948 <__addsf3>
 800a080:	2100      	movs	r1, #0
 800a082:	f7fd ff25 	bl	8007ed0 <__aeabi_fcmpgt>
 800a086:	b140      	cbz	r0, 800a09a <floorf+0x4e>
 800a088:	2c00      	cmp	r4, #0
 800a08a:	bfbe      	ittt	lt
 800a08c:	f44f 0300 	movlt.w	r3, #8388608	; 0x800000
 800a090:	fa43 f505 	asrlt.w	r5, r3, r5
 800a094:	1967      	addlt	r7, r4, r5
 800a096:	ea27 0406 	bic.w	r4, r7, r6
 800a09a:	4621      	mov	r1, r4
 800a09c:	4608      	mov	r0, r1
 800a09e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a0a0:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 800a0a4:	d3fa      	bcc.n	800a09c <floorf+0x50>
 800a0a6:	f7fd fc4f 	bl	8007948 <__addsf3>
 800a0aa:	4601      	mov	r1, r0
 800a0ac:	4608      	mov	r0, r1
 800a0ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a0b0:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 800a0b4:	f2c7 1149 	movt	r1, #29001	; 0x7149
 800a0b8:	f7fd fc46 	bl	8007948 <__addsf3>
 800a0bc:	2100      	movs	r1, #0
 800a0be:	f7fd ff07 	bl	8007ed0 <__aeabi_fcmpgt>
 800a0c2:	2800      	cmp	r0, #0
 800a0c4:	d0e9      	beq.n	800a09a <floorf+0x4e>
 800a0c6:	2c00      	cmp	r4, #0
 800a0c8:	db01      	blt.n	800a0ce <floorf+0x82>
 800a0ca:	2400      	movs	r4, #0
 800a0cc:	e7e5      	b.n	800a09a <floorf+0x4e>
 800a0ce:	2300      	movs	r3, #0
 800a0d0:	f6cb 7380 	movt	r3, #49024	; 0xbf80
 800a0d4:	2e00      	cmp	r6, #0
 800a0d6:	bf18      	it	ne
 800a0d8:	461c      	movne	r4, r3
 800a0da:	e7de      	b.n	800a09a <floorf+0x4e>

0800a0dc <__fpclassifyf>:
 800a0dc:	f030 4000 	bics.w	r0, r0, #2147483648	; 0x80000000
 800a0e0:	d101      	bne.n	800a0e6 <__fpclassifyf+0xa>
 800a0e2:	2002      	movs	r0, #2
 800a0e4:	4770      	bx	lr
 800a0e6:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 800a0ea:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 800a0ee:	d201      	bcs.n	800a0f4 <__fpclassifyf+0x18>
 800a0f0:	2004      	movs	r0, #4
 800a0f2:	4770      	bx	lr
 800a0f4:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800a0f8:	1e42      	subs	r2, r0, #1
 800a0fa:	f2c0 037f 	movt	r3, #127	; 0x7f
 800a0fe:	429a      	cmp	r2, r3
 800a100:	d801      	bhi.n	800a106 <__fpclassifyf+0x2a>
 800a102:	2003      	movs	r0, #3
 800a104:	4770      	bx	lr
 800a106:	f1b0 43ff 	subs.w	r3, r0, #2139095040	; 0x7f800000
 800a10a:	4258      	negs	r0, r3
 800a10c:	4158      	adcs	r0, r3
 800a10e:	4770      	bx	lr

0800a110 <scalbnf>:
 800a110:	b538      	push	{r3, r4, r5, lr}
 800a112:	f030 4400 	bics.w	r4, r0, #2147483648	; 0x80000000
 800a116:	4603      	mov	r3, r0
 800a118:	4602      	mov	r2, r0
 800a11a:	460d      	mov	r5, r1
 800a11c:	d011      	beq.n	800a142 <scalbnf+0x32>
 800a11e:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 800a122:	d210      	bcs.n	800a146 <scalbnf+0x36>
 800a124:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 800a128:	d313      	bcc.n	800a152 <scalbnf+0x42>
 800a12a:	0de4      	lsrs	r4, r4, #23
 800a12c:	1964      	adds	r4, r4, r5
 800a12e:	2cfe      	cmp	r4, #254	; 0xfe
 800a130:	bfc8      	it	gt
 800a132:	4619      	movgt	r1, r3
 800a134:	dc33      	bgt.n	800a19e <scalbnf+0x8e>
 800a136:	2c00      	cmp	r4, #0
 800a138:	dd1b      	ble.n	800a172 <scalbnf+0x62>
 800a13a:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 800a13e:	ea42 53c4 	orr.w	r3, r2, r4, lsl #23
 800a142:	4618      	mov	r0, r3
 800a144:	bd38      	pop	{r3, r4, r5, pc}
 800a146:	4601      	mov	r1, r0
 800a148:	f7fd fbfe 	bl	8007948 <__addsf3>
 800a14c:	4603      	mov	r3, r0
 800a14e:	4618      	mov	r0, r3
 800a150:	bd38      	pop	{r3, r4, r5, pc}
 800a152:	f04f 4198 	mov.w	r1, #1275068416	; 0x4c000000
 800a156:	f7fd fcff 	bl	8007b58 <__aeabi_fmul>
 800a15a:	f643 42b0 	movw	r2, #15536	; 0x3cb0
 800a15e:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 800a162:	4295      	cmp	r5, r2
 800a164:	4603      	mov	r3, r0
 800a166:	db12      	blt.n	800a18e <scalbnf+0x7e>
 800a168:	f3c0 54c7 	ubfx	r4, r0, #23, #8
 800a16c:	4602      	mov	r2, r0
 800a16e:	3c19      	subs	r4, #25
 800a170:	e7dc      	b.n	800a12c <scalbnf+0x1c>
 800a172:	f114 0f16 	cmn.w	r4, #22
 800a176:	da20      	bge.n	800a1ba <scalbnf+0xaa>
 800a178:	f24c 3250 	movw	r2, #50000	; 0xc350
 800a17c:	4619      	mov	r1, r3
 800a17e:	4295      	cmp	r5, r2
 800a180:	dc0d      	bgt.n	800a19e <scalbnf+0x8e>
 800a182:	f244 2060 	movw	r0, #16992	; 0x4260
 800a186:	f6c0 50a2 	movt	r0, #3490	; 0xda2
 800a18a:	f000 f823 	bl	800a1d4 <copysignf>
 800a18e:	f244 2160 	movw	r1, #16992	; 0x4260
 800a192:	f6c0 51a2 	movt	r1, #3490	; 0xda2
 800a196:	f7fd fcdf 	bl	8007b58 <__aeabi_fmul>
 800a19a:	4603      	mov	r3, r0
 800a19c:	e7d1      	b.n	800a142 <scalbnf+0x32>
 800a19e:	f24f 20ca 	movw	r0, #62154	; 0xf2ca
 800a1a2:	f2c7 1049 	movt	r0, #29001	; 0x7149
 800a1a6:	f000 f815 	bl	800a1d4 <copysignf>
 800a1aa:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 800a1ae:	f2c7 1149 	movt	r1, #29001	; 0x7149
 800a1b2:	f7fd fcd1 	bl	8007b58 <__aeabi_fmul>
 800a1b6:	4603      	mov	r3, r0
 800a1b8:	e7c3      	b.n	800a142 <scalbnf+0x32>
 800a1ba:	f104 0019 	add.w	r0, r4, #25
 800a1be:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 800a1c2:	f04f 514c 	mov.w	r1, #855638016	; 0x33000000
 800a1c6:	ea42 50c0 	orr.w	r0, r2, r0, lsl #23
 800a1ca:	f7fd fcc5 	bl	8007b58 <__aeabi_fmul>
 800a1ce:	4603      	mov	r3, r0
 800a1d0:	e7b7      	b.n	800a142 <scalbnf+0x32>
 800a1d2:	bf00      	nop

0800a1d4 <copysignf>:
 800a1d4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a1d8:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800a1dc:	4308      	orrs	r0, r1
 800a1de:	4770      	bx	lr

0800a1e0 <__errno>:
 800a1e0:	f240 034c 	movw	r3, #76	; 0x4c
 800a1e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a1e8:	6818      	ldr	r0, [r3, #0]
 800a1ea:	4770      	bx	lr

0800a1ec <__aeabi_dmul>:
 800a1ec:	b570      	push	{r4, r5, r6, lr}
 800a1ee:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800a1f2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800a1f6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800a1fa:	bf1d      	ittte	ne
 800a1fc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800a200:	ea94 0f0c 	teqne	r4, ip
 800a204:	ea95 0f0c 	teqne	r5, ip
 800a208:	f000 f8de 	bleq	800a3c8 <__aeabi_dmul+0x1dc>
 800a20c:	442c      	add	r4, r5
 800a20e:	ea81 0603 	eor.w	r6, r1, r3
 800a212:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800a216:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800a21a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800a21e:	bf18      	it	ne
 800a220:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800a224:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800a228:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800a22c:	d038      	beq.n	800a2a0 <__aeabi_dmul+0xb4>
 800a22e:	fba0 ce02 	umull	ip, lr, r0, r2
 800a232:	f04f 0500 	mov.w	r5, #0
 800a236:	fbe1 e502 	umlal	lr, r5, r1, r2
 800a23a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800a23e:	fbe0 e503 	umlal	lr, r5, r0, r3
 800a242:	f04f 0600 	mov.w	r6, #0
 800a246:	fbe1 5603 	umlal	r5, r6, r1, r3
 800a24a:	f09c 0f00 	teq	ip, #0
 800a24e:	bf18      	it	ne
 800a250:	f04e 0e01 	orrne.w	lr, lr, #1
 800a254:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800a258:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800a25c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800a260:	d204      	bcs.n	800a26c <__aeabi_dmul+0x80>
 800a262:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800a266:	416d      	adcs	r5, r5
 800a268:	eb46 0606 	adc.w	r6, r6, r6
 800a26c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800a270:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800a274:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800a278:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800a27c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800a280:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800a284:	bf88      	it	hi
 800a286:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800a28a:	d81e      	bhi.n	800a2ca <__aeabi_dmul+0xde>
 800a28c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800a290:	bf08      	it	eq
 800a292:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800a296:	f150 0000 	adcs.w	r0, r0, #0
 800a29a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800a29e:	bd70      	pop	{r4, r5, r6, pc}
 800a2a0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800a2a4:	ea46 0101 	orr.w	r1, r6, r1
 800a2a8:	ea40 0002 	orr.w	r0, r0, r2
 800a2ac:	ea81 0103 	eor.w	r1, r1, r3
 800a2b0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800a2b4:	bfc2      	ittt	gt
 800a2b6:	ebd4 050c 	rsbsgt	r5, r4, ip
 800a2ba:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800a2be:	bd70      	popgt	{r4, r5, r6, pc}
 800a2c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800a2c4:	f04f 0e00 	mov.w	lr, #0
 800a2c8:	3c01      	subs	r4, #1
 800a2ca:	f300 80ab 	bgt.w	800a424 <__aeabi_dmul+0x238>
 800a2ce:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800a2d2:	bfde      	ittt	le
 800a2d4:	2000      	movle	r0, #0
 800a2d6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800a2da:	bd70      	pople	{r4, r5, r6, pc}
 800a2dc:	f1c4 0400 	rsb	r4, r4, #0
 800a2e0:	3c20      	subs	r4, #32
 800a2e2:	da35      	bge.n	800a350 <__aeabi_dmul+0x164>
 800a2e4:	340c      	adds	r4, #12
 800a2e6:	dc1b      	bgt.n	800a320 <__aeabi_dmul+0x134>
 800a2e8:	f104 0414 	add.w	r4, r4, #20
 800a2ec:	f1c4 0520 	rsb	r5, r4, #32
 800a2f0:	fa00 f305 	lsl.w	r3, r0, r5
 800a2f4:	fa20 f004 	lsr.w	r0, r0, r4
 800a2f8:	fa01 f205 	lsl.w	r2, r1, r5
 800a2fc:	ea40 0002 	orr.w	r0, r0, r2
 800a300:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800a304:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800a308:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800a30c:	fa21 f604 	lsr.w	r6, r1, r4
 800a310:	eb42 0106 	adc.w	r1, r2, r6
 800a314:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800a318:	bf08      	it	eq
 800a31a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800a31e:	bd70      	pop	{r4, r5, r6, pc}
 800a320:	f1c4 040c 	rsb	r4, r4, #12
 800a324:	f1c4 0520 	rsb	r5, r4, #32
 800a328:	fa00 f304 	lsl.w	r3, r0, r4
 800a32c:	fa20 f005 	lsr.w	r0, r0, r5
 800a330:	fa01 f204 	lsl.w	r2, r1, r4
 800a334:	ea40 0002 	orr.w	r0, r0, r2
 800a338:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a33c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800a340:	f141 0100 	adc.w	r1, r1, #0
 800a344:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800a348:	bf08      	it	eq
 800a34a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800a34e:	bd70      	pop	{r4, r5, r6, pc}
 800a350:	f1c4 0520 	rsb	r5, r4, #32
 800a354:	fa00 f205 	lsl.w	r2, r0, r5
 800a358:	ea4e 0e02 	orr.w	lr, lr, r2
 800a35c:	fa20 f304 	lsr.w	r3, r0, r4
 800a360:	fa01 f205 	lsl.w	r2, r1, r5
 800a364:	ea43 0302 	orr.w	r3, r3, r2
 800a368:	fa21 f004 	lsr.w	r0, r1, r4
 800a36c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a370:	fa21 f204 	lsr.w	r2, r1, r4
 800a374:	ea20 0002 	bic.w	r0, r0, r2
 800a378:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800a37c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800a380:	bf08      	it	eq
 800a382:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800a386:	bd70      	pop	{r4, r5, r6, pc}
 800a388:	f094 0f00 	teq	r4, #0
 800a38c:	d10f      	bne.n	800a3ae <__aeabi_dmul+0x1c2>
 800a38e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800a392:	0040      	lsls	r0, r0, #1
 800a394:	eb41 0101 	adc.w	r1, r1, r1
 800a398:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800a39c:	bf08      	it	eq
 800a39e:	3c01      	subeq	r4, #1
 800a3a0:	d0f7      	beq.n	800a392 <__aeabi_dmul+0x1a6>
 800a3a2:	ea41 0106 	orr.w	r1, r1, r6
 800a3a6:	f095 0f00 	teq	r5, #0
 800a3aa:	bf18      	it	ne
 800a3ac:	4770      	bxne	lr
 800a3ae:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800a3b2:	0052      	lsls	r2, r2, #1
 800a3b4:	eb43 0303 	adc.w	r3, r3, r3
 800a3b8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800a3bc:	bf08      	it	eq
 800a3be:	3d01      	subeq	r5, #1
 800a3c0:	d0f7      	beq.n	800a3b2 <__aeabi_dmul+0x1c6>
 800a3c2:	ea43 0306 	orr.w	r3, r3, r6
 800a3c6:	4770      	bx	lr
 800a3c8:	ea94 0f0c 	teq	r4, ip
 800a3cc:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800a3d0:	bf18      	it	ne
 800a3d2:	ea95 0f0c 	teqne	r5, ip
 800a3d6:	d00c      	beq.n	800a3f2 <__aeabi_dmul+0x206>
 800a3d8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800a3dc:	bf18      	it	ne
 800a3de:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800a3e2:	d1d1      	bne.n	800a388 <__aeabi_dmul+0x19c>
 800a3e4:	ea81 0103 	eor.w	r1, r1, r3
 800a3e8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a3ec:	f04f 0000 	mov.w	r0, #0
 800a3f0:	bd70      	pop	{r4, r5, r6, pc}
 800a3f2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800a3f6:	bf06      	itte	eq
 800a3f8:	4610      	moveq	r0, r2
 800a3fa:	4619      	moveq	r1, r3
 800a3fc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800a400:	d019      	beq.n	800a436 <__aeabi_dmul+0x24a>
 800a402:	ea94 0f0c 	teq	r4, ip
 800a406:	d102      	bne.n	800a40e <__aeabi_dmul+0x222>
 800a408:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800a40c:	d113      	bne.n	800a436 <__aeabi_dmul+0x24a>
 800a40e:	ea95 0f0c 	teq	r5, ip
 800a412:	d105      	bne.n	800a420 <__aeabi_dmul+0x234>
 800a414:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800a418:	bf1c      	itt	ne
 800a41a:	4610      	movne	r0, r2
 800a41c:	4619      	movne	r1, r3
 800a41e:	d10a      	bne.n	800a436 <__aeabi_dmul+0x24a>
 800a420:	ea81 0103 	eor.w	r1, r1, r3
 800a424:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a428:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800a42c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800a430:	f04f 0000 	mov.w	r0, #0
 800a434:	bd70      	pop	{r4, r5, r6, pc}
 800a436:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800a43a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800a43e:	bd70      	pop	{r4, r5, r6, pc}

0800a440 <__aeabi_ddiv>:
 800a440:	b570      	push	{r4, r5, r6, lr}
 800a442:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800a446:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800a44a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800a44e:	bf1d      	ittte	ne
 800a450:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800a454:	ea94 0f0c 	teqne	r4, ip
 800a458:	ea95 0f0c 	teqne	r5, ip
 800a45c:	f000 f8a7 	bleq	800a5ae <__aeabi_ddiv+0x16e>
 800a460:	eba4 0405 	sub.w	r4, r4, r5
 800a464:	ea81 0e03 	eor.w	lr, r1, r3
 800a468:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800a46c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800a470:	f000 8088 	beq.w	800a584 <__aeabi_ddiv+0x144>
 800a474:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800a478:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800a47c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800a480:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800a484:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800a488:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800a48c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800a490:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800a494:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800a498:	429d      	cmp	r5, r3
 800a49a:	bf08      	it	eq
 800a49c:	4296      	cmpeq	r6, r2
 800a49e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800a4a2:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800a4a6:	d202      	bcs.n	800a4ae <__aeabi_ddiv+0x6e>
 800a4a8:	085b      	lsrs	r3, r3, #1
 800a4aa:	ea4f 0232 	mov.w	r2, r2, rrx
 800a4ae:	1ab6      	subs	r6, r6, r2
 800a4b0:	eb65 0503 	sbc.w	r5, r5, r3
 800a4b4:	085b      	lsrs	r3, r3, #1
 800a4b6:	ea4f 0232 	mov.w	r2, r2, rrx
 800a4ba:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800a4be:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800a4c2:	ebb6 0e02 	subs.w	lr, r6, r2
 800a4c6:	eb75 0e03 	sbcs.w	lr, r5, r3
 800a4ca:	bf22      	ittt	cs
 800a4cc:	1ab6      	subcs	r6, r6, r2
 800a4ce:	4675      	movcs	r5, lr
 800a4d0:	ea40 000c 	orrcs.w	r0, r0, ip
 800a4d4:	085b      	lsrs	r3, r3, #1
 800a4d6:	ea4f 0232 	mov.w	r2, r2, rrx
 800a4da:	ebb6 0e02 	subs.w	lr, r6, r2
 800a4de:	eb75 0e03 	sbcs.w	lr, r5, r3
 800a4e2:	bf22      	ittt	cs
 800a4e4:	1ab6      	subcs	r6, r6, r2
 800a4e6:	4675      	movcs	r5, lr
 800a4e8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800a4ec:	085b      	lsrs	r3, r3, #1
 800a4ee:	ea4f 0232 	mov.w	r2, r2, rrx
 800a4f2:	ebb6 0e02 	subs.w	lr, r6, r2
 800a4f6:	eb75 0e03 	sbcs.w	lr, r5, r3
 800a4fa:	bf22      	ittt	cs
 800a4fc:	1ab6      	subcs	r6, r6, r2
 800a4fe:	4675      	movcs	r5, lr
 800a500:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800a504:	085b      	lsrs	r3, r3, #1
 800a506:	ea4f 0232 	mov.w	r2, r2, rrx
 800a50a:	ebb6 0e02 	subs.w	lr, r6, r2
 800a50e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800a512:	bf22      	ittt	cs
 800a514:	1ab6      	subcs	r6, r6, r2
 800a516:	4675      	movcs	r5, lr
 800a518:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800a51c:	ea55 0e06 	orrs.w	lr, r5, r6
 800a520:	d018      	beq.n	800a554 <__aeabi_ddiv+0x114>
 800a522:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800a526:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800a52a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800a52e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a532:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800a536:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800a53a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800a53e:	d1c0      	bne.n	800a4c2 <__aeabi_ddiv+0x82>
 800a540:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800a544:	d10b      	bne.n	800a55e <__aeabi_ddiv+0x11e>
 800a546:	ea41 0100 	orr.w	r1, r1, r0
 800a54a:	f04f 0000 	mov.w	r0, #0
 800a54e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800a552:	e7b6      	b.n	800a4c2 <__aeabi_ddiv+0x82>
 800a554:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800a558:	bf04      	itt	eq
 800a55a:	4301      	orreq	r1, r0
 800a55c:	2000      	moveq	r0, #0
 800a55e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800a562:	bf88      	it	hi
 800a564:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800a568:	f63f aeaf 	bhi.w	800a2ca <__aeabi_dmul+0xde>
 800a56c:	ebb5 0c03 	subs.w	ip, r5, r3
 800a570:	bf04      	itt	eq
 800a572:	ebb6 0c02 	subseq.w	ip, r6, r2
 800a576:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800a57a:	f150 0000 	adcs.w	r0, r0, #0
 800a57e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800a582:	bd70      	pop	{r4, r5, r6, pc}
 800a584:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800a588:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800a58c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800a590:	bfc2      	ittt	gt
 800a592:	ebd4 050c 	rsbsgt	r5, r4, ip
 800a596:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800a59a:	bd70      	popgt	{r4, r5, r6, pc}
 800a59c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800a5a0:	f04f 0e00 	mov.w	lr, #0
 800a5a4:	3c01      	subs	r4, #1
 800a5a6:	e690      	b.n	800a2ca <__aeabi_dmul+0xde>
 800a5a8:	ea45 0e06 	orr.w	lr, r5, r6
 800a5ac:	e68d      	b.n	800a2ca <__aeabi_dmul+0xde>
 800a5ae:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800a5b2:	ea94 0f0c 	teq	r4, ip
 800a5b6:	bf08      	it	eq
 800a5b8:	ea95 0f0c 	teqeq	r5, ip
 800a5bc:	f43f af3b 	beq.w	800a436 <__aeabi_dmul+0x24a>
 800a5c0:	ea94 0f0c 	teq	r4, ip
 800a5c4:	d10a      	bne.n	800a5dc <__aeabi_ddiv+0x19c>
 800a5c6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800a5ca:	f47f af34 	bne.w	800a436 <__aeabi_dmul+0x24a>
 800a5ce:	ea95 0f0c 	teq	r5, ip
 800a5d2:	f47f af25 	bne.w	800a420 <__aeabi_dmul+0x234>
 800a5d6:	4610      	mov	r0, r2
 800a5d8:	4619      	mov	r1, r3
 800a5da:	e72c      	b.n	800a436 <__aeabi_dmul+0x24a>
 800a5dc:	ea95 0f0c 	teq	r5, ip
 800a5e0:	d106      	bne.n	800a5f0 <__aeabi_ddiv+0x1b0>
 800a5e2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800a5e6:	f43f aefd 	beq.w	800a3e4 <__aeabi_dmul+0x1f8>
 800a5ea:	4610      	mov	r0, r2
 800a5ec:	4619      	mov	r1, r3
 800a5ee:	e722      	b.n	800a436 <__aeabi_dmul+0x24a>
 800a5f0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800a5f4:	bf18      	it	ne
 800a5f6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800a5fa:	f47f aec5 	bne.w	800a388 <__aeabi_dmul+0x19c>
 800a5fe:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800a602:	f47f af0d 	bne.w	800a420 <__aeabi_dmul+0x234>
 800a606:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800a60a:	f47f aeeb 	bne.w	800a3e4 <__aeabi_dmul+0x1f8>
 800a60e:	e712      	b.n	800a436 <__aeabi_dmul+0x24a>

0800a610 <__gedf2>:
 800a610:	f04f 3cff 	mov.w	ip, #4294967295
 800a614:	e006      	b.n	800a624 <__cmpdf2+0x4>
 800a616:	bf00      	nop

0800a618 <__ledf2>:
 800a618:	f04f 0c01 	mov.w	ip, #1
 800a61c:	e002      	b.n	800a624 <__cmpdf2+0x4>
 800a61e:	bf00      	nop

0800a620 <__cmpdf2>:
 800a620:	f04f 0c01 	mov.w	ip, #1
 800a624:	f84d cd04 	str.w	ip, [sp, #-4]!
 800a628:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800a62c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800a630:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800a634:	bf18      	it	ne
 800a636:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800a63a:	d01b      	beq.n	800a674 <__cmpdf2+0x54>
 800a63c:	b001      	add	sp, #4
 800a63e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800a642:	bf0c      	ite	eq
 800a644:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800a648:	ea91 0f03 	teqne	r1, r3
 800a64c:	bf02      	ittt	eq
 800a64e:	ea90 0f02 	teqeq	r0, r2
 800a652:	2000      	moveq	r0, #0
 800a654:	4770      	bxeq	lr
 800a656:	f110 0f00 	cmn.w	r0, #0
 800a65a:	ea91 0f03 	teq	r1, r3
 800a65e:	bf58      	it	pl
 800a660:	4299      	cmppl	r1, r3
 800a662:	bf08      	it	eq
 800a664:	4290      	cmpeq	r0, r2
 800a666:	bf2c      	ite	cs
 800a668:	17d8      	asrcs	r0, r3, #31
 800a66a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800a66e:	f040 0001 	orr.w	r0, r0, #1
 800a672:	4770      	bx	lr
 800a674:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800a678:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800a67c:	d102      	bne.n	800a684 <__cmpdf2+0x64>
 800a67e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800a682:	d107      	bne.n	800a694 <__cmpdf2+0x74>
 800a684:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800a688:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800a68c:	d1d6      	bne.n	800a63c <__cmpdf2+0x1c>
 800a68e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800a692:	d0d3      	beq.n	800a63c <__cmpdf2+0x1c>
 800a694:	f85d 0b04 	ldr.w	r0, [sp], #4
 800a698:	4770      	bx	lr
 800a69a:	bf00      	nop

0800a69c <__aeabi_cdrcmple>:
 800a69c:	4684      	mov	ip, r0
 800a69e:	4610      	mov	r0, r2
 800a6a0:	4662      	mov	r2, ip
 800a6a2:	468c      	mov	ip, r1
 800a6a4:	4619      	mov	r1, r3
 800a6a6:	4663      	mov	r3, ip
 800a6a8:	e000      	b.n	800a6ac <__aeabi_cdcmpeq>
 800a6aa:	bf00      	nop

0800a6ac <__aeabi_cdcmpeq>:
 800a6ac:	b501      	push	{r0, lr}
 800a6ae:	f7ff ffb7 	bl	800a620 <__cmpdf2>
 800a6b2:	2800      	cmp	r0, #0
 800a6b4:	bf48      	it	mi
 800a6b6:	f110 0f00 	cmnmi.w	r0, #0
 800a6ba:	bd01      	pop	{r0, pc}

0800a6bc <__aeabi_dcmpeq>:
 800a6bc:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a6c0:	f7ff fff4 	bl	800a6ac <__aeabi_cdcmpeq>
 800a6c4:	bf0c      	ite	eq
 800a6c6:	2001      	moveq	r0, #1
 800a6c8:	2000      	movne	r0, #0
 800a6ca:	f85d fb08 	ldr.w	pc, [sp], #8
 800a6ce:	bf00      	nop

0800a6d0 <__aeabi_dcmplt>:
 800a6d0:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a6d4:	f7ff ffea 	bl	800a6ac <__aeabi_cdcmpeq>
 800a6d8:	bf34      	ite	cc
 800a6da:	2001      	movcc	r0, #1
 800a6dc:	2000      	movcs	r0, #0
 800a6de:	f85d fb08 	ldr.w	pc, [sp], #8
 800a6e2:	bf00      	nop

0800a6e4 <__aeabi_dcmple>:
 800a6e4:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a6e8:	f7ff ffe0 	bl	800a6ac <__aeabi_cdcmpeq>
 800a6ec:	bf94      	ite	ls
 800a6ee:	2001      	movls	r0, #1
 800a6f0:	2000      	movhi	r0, #0
 800a6f2:	f85d fb08 	ldr.w	pc, [sp], #8
 800a6f6:	bf00      	nop

0800a6f8 <__aeabi_dcmpge>:
 800a6f8:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a6fc:	f7ff ffce 	bl	800a69c <__aeabi_cdrcmple>
 800a700:	bf94      	ite	ls
 800a702:	2001      	movls	r0, #1
 800a704:	2000      	movhi	r0, #0
 800a706:	f85d fb08 	ldr.w	pc, [sp], #8
 800a70a:	bf00      	nop

0800a70c <__aeabi_dcmpgt>:
 800a70c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a710:	f7ff ffc4 	bl	800a69c <__aeabi_cdrcmple>
 800a714:	bf34      	ite	cc
 800a716:	2001      	movcc	r0, #1
 800a718:	2000      	movcs	r0, #0
 800a71a:	f85d fb08 	ldr.w	pc, [sp], #8
 800a71e:	bf00      	nop

0800a720 <main>:
/************ COM ***************/
int loopcnt = 0;


int main()
{
 800a720:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800a722:	4b2d      	ldr	r3, [pc, #180]	; (800a7d8 <main+0xb8>)
	CTRLSTATES_init(&CtrlStates);

	xCoRoutineCreate( vLedCtrlCoRoutine, 0, 0 );
	xCoRoutineCreate( vRemoteCtrlWatchdogCoRoutine, 1, 0 );

	xTaskCreate( IMU_Calculation, ( signed char * ) "IMU_Gyro", configMINIMAL_STACK_SIZE, NULL, 4, NULL );
 800a724:	2400      	movs	r4, #0
int loopcnt = 0;


int main()
{
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800a726:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800a72a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800a72e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

	RCC_Configuration();
 800a732:	f7f7 fe8b 	bl	800244c <RCC_Configuration>
	NVIC_Configuration();
 800a736:	f7f7 fea1 	bl	800247c <NVIC_Configuration>
	GPIO_Configuration();
 800a73a:	f7f7 fed3 	bl	80024e4 <GPIO_Configuration>
	USART_Configuration();
 800a73e:	f7f8 f80b 	bl	8002758 <USART_Configuration>
	setup_xBeeS6();
 800a742:	f7f8 fb9d 	bl	8002e80 <setup_xBeeS6>
	SPI_Configuration();
 800a746:	f7f8 f849 	bl	80027dc <SPI_Configuration>
	I2C_Configuration();
 800a74a:	f7f8 f879 	bl	8002840 <I2C_Configuration>
	TIM2_PWM_Configuration();
 800a74e:	f7f8 f8b9 	bl	80028c4 <TIM2_PWM_Configuration>
	TIM3_PWM_Configuration();
 800a752:	f7f8 f91f 	bl	8002994 <TIM3_PWM_Configuration>
	TIM4_Configuration();
 800a756:	f7f8 f983 	bl	8002a60 <TIM4_Configuration>
	ADC_Configuration();
 800a75a:	f7f8 f9f3 	bl	8002b44 <ADC_Configuration>
	EXTI_Configuration();
 800a75e:	f7f8 f9a7 	bl	8002ab0 <EXTI_Configuration>
	DMA_Configuration(&accBuffer[0]);
 800a762:	481e      	ldr	r0, [pc, #120]	; (800a7dc <main+0xbc>)
 800a764:	f7f8 f88a 	bl	800287c <DMA_Configuration>
	//TIM4_PWM_INPUT_Configuration();

	SETTINGS_init(&GlobalSettings);
 800a768:	481d      	ldr	r0, [pc, #116]	; (800a7e0 <main+0xc0>)
 800a76a:	f7f7 fbe9 	bl	8001f40 <SETTINGS_init>
	CTRLSTATES_init(&CtrlStates);
 800a76e:	481d      	ldr	r0, [pc, #116]	; (800a7e4 <main+0xc4>)
 800a770:	f7f7 fc24 	bl	8001fbc <CTRLSTATES_init>

	xCoRoutineCreate( vLedCtrlCoRoutine, 0, 0 );
 800a774:	2100      	movs	r1, #0
 800a776:	460a      	mov	r2, r1
 800a778:	481b      	ldr	r0, [pc, #108]	; (800a7e8 <main+0xc8>)
 800a77a:	f7fb fa41 	bl	8005c00 <xCoRoutineCreate>
	xCoRoutineCreate( vRemoteCtrlWatchdogCoRoutine, 1, 0 );
 800a77e:	2101      	movs	r1, #1
 800a780:	2200      	movs	r2, #0
 800a782:	481a      	ldr	r0, [pc, #104]	; (800a7ec <main+0xcc>)
 800a784:	f7fb fa3c 	bl	8005c00 <xCoRoutineCreate>

	xTaskCreate( IMU_Calculation, ( signed char * ) "IMU_Gyro", configMINIMAL_STACK_SIZE, NULL, 4, NULL );
 800a788:	2304      	movs	r3, #4
 800a78a:	e88d 0018 	stmia.w	sp, {r3, r4}
 800a78e:	4918      	ldr	r1, [pc, #96]	; (800a7f0 <main+0xd0>)
 800a790:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800a794:	4623      	mov	r3, r4
 800a796:	9402      	str	r4, [sp, #8]
 800a798:	9403      	str	r4, [sp, #12]
 800a79a:	4816      	ldr	r0, [pc, #88]	; (800a7f4 <main+0xd4>)
 800a79c:	f7fb ff2a 	bl	80065f4 <xTaskGenericCreate>
	xTaskCreate( PID_Calculation, ( signed char * ) "PID_Calc", configMINIMAL_STACK_SIZE, NULL, 3, NULL );
 800a7a0:	2303      	movs	r3, #3
 800a7a2:	e88d 0018 	stmia.w	sp, {r3, r4}
 800a7a6:	4914      	ldr	r1, [pc, #80]	; (800a7f8 <main+0xd8>)
 800a7a8:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800a7ac:	4623      	mov	r3, r4
 800a7ae:	9402      	str	r4, [sp, #8]
 800a7b0:	9403      	str	r4, [sp, #12]
 800a7b2:	4812      	ldr	r0, [pc, #72]	; (800a7fc <main+0xdc>)
 800a7b4:	f7fb ff1e 	bl	80065f4 <xTaskGenericCreate>
	xTaskCreate( IMU_Print_Values, ( signed char * ) "Print_Euler", configMINIMAL_STACK_SIZE, NULL, 2, NULL );
 800a7b8:	2302      	movs	r3, #2
 800a7ba:	e88d 0018 	stmia.w	sp, {r3, r4}
 800a7be:	4910      	ldr	r1, [pc, #64]	; (800a800 <main+0xe0>)
 800a7c0:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800a7c4:	4623      	mov	r3, r4
 800a7c6:	9402      	str	r4, [sp, #8]
 800a7c8:	9403      	str	r4, [sp, #12]
 800a7ca:	480e      	ldr	r0, [pc, #56]	; (800a804 <main+0xe4>)
 800a7cc:	f7fb ff12 	bl	80065f4 <xTaskGenericCreate>

	/* Start the tasks and timer running. */
	vTaskStartScheduler();
 800a7d0:	f7fc f8ee 	bl	80069b0 <vTaskStartScheduler>
 800a7d4:	e7fe      	b.n	800a7d4 <main+0xb4>
 800a7d6:	bf00      	nop
 800a7d8:	e000ed00 	.word	0xe000ed00
 800a7dc:	20002bd4 	.word	0x20002bd4
 800a7e0:	20002b88 	.word	0x20002b88
 800a7e4:	20002bc8 	.word	0x20002bc8
 800a7e8:	08001e89 	.word	0x08001e89
 800a7ec:	08001d19 	.word	0x08001d19
 800a7f0:	0800acd7 	.word	0x0800acd7
 800a7f4:	08001749 	.word	0x08001749
 800a7f8:	0800ace0 	.word	0x0800ace0
 800a7fc:	08001391 	.word	0x08001391
 800a800:	0800ace9 	.word	0x0800ace9
 800a804:	08001371 	.word	0x08001371

0800a808 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800a808:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800a80a:	f000 b804 	b.w	800a816 <LoopCopyDataInit>

0800a80e <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800a80e:	4b0c      	ldr	r3, [pc, #48]	; (800a840 <LoopFillZerobss+0x12>)
  ldr  r3, [r3, r1]
 800a810:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800a812:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800a814:	3104      	adds	r1, #4

0800a816 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800a816:	480b      	ldr	r0, [pc, #44]	; (800a844 <LoopFillZerobss+0x16>)
  ldr  r3, =_edata
 800a818:	4b0b      	ldr	r3, [pc, #44]	; (800a848 <LoopFillZerobss+0x1a>)
  adds  r2, r0, r1
 800a81a:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800a81c:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800a81e:	f4ff aff6 	bcc.w	800a80e <CopyDataInit>
  ldr  r2, =_sbss
 800a822:	4a0a      	ldr	r2, [pc, #40]	; (800a84c <LoopFillZerobss+0x1e>)
  b  LoopFillZerobss
 800a824:	f000 b803 	b.w	800a82e <LoopFillZerobss>

0800a828 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800a828:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800a82a:	f842 3b04 	str.w	r3, [r2], #4

0800a82e <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800a82e:	4b08      	ldr	r3, [pc, #32]	; (800a850 <LoopFillZerobss+0x22>)
  cmp  r2, r3
 800a830:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800a832:	f4ff aff9 	bcc.w	800a828 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800a836:	f7fc fda3 	bl	8007380 <SystemInit>
/* Call the application's entry point.*/
  bl  main
 800a83a:	f7ff ff71 	bl	800a720 <main>
  bx  lr    
 800a83e:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800a840:	0800ad28 	.word	0x0800ad28
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800a844:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800a848:	20000140 	.word	0x20000140
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 800a84c:	20000140 	.word	0x20000140
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800a850:	20002e04 	.word	0x20002e04

0800a854 <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800a854:	f7ff bffe 	b.w	800a854 <ADC1_2_IRQHandler>

0800a858 <ucExpectedStackBytes.5909>:
 800a858:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
 800a868:	a5a5 a5a5                                   ....

0800a86c <npio2_hw>:
 800a86c:	0f00 3fc9 0f00 4049 cb00 4096 0f00 40c9     ...?..I@...@...@
 800a87c:	5300 40fb cb00 4116 ed00 412f 0f00 4149     .S.@...A../A..IA
 800a88c:	3100 4162 5300 417b 3a00 418a cb00 4196     .1bA.S{A.:.A...A
 800a89c:	5c00 41a3 ed00 41af 7e00 41bc 0f00 41c9     .\.A...A.~.A...A
 800a8ac:	a000 41d5 3100 41e2 c200 41ee 5300 41fb     ...A.1.A...A.S.A
 800a8bc:	f200 4203 3a00 420a 8300 4210 cb00 4216     ...B.:.B...B...B
 800a8cc:	1400 421d 5c00 4223 a500 4229 ed00 422f     ...B.\#B..)B../B
 800a8dc:	3600 4236 7e00 423c c700 4242 0f00 4249     .66B.~<B..BB..IB

0800a8ec <two_over_pi>:
 800a8ec:	00a2 0000 00f9 0000 0083 0000 006e 0000     ............n...
 800a8fc:	004e 0000 0044 0000 0015 0000 0029 0000     N...D.......)...
 800a90c:	00fc 0000 0027 0000 0057 0000 00d1 0000     ....'...W.......
 800a91c:	00f5 0000 0034 0000 00dd 0000 00c0 0000     ....4...........
 800a92c:	00db 0000 0062 0000 0095 0000 0099 0000     ....b...........
 800a93c:	003c 0000 0043 0000 0090 0000 0041 0000     <...C.......A...
 800a94c:	00fe 0000 0051 0000 0063 0000 00ab 0000     ....Q...c.......
 800a95c:	00de 0000 00bb 0000 00c5 0000 0061 0000     ............a...
 800a96c:	00b7 0000 0024 0000 006e 0000 003a 0000     ....$...n...:...
 800a97c:	0042 0000 004d 0000 00d2 0000 00e0 0000     B...M...........
 800a98c:	0006 0000 0049 0000 002e 0000 00ea 0000     ....I...........
 800a99c:	0009 0000 00d1 0000 0092 0000 001c 0000     ................
 800a9ac:	00fe 0000 001d 0000 00eb 0000 001c 0000     ................
 800a9bc:	00b1 0000 0029 0000 00a7 0000 003e 0000     ....).......>...
 800a9cc:	00e8 0000 0082 0000 0035 0000 00f5 0000     ........5.......
 800a9dc:	002e 0000 00bb 0000 0044 0000 0084 0000     ........D.......
 800a9ec:	00e9 0000 009c 0000 0070 0000 0026 0000     ........p...&...
 800a9fc:	00b4 0000 005f 0000 007e 0000 0041 0000     ...._...~...A...
 800aa0c:	0039 0000 0091 0000 00d6 0000 0039 0000     9...........9...
 800aa1c:	0083 0000 0053 0000 0039 0000 00f4 0000     ....S...9.......
 800aa2c:	009c 0000 0084 0000 005f 0000 008b 0000     ........_.......
 800aa3c:	00bd 0000 00f9 0000 0028 0000 003b 0000     ........(...;...
 800aa4c:	001f 0000 00f8 0000 0097 0000 00ff 0000     ................
 800aa5c:	00de 0000 0005 0000 0098 0000 000f 0000     ................
 800aa6c:	00ef 0000 002f 0000 0011 0000 008b 0000     ..../...........
 800aa7c:	005a 0000 000a 0000 006d 0000 001f 0000     Z.......m.......
 800aa8c:	006d 0000 0036 0000 007e 0000 00cf 0000     m...6...~.......
 800aa9c:	0027 0000 00cb 0000 0009 0000 00b7 0000     '...............
 800aaac:	004f 0000 0046 0000 003f 0000 0066 0000     O...F...?...f...
 800aabc:	009e 0000 005f 0000 00ea 0000 002d 0000     ...._.......-...
 800aacc:	0075 0000 0027 0000 00ba 0000 00c7 0000     u...'...........
 800aadc:	00eb 0000 00e5 0000 00f1 0000 007b 0000     ............{...
 800aaec:	003d 0000 0007 0000 0039 0000 00f7 0000     =.......9.......
 800aafc:	008a 0000 0052 0000 0092 0000 00ea 0000     ....R...........
 800ab0c:	006b 0000 00fb 0000 005f 0000 00b1 0000     k......._.......
 800ab1c:	001f 0000 008d 0000 005d 0000 0008 0000     ........].......
 800ab2c:	0056 0000 0003 0000 0030 0000 0046 0000     V.......0...F...
 800ab3c:	00fc 0000 007b 0000 006b 0000 00ab 0000     ....{...k.......
 800ab4c:	00f0 0000 00cf 0000 00bc 0000 0020 0000     ............ ...
 800ab5c:	009a 0000 00f4 0000 0036 0000 001d 0000     ........6.......
 800ab6c:	00a9 0000 00e3 0000 0091 0000 0061 0000     ............a...
 800ab7c:	005e 0000 00e6 0000 001b 0000 0008 0000     ^...............
 800ab8c:	0065 0000 0099 0000 0085 0000 005f 0000     e..........._...
 800ab9c:	0014 0000 00a0 0000 0068 0000 0040 0000     ........h...@...
 800abac:	008d 0000 00ff 0000 00d8 0000 0080 0000     ................
 800abbc:	004d 0000 0073 0000 0027 0000 0031 0000     M...s...'...1...
 800abcc:	0006 0000 0006 0000 0015 0000 0056 0000     ............V...
 800abdc:	00ca 0000 0073 0000 00a8 0000 00c9 0000     ....s...........
 800abec:	0060 0000 00e2 0000 007b 0000 00c0 0000     `.......{.......
 800abfc:	008c 0000 006b 0000                         ....k...

0800ac04 <init_jk>:
 800ac04:	0004 0000 0007 0000 0009 0000               ............

0800ac10 <PIo2>:
 800ac10:	0000 3fc9 0000 39f0 0000 37da 0000 33a2     ...?...9...7...3
 800ac20:	0000 2e84 0000 2b50 0000 27c2 0000 22d0     ......P+...'..."
 800ac30:	0000 1fc4 0000 1bc6 0000 1744 0000 0000     ..........D.....

0800ac40 <atanhi>:
 800ac40:	bb4f 0561 ac67 3fdd 2d18 5444 21fb 3fe9     O.a.g..?.-DT.!.?
 800ac50:	f69b d281 730b 3fef 2d18 5444 21fb 3ff9     .....s.?.-DT.!.?

0800ac60 <atanlo>:
 800ac60:	65e2 222f 2b7f 3c7a 5c07 3314 a626 3c81     .e/".+z<.\.3&..<
 800ac70:	cbbd 7af0 0788 3c70 5c07 3314 a626 3c91     ...z..p<.\.3&..<

0800ac80 <atanhi>:
 800ac80:	6338 3eed 0fda 3f49 985e 3f7b 0fda 3fc9     8c.>..I?^.{?...?

0800ac90 <atanlo>:
 800ac90:	3769 31ac 2168 3322 0fb4 3314 2168 33a2     i7.1h!"3...3h!.3
 800aca0:	6574 7473 253a 2c64 6425 252c 0d64 000a     test:%d,%d,%d...
 800acb0:	7245 6f72 2072 7947 6f72 5420 7365 2174     Error Gyro Test!
 800acc0:	0d0a 5700 7461 6863 6f64 2067 7245 6f72     ...Watchdog Erro
 800acd0:	2172 2521 0a64 4900 554d 475f 7279 006f     r!!%d..IMU_Gyro.
 800ace0:	4950 5f44 6143 636c 5000 6972 746e 455f     PID_Calc.Print_E
 800acf0:	6c75 7265 2800 756e 6c6c 0029 4449 454c     uler.(null).IDLE
 800ad00:	5400 726d 5320 6376 0000 0000 7173 7472     .Tmr Svc....sqrt
 800ad10:	0000 0000 7361 6e69 0066 0000 7173 7472     ....asinf...sqrt
 800ad20:	0066 0000 0043 0000                         f...C...
